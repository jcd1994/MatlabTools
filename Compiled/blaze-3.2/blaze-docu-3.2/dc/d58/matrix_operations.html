<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Matrix Operations</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Matrix Operations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#matrix_operations_constructors">Constructors</a><ul><li class="level2"><a href="#matrix_operations_default_construction">Default Construction</a></li>
<li class="level2"><a href="#matrix_operations_size_construction">Construction with Specific Size</a></li>
<li class="level2"><a href="#matrix_operations_initialization_constructors">Initialization Constructors</a></li>
<li class="level2"><a href="#matrix_operations_array_construction">Array Construction</a></li>
<li class="level2"><a href="#matrix_operations_initializer_list_construction">matrix_operations_initializer_list_construction</a></li>
<li class="level2"><a href="#matrix_operations_copy_construction">Copy Construction</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_assignment">Assignment</a><ul><li class="level2"><a href="#matrix_operations_homogeneous_assignment">Homogeneous Assignment</a></li>
<li class="level2"><a href="#matrix_operations_array_assignment">Array Assignment</a></li>
<li class="level2"><a href="#matrix_operations_initializer_list_assignment">Initializer List Assignment</a></li>
<li class="level2"><a href="#matrix_operations_copy_assignment">Copy Assignment</a></li>
<li class="level2"><a href="#matrix_operations_compound_assignment">Compound Assignment</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_element_access">Element Access</a></li>
<li class="level1"><a href="#matrix_operations_element_insertion">Element Insertion</a></li>
<li class="level1"><a href="#matrix_operations_non_modifying_operations">Non-Modifying Operations</a><ul><li class="level2"><a href="#matrix_operations_rows">.rows()</a></li>
<li class="level2"><a href="#matrix_operations_columns">.columns()</a></li>
<li class="level2"><a href="#matrix_operations_capacity">.capacity()</a></li>
<li class="level2"><a href="#matrix_operations_nonzeros">.nonZeros()</a></li>
<li class="level2"><a href="#matrix_operations_isnan">isnan()</a></li>
<li class="level2"><a href="#matrix_operations_isdefault">isDefault()</a></li>
<li class="level2"><a href="#matrix_operations_isSquare">isSquare()</a></li>
<li class="level2"><a href="#matrix_operations_issymmetric">isSymmetric()</a></li>
<li class="level2"><a href="#matrix_operations_isUniform">isUniform()</a></li>
<li class="level2"><a href="#matrix_operations_islower">isLower()</a></li>
<li class="level2"><a href="#matrix_operations_isunilower">isUniLower()</a></li>
<li class="level2"><a href="#matrix_operations_isstrictlylower">isStrictlyLower()</a></li>
<li class="level2"><a href="#matrix_operations_isUpper">isUpper()</a></li>
<li class="level2"><a href="#matrix_operations_isuniupper">isUniUpper()</a></li>
<li class="level2"><a href="#matrix_operations_isstrictlyupper">isStrictlyUpper()</a></li>
<li class="level2"><a href="#matrix_operations_isdiagonal">isDiagonal()</a></li>
<li class="level2"><a href="#matrix_operations_isidentity">isIdentity()</a></li>
<li class="level2"><a href="#matrix_operations_matrix_determinant">det()</a></li>
<li class="level2"><a href="#matrix_operations_matrix_trans">trans()</a></li>
<li class="level2"><a href="#matrix_operations_ctrans">ctrans()</a></li>
<li class="level2"><a href="#matrix_operations_matrix_evaluate">eval() / evaluate()</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_modifying_operations">Modifying Operations</a><ul><li class="level2"><a href="#matrix_operations_resize_reserve">.resize() / .reserve()</a></li>
<li class="level2"><a href="#matrix_operations_shrinkToFit">.shrinkToFit()</a></li>
<li class="level2"><a href="#matrix_operations_reset_clear">reset() / clear</a></li>
<li class="level2"><a href="#matrix_operations_matrix_transpose">transpose()</a></li>
<li class="level2"><a href="#matrix_operations_ctranspose">ctranspose()</a></li>
<li class="level2"><a href="#matrix_operations_swap">swap()</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_arithmetic_operations">Arithmetic Operations</a><ul><li class="level2"><a href="#matrix_operations_min_max">min() / max()</a></li>
<li class="level2"><a href="#matrix_operators_trace">trace()</a></li>
<li class="level2"><a href="#matrix_operators_abs">abs()</a></li>
<li class="level2"><a href="#matrix_operators_rounding_functions">floor() / ceil() / trunc() / round()</a></li>
<li class="level2"><a href="#matrix_operators_conj">conj()</a></li>
<li class="level2"><a href="#matrix_operators_real">real()</a></li>
<li class="level2"><a href="#matrix_operators_imag">imag()</a></li>
<li class="level2"><a href="#matrix_operators_sqrt">sqrt() / invsqrt()</a></li>
<li class="level2"><a href="#matrix_operators_cbrt">cbrt() / invcbrt()</a></li>
<li class="level2"><a href="#matrix_operators_clamp">clamp()</a></li>
<li class="level2"><a href="#matrix_operators_pow">pow()</a></li>
<li class="level2"><a href="#matrix_operators_exp">exp()</a></li>
<li class="level2"><a href="#matrix_operators_log">log() / log2() / log10()</a></li>
<li class="level2"><a href="#matrix_operators_trigonometric_functions">sin() / cos() / tan() / asin() / acos() / atan()</a></li>
<li class="level2"><a href="#matrix_operators_hyperbolic_functions">sinh() / cosh() / tanh() / asinh() / acosh() / atanh()</a></li>
<li class="level2"><a href="#matrix_operators_erf">erf() / erfc()</a></li>
<li class="level2"><a href="#matrix_operations_map">map() / forEach()</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_declaration_operations">Declaration Operations</a><ul><li class="level2"><a href="#matrix_operations_declsym">declsym()</a></li>
<li class="level2"><a href="#matrix_operations_declherm">declherm()</a></li>
<li class="level2"><a href="#matrix_operations_decllow">decllow()</a></li>
<li class="level2"><a href="#matrix_operations_declupp">declupp()</a></li>
<li class="level2"><a href="#matrix_operations_decldiag">decldiag()</a></li>
<li class="level2"><a href="#matrix_operations_declid">declid()</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_matrix_inversion">Matrix Inversion</a></li>
<li class="level1"><a href="#matrix_operations_decomposition">Matrix Decomposition</a><ul><li class="level2"><a href="#matrix_operations_decomposition_lu">LU Decomposition</a></li>
<li class="level2"><a href="#matrix_operations_decomposition_llh">Cholesky Decomposition</a></li>
<li class="level2"><a href="#matrix_operations_decomposition_qr">QR Decomposition</a></li>
<li class="level2"><a href="#matrix_operations_decomposition_rq">RQ Decomposition</a></li>
<li class="level2"><a href="#matrix_operations_decomposition_ql">QL Decomposition</a></li>
<li class="level2"><a href="#matrix_operations_decomposition_lq">LQ Decomposition</a></li>
</ul>
</li>
<li class="level1"><a href="#matrix_operations_eigenvalues">Eigenvalues/Eigenvectors</a></li>
<li class="level1"><a href="#matrix_operations_singularvalues">Singular Values/Singular Vectors</a></li>
</ul>
</div>
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_constructors"></a>
Constructors</h1>
<hr/>
<p>Matrices are just as easy and intuitive to create as vectors. Still, there are a few rules to be aware of:</p><ul>
<li>In case the last template parameter (the storage order) is omitted, the matrix is per default stored in row-major order.</li>
<li>The elements of a <code>StaticMatrix</code> or <code>HybridMatrix</code> are default initialized (i.e. built-in data types are initialized to 0, class types are initialized via the default constructor).</li>
<li>Newly allocated elements of a <code>DynamicMatrix</code> or <code>CompressedMatrix</code> remain uninitialized if they are of built-in type and are default constructed if they are of class type.</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_default_construction"></a>
Default Construction</h2>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div><div class="line"></div><div class="line"><span class="comment">// All matrices can be default constructed. Whereas the size of</span></div><div class="line"><span class="comment">// a StaticMatrix is fixed via the second and third template</span></div><div class="line"><span class="comment">// parameter, the initial size of a constructed DynamicMatrix</span></div><div class="line"><span class="comment">// or CompressedMatrix is 0.</span></div><div class="line">StaticMatrix&lt;int,2UL,2UL&gt; M1;             <span class="comment">// Instantiation of a 2x2 integer row-major</span></div><div class="line">                                          <span class="comment">// matrix. All elements are initialized to 0.</span></div><div class="line">DynamicMatrix&lt;float&gt; M2;                  <span class="comment">// Instantiation of a single precision dynamic</span></div><div class="line">                                          <span class="comment">// row-major matrix with 0 rows and 0 columns.</span></div><div class="line">DynamicMatrix&lt;double,columnMajor&gt; M3;     <span class="comment">// Instantiation of a double precision dynamic</span></div><div class="line">                                          <span class="comment">// column-major matrix with 0 rows and 0 columns.</span></div><div class="line">CompressedMatrix&lt;int&gt; M4;                 <span class="comment">// Instantiation of a compressed integer</span></div><div class="line">                                          <span class="comment">// row-major matrix of size 0x0.</span></div><div class="line">CompressedMatrix&lt;double,columnMajor&gt; M5;  <span class="comment">// Instantiation of a compressed double precision</span></div><div class="line">                                          <span class="comment">// column-major matrix of size 0x0.</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_size_construction"></a>
Construction with Specific Size</h2>
<p>The <code>DynamicMatrix</code>, <code>HybridMatrix</code>, and <code>CompressedMatrix</code> classes offer a constructor that allows to immediately give the matrices a specific number of rows and columns:</p>
<div class="fragment"><div class="line">DynamicMatrix&lt;int&gt; M6( 5UL, 4UL );                   <span class="comment">// Instantiation of a 5x4 dynamic row-major</span></div><div class="line">                                                     <span class="comment">// matrix. The elements are not initialized.</span></div><div class="line">HybridMatrix&lt;double,5UL,9UL&gt; M7( 3UL, 7UL );         <span class="comment">// Instantiation of a 3x7 hybrid row-major</span></div><div class="line">                                                     <span class="comment">// matrix. The elements are not initialized.</span></div><div class="line">CompressedMatrix&lt;float,columnMajor&gt; M8( 8UL, 6UL );  <span class="comment">// Instantiation of an empty 8x6 compressed</span></div><div class="line">                                                     <span class="comment">// column-major matrix.</span></div></div><!-- fragment --><p>Note that dense matrices (in this case <code>DynamicMatrix</code> and <code>HybridMatrix</code>) immediately allocate enough capacity for all matrix elements. Sparse matrices on the other hand (in this example <code>CompressedMatrix</code>) merely acquire the size, but don't necessarily allocate memory.</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_initialization_constructors"></a>
Initialization Constructors</h2>
<p>All dense matrix classes offer a constructor for a direct, homogeneous initialization of all matrix elements. In contrast, for sparse matrices the predicted number of non-zero elements can be specified.</p>
<div class="fragment"><div class="line">StaticMatrix&lt;int,4UL,3UL,columnMajor&gt; M9( 7 );  <span class="comment">// Instantiation of a 4x3 integer column-major</span></div><div class="line">                                                <span class="comment">// matrix. All elements are initialized to 7.</span></div><div class="line">DynamicMatrix&lt;float&gt; M10( 2UL, 5UL, 2.0F );     <span class="comment">// Instantiation of a 2x5 single precision row-major</span></div><div class="line">                                                <span class="comment">// matrix. All elements are initialized to 2.0F.</span></div><div class="line">CompressedMatrix&lt;int&gt; M11( 3UL, 4UL, 4 );       <span class="comment">// Instantiation of a 3x4 integer row-major</span></div><div class="line">                                                <span class="comment">// matrix with capacity for 4 non-zero elements.</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_array_construction"></a>
Array Construction</h2>
<p>Alternatively, all dense matrix classes offer a constructor for an initialization with a dynamic or static array. If the matrix is initialized from a dynamic array, the constructor expects the dimensions of values provided by the array as first and second argument, the array as third argument. In case of a static array, the fixed size of the array is used:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::unique_ptr&lt;double[]&gt; array1( <span class="keyword">new</span> <span class="keywordtype">double</span>[6] );</div><div class="line"><span class="comment">// ... Initialization of the dynamic array</span></div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,2UL,3UL&gt;</a> M12( 2UL, 3UL, array1.get() );</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> array2[2][2] = { { 4, -5 }, { -6, 7 } };</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,2UL,rowMajor&gt;</a> M13( array2 );</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_initializer_list_construction"></a>
matrix_operations_initializer_list_construction</h2>
<p>In addition, all dense matrix classes can be directly initialized by means of an initializer list:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float,columnMajor&gt;</a> M14{ {  3.1F,  6.4F },</div><div class="line">                                             { -0.9F, -1.2F },</div><div class="line">                                             {  4.8F,  0.6F } };</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_copy_construction"></a>
Copy Construction</h2>
<p>All dense and sparse matrices can be created as a copy of another dense or sparse matrix.</p>
<div class="fragment"><div class="line">StaticMatrix&lt;int,5UL,4UL,rowMajor&gt; M15( M6 );    <span class="comment">// Instantiation of the dense row-major matrix M15</span></div><div class="line">                                                 <span class="comment">// as copy of the dense row-major matrix M6.</span></div><div class="line">DynamicMatrix&lt;float,columnMajor&gt; M16( M8 );      <span class="comment">// Instantiation of the dense column-major matrix M16</span></div><div class="line">                                                 <span class="comment">// as copy of the sparse column-major matrix M8.</span></div><div class="line">CompressedMatrix&lt;double,columnMajor&gt; M17( M7 );  <span class="comment">// Instantiation of the compressed column-major matrix</span></div><div class="line">                                                 <span class="comment">// M17 as copy of the dense row-major matrix M7.</span></div><div class="line">CompressedMatrix&lt;float,rowMajor&gt; M18( M8 );      <span class="comment">// Instantiation of the compressed row-major matrix</span></div><div class="line">                                                 <span class="comment">// M18 as copy of the compressed column-major matrix M8.</span></div></div><!-- fragment --><p>Note that it is not possible to create a <code>StaticMatrix</code> as a copy of a matrix with a different number of rows and/or columns:</p>
<div class="fragment"><div class="line">StaticMatrix&lt;int,4UL,5UL,rowMajor&gt; M19( M6 );     <span class="comment">// Runtime error: Number of rows and columns</span></div><div class="line">                                                  <span class="comment">// does not match!</span></div><div class="line">StaticMatrix&lt;int,4UL,4UL,columnMajor&gt; M20( M9 );  <span class="comment">// Compile time error: Number of columns does</span></div><div class="line">                                                  <span class="comment">// not match!</span></div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_assignment"></a>
Assignment</h1>
<hr/>
<p>There are several types of assignment to dense and sparse matrices: <a class="el" href="../../dc/d58/matrix_operations.html#matrix_operations_homogeneous_assignment">Homogeneous Assignment</a>, <a class="el" href="../../dc/d58/matrix_operations.html#matrix_operations_array_assignment">Array Assignment</a>, <a class="el" href="../../dc/d58/matrix_operations.html#matrix_operations_copy_assignment">Copy Assignment</a>, and <a class="el" href="../../dc/d58/matrix_operations.html#matrix_operations_compound_assignment">Compound Assignment</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_homogeneous_assignment"></a>
Homogeneous Assignment</h2>
<p>It is possible to assign the same value to all elements of a dense matrix. All dense matrix classes provide an according assignment operator:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,3UL,2UL&gt;</a> M1;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> M2;</div><div class="line"></div><div class="line"><span class="comment">// Setting all integer elements of the StaticMatrix to 4</span></div><div class="line">M1 = 4;</div><div class="line"></div><div class="line"><span class="comment">// Setting all double precision elements of the DynamicMatrix to 3.5</span></div><div class="line">M2 = 3.5</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_array_assignment"></a>
Array Assignment</h2>
<p>Dense matrices can also be assigned a static array:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,2UL,rowMajor&gt;</a> M1;</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,2UL,columnMajor&gt;</a> M2;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> M3;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> array1[2][2] = { { 1, 2 }, { 3, 4 } };</div><div class="line"><span class="keywordtype">double</span> array2[3][2] = { { 3.1, 6.4 }, { -0.9, -1.2 }, { 4.8, 0.6 } };</div><div class="line"></div><div class="line">M1 = array1;</div><div class="line">M2 = array1;</div><div class="line">M3 = array2;</div></div><!-- fragment --><p>Note that the dimensions of the static array have to match the size of a <code>StaticMatrix</code>, whereas a <code>DynamicMatrix</code> is resized according to the array dimensions:</p>
<p><img class="formulaInl" alt="$ M3 = \left(\begin{array}{*{2}{c}} 3.1 &amp; 6.4 \\ -0.9 &amp; -1.2 \\ 4.8 &amp; 0.6 \\ \end{array}\right)$" src="../../form_174.png"/></p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_initializer_list_assignment"></a>
Initializer List Assignment</h2>
<p>Alternatively, it is possible to directly assign an initializer list to a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> M;</div><div class="line">M = { { 3.1, 6.4 }, { -0.9, -1.2 }, { 4.8, 0.6 } };</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_copy_assignment"></a>
Copy Assignment</h2>
<p>All kinds of matrices can be assigned to each other. The only restriction is that since a <code>StaticMatrix</code> cannot change its size, the assigned matrix must match both in the number of rows and in the number of columns.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,3UL,2UL,rowMajor&gt;</a>  M1;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a>         M2( 3UL, 2UL );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float,rowMajor&gt;</a>       M3( 5UL, 2UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,rowMajor&gt;</a>      M4( 3UL, 2UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float,columnMajor&gt;</a> M5( 3UL, 2UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization of the matrices</span></div><div class="line"></div><div class="line">M1 = M2;  <span class="comment">// OK: Assignment of a 3x2 dense row-major matrix to another 3x2 dense row-major matrix</span></div><div class="line">M1 = M4;  <span class="comment">// OK: Assignment of a 3x2 sparse row-major matrix to a 3x2 dense row-major matrix</span></div><div class="line">M1 = M3;  <span class="comment">// Runtime error: Cannot assign a 5x2 matrix to a 3x2 static matrix</span></div><div class="line">M1 = M5;  <span class="comment">// OK: Assignment of a 3x2 sparse column-major matrix to a 3x2 dense row-major matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_compound_assignment"></a>
Compound Assignment</h2>
<p>Compound assignment is also available for matrices: addition assignment, subtraction assignment, and multiplication assignment. In contrast to plain assignment, however, the number of rows and columns of the two operands have to match according to the arithmetic operation.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a>    M1;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a>           M2( 2UL, 3UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float,columnMajor&gt;</a>   M3( 2UL, 3UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float,rowMajor&gt;</a>      M4( 2UL, 4UL );</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;float,2UL,4UL,rowMajor&gt;</a>  M5;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float,rowMajor&gt;</a>      M6( 3UL, 2UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization of the matrices</span></div><div class="line"></div><div class="line">M1 += M2;  <span class="comment">// OK: Addition assignment between two row-major matrices of the same dimensions</span></div><div class="line">M1 -= M3;  <span class="comment">// OK: Subtraction assignment between between a row-major and a column-major matrix</span></div><div class="line">M1 += M4;  <span class="comment">// Runtime error: No compound assignment between matrices of different size</span></div><div class="line">M1 -= M5;  <span class="comment">// Compilation error: No compound assignment between matrices of different size</span></div><div class="line">M2 *= M6;  <span class="comment">// OK: Multiplication assignment between two row-major matrices</span></div></div><!-- fragment --><p>Note that the multiplication assignment potentially changes the number of columns of the target matrix:</p>
<p><img class="formulaInl" alt="$\left(\begin{array}{*{3}{c}} 2 &amp; 0 &amp; 1 \\ 0 &amp; 3 &amp; 2 \\ \end{array}\right) \times \left(\begin{array}{*{2}{c}} 4 &amp; 0 \\ 1 &amp; 0 \\ 0 &amp; 3 \\ \end{array}\right) = \left(\begin{array}{*{2}{c}} 8 &amp; 3 \\ 3 &amp; 6 \\ \end{array}\right)$" src="../../form_175.png"/></p>
<p>Since a <code>StaticMatrix</code> cannot change its size, only a square StaticMatrix can be used in a multiplication assignment with other square matrices of the same dimensions.</p>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_element_access"></a>
Element Access</h1>
<hr/>
<p>The easiest way to access a specific dense or sparse matrix element is via the function call operator. The indices to access a matrix are zero-based:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> M1( 4UL, 6UL );</div><div class="line">M1(0,0) = 1;</div><div class="line">M1(0,1) = 3;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> M2( 5UL, 3UL );</div><div class="line">M2(0,2) =  4.1;</div><div class="line">M2(1,1) = -6.3;</div></div><!-- fragment --><p>Since dense matrices allocate enough memory for all contained elements, using the function call operator on a dense matrix directly returns a reference to the accessed value. In case of a sparse matrix, if the accessed value is currently not contained in the matrix, the value is inserted into the matrix prior to returning a reference to the value, which can be much more expensive than the direct access to a dense matrix. Consider the following example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int&gt;</a> M1( 4UL, 4UL );</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>(); ++i ) {</div><div class="line">   <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j=0UL; j&lt;M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ac93d8d0a3dac721b2d3ba07e09da0247">columns</a>(); ++j ) {</div><div class="line">      ... = M1(i,j);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Although the compressed matrix is only used for read access within the for loop, using the function call operator temporarily inserts 16 non-zero elements into the matrix. Therefore, all matrices (sparse as well as dense) offer an alternate way via the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99" title="Returns an iterator to the first element of row/column i. ">begin()</a></code>, <code><a class="el" href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174" title="Returns an iterator to the first element of row/column i. ">cbegin()</a></code>, <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a></code> and <code><a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a></code> functions to traverse all contained elements by iterator. Note that it is not possible to traverse all elements of the matrix, but that it is only possible to traverse elements in a row/column-wise fashion. In case of a non-const matrix, <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99" title="Returns an iterator to the first element of row/column i. ">begin()</a></code> and <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a></code> return an <code>Iterator</code>, which allows a manipulation of the non-zero value, in case of a constant matrix or in case <code><a class="el" href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174" title="Returns an iterator to the first element of row/column i. ">cbegin()</a></code> or <code><a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a></code> are used a <code>ConstIterator</code> is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div><div class="line"></div><div class="line">CompressedMatrix&lt;int,rowMajor&gt; M1( 4UL, 6UL );</div><div class="line"></div><div class="line"><span class="comment">// Traversing the matrix by Iterator</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>(); ++i ) {</div><div class="line">   <span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">CompressedMatrix&lt;int,rowMajor&gt;::Iterator</a> it=A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ae49c75cee4d52bced7aa8ba685b96b47">begin</a>(i); it!=A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a01d7b479f64e924c4465678baad18ac6">end</a>(i); ++it ) {</div><div class="line">      it-&gt;value() = ...;  <span class="comment">// OK: Write access to the value of the non-zero element.</span></div><div class="line">      ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div><div class="line">      it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div><div class="line">      ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the non-zero element.</span></div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Traversing the matrix by ConstIterator</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>(); ++i ) {</div><div class="line">   <span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">CompressedMatrix&lt;int,rowMajor&gt;::ConstIterator</a> it=A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aeb550e564651c8e29c100a4628206187">cbegin</a>(i); it!=A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a72e9c2a133ad215c748e539ef0be2538">cend</a>(i); ++it ) {</div><div class="line">      it-&gt;value() = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div><div class="line">      ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div><div class="line">      it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div><div class="line">      ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the non-zero element.</span></div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Note that <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99" title="Returns an iterator to the first element of row/column i. ">begin()</a></code>, <code><a class="el" href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174" title="Returns an iterator to the first element of row/column i. ">cbegin()</a></code>, <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a></code>, and <code><a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a></code> are also available as free functions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>(); ++i ) {</div><div class="line">   <span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">CompressedMatrix&lt;int,rowMajor&gt;::Iterator</a> it=<a class="code" href="../../dd/d7a/group__matrix.html#ga8f0c048c86b644d1b9be16edc43d1b99">begin</a>( A, i ); it!=<a class="code" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6">end</a>( A, i ); ++it ) {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;A.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>(); ++i ) {</div><div class="line">   <span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">CompressedMatrix&lt;int,rowMajor&gt;::ConstIterator</a> it=<a class="code" href="../../dd/d7a/group__matrix.html#ga369515ccbfb1641af7b6fc3b9e510174">cbegin</a>( A, i ); it!=<a class="code" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023">cend</a>( A, i ); ++it ) {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_element_insertion"></a>
Element Insertion</h1>
<hr/>
<p>Whereas a dense matrix always provides enough capacity to store all matrix elements, a sparse matrix only stores the non-zero elements. Therefore it is necessary to explicitly add elements to the matrix. The first possibility to add elements to a sparse matrix is the function call operator:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div><div class="line"></div><div class="line">CompressedMatrix&lt;int&gt; M1( 3UL, 4UL );</div><div class="line">M1(1,2) = 9;</div></div><!-- fragment --><p>In case the element at the given position is not yet contained in the sparse matrix, it is automatically inserted. Otherwise the old value is replaced by the new value 2. The operator returns a reference to the sparse vector element.<br />
An alternative is the <code><a class="el" href="../../dc/d7b/group__simd.html#ga123bb79d57112645ef44ef5675361a4c" title="Sets all values in the vector to the given 1-byte integral value. ">set()</a></code> function: In case the element is not yet contained in the matrix the element is inserted, else the element's value is modified:</p>
<div class="fragment"><div class="line"><span class="comment">// Insert or modify the value at position (2,0)</span></div><div class="line">M1.set( 2, 0, 1 );</div></div><!-- fragment --><p>However, insertion of elements can be better controlled via the <code>insert()</code> function. In contrast to the function call operator and the <code><a class="el" href="../../dc/d7b/group__simd.html#ga123bb79d57112645ef44ef5675361a4c" title="Sets all values in the vector to the given 1-byte integral value. ">set()</a></code> function it emits an exception in case the element is already contained in the matrix. In order to check for this case, the <code>find()</code> function can be used:</p>
<div class="fragment"><div class="line"><span class="comment">// In case the element at position (2,3) is not yet contained in the matrix it is inserted</span></div><div class="line"><span class="comment">// with a value of 4.</span></div><div class="line"><span class="keywordflow">if</span>( M1.find( 2, 3 ) == M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a01d7b479f64e924c4465678baad18ac6">end</a>( 2 ) )</div><div class="line">   M1.insert( 2, 3, 4 );</div></div><!-- fragment --><p>Although the <code>insert()</code> function is very flexible, due to performance reasons it is not suited for the setup of large sparse matrices. A very efficient, yet also very low-level way to fill a sparse matrix is the <code>append()</code> function. It requires the sparse matrix to provide enough capacity to insert a new element in the specified row/column. Additionally, the index of the new element must be larger than the index of the previous element in the same row/column. Violating these conditions results in undefined behavior!</p>
<div class="fragment"><div class="line">M1.reserve( 0, 3 );     <span class="comment">// Reserving space for three non-zero elements in row 0</span></div><div class="line">M1.append( 0, 1,  2 );  <span class="comment">// Appending the element 2 in row 0 at column index 1</span></div><div class="line">M1.append( 0, 2, -4 );  <span class="comment">// Appending the element -4 in row 0 at column index 2</span></div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>The most efficient way to fill a sparse matrix with elements, however, is a combination of <code>reserve()</code>, <code>append()</code>, and the <code>finalize()</code> function:</p>
<div class="fragment"><div class="line"><span class="comment">// Setup of the compressed row-major matrix</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//       ( 0 1 0 2 0 )</span></div><div class="line"><span class="comment">//   A = ( 0 0 0 0 0 )</span></div><div class="line"><span class="comment">//       ( 3 0 0 0 0 )</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int&gt;</a> M1( 3UL, 5UL );</div><div class="line">M1.reserve( 3 );       <span class="comment">// Reserving enough space for 3 non-zero elements</span></div><div class="line">M1.append( 0, 1, 1 );  <span class="comment">// Appending the value 1 in row 0 with column index 1</span></div><div class="line">M1.append( 0, 3, 2 );  <span class="comment">// Appending the value 2 in row 0 with column index 3</span></div><div class="line">M1.finalize( 0 );      <span class="comment">// Finalizing row 0</span></div><div class="line">M1.finalize( 1 );      <span class="comment">// Finalizing the empty row 1 to prepare row 2</span></div><div class="line">M1.append( 2, 0, 3 );  <span class="comment">// Appending the value 3 in row 2 with column index 0</span></div><div class="line">M1.finalize( 2 );      <span class="comment">// Finalizing row 2</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <code>finalize()</code> function has to be explicitly called for each row or column, even for empty ones! </dd>
<dd>
Although <code>append()</code> does not allocate new memory, it still invalidates all iterators returned by the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a></code> functions!</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_non_modifying_operations"></a>
Non-Modifying Operations</h1>
<hr/>
<h2><a class="anchor" id="matrix_operations_rows"></a>
.rows()</h2>
<p>The current number of rows of a matrix can be acquired via the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4" title="Returns the current number of rows of the matrix. ">rows()</a></code> member function:</p>
<div class="fragment"><div class="line"><span class="comment">// Instantiating a dynamic matrix with 10 rows and 8 columns</span></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> M1( 10UL, 8UL );</div><div class="line">M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>();  <span class="comment">// Returns 10</span></div><div class="line"></div><div class="line"><span class="comment">// Instantiating a compressed matrix with 8 rows and 12 columns</span></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> M2( 8UL, 12UL );</div><div class="line">M2.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adacd3d9f2b3a9468f94ea4ffd39d0fff">rows</a>();  <span class="comment">// Returns 8</span></div></div><!-- fragment --><p>Alternatively, the free functions <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4" title="Returns the current number of rows of the matrix. ">rows()</a></code> can be used to query the current number of rows of a matrix. In contrast to the member function, the free function can also be used to query the number of rows of a matrix expression:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">rows</a>( M1 );  <span class="comment">// Returns 10, i.e. has the same effect as the member function</span></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">rows</a>( M2 );  <span class="comment">// Returns 8, i.e. has the same effect as the member function</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">rows</a>( M1 * M2 );  <span class="comment">// Returns 10, i.e. the number of rows of the resulting matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_columns"></a>
.columns()</h2>
<p>The current number of columns of a matrix can be acquired via the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d" title="Returns the current number of columns of the matrix. ">columns()</a></code> member function:</p>
<div class="fragment"><div class="line"><span class="comment">// Instantiating a dynamic matrix with 6 rows and 8 columns</span></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> M1( 6UL, 8UL );</div><div class="line">M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ac93d8d0a3dac721b2d3ba07e09da0247">columns</a>();   <span class="comment">// Returns 8</span></div><div class="line"></div><div class="line"><span class="comment">// Instantiating a compressed matrix with 8 rows and 7 columns</span></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> M2( 8UL, 7UL );</div><div class="line">M2.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ac93d8d0a3dac721b2d3ba07e09da0247">columns</a>();   <span class="comment">// Returns 7</span></div></div><!-- fragment --><p>There is also a free function <code><a class="el" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d" title="Returns the current number of columns of the matrix. ">columns()</a></code> available, which can also be used to query the number of columns of a matrix expression:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">columns</a>( M1 );  <span class="comment">// Returns 8, i.e. has the same effect as the member function</span></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">columns</a>( M2 );  <span class="comment">// Returns 7, i.e. has the same effect as the member function</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">columns</a>( M1 * M2 );  <span class="comment">// Returns 7, i.e. the number of columns of the resulting matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_capacity"></a>
.capacity()</h2>
<p>The <code><a class="el" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56" title="Returns the maximum capacity of the matrix. ">capacity()</a></code> member function returns the internal capacity of a dense or sparse matrix. Note that the capacity of a matrix doesn't have to be equal to the size of a matrix. In case of a dense matrix the capacity will always be greater or equal than the total number of elements of the matrix. In case of a sparse matrix, the capacity will usually be much less than the total number of elements.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> M1( 5UL, 7UL );</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;float,7UL,4UL&gt;</a> M2;</div><div class="line">M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a754569c5b519ad218df019ca0e9d8a2a">capacity</a>();  <span class="comment">// Returns at least 35</span></div><div class="line">M2.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a754569c5b519ad218df019ca0e9d8a2a">capacity</a>();  <span class="comment">// Returns at least 28</span></div></div><!-- fragment --><p>There is also a free function <code><a class="el" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56" title="Returns the maximum capacity of the matrix. ">capacity()</a></code> available to query the capacity. However, please note that this function cannot be used to query the capacity of a matrix expression:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56">capacity</a>( M1 );  <span class="comment">// Returns at least 35, i.e. has the same effect as the member function</span></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56">capacity</a>( M2 );  <span class="comment">// Returns at least 28, i.e. has the same effect as the member function</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga41e8f2c5d0de752c667be20765570e56">capacity</a>( M1 * M2 );  <span class="comment">// Compilation error!</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_nonzeros"></a>
.nonZeros()</h2>
<p>For both dense and sparse matrices the current number of non-zero elements can be queried via the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923" title="Returns the total number of non-zero elements in the matrix. ">nonZeros()</a></code> member function. In case of matrices there are two flavors of the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923" title="Returns the total number of non-zero elements in the matrix. ">nonZeros()</a></code> function: One returns the total number of non-zero elements in the matrix, the second returns the number of non-zero elements in a specific row (in case of a row-major matrix) or column (in case of a column-major matrix). Sparse matrices directly return their number of non-zero elements, dense matrices traverse their elements and count the number of non-zero elements.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> M1( 3UL, 5UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initializing the dense matrix</span></div><div class="line"></div><div class="line">M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a02a1bbf19f177ae92462b94d730d7f92">nonZeros</a>();     <span class="comment">// Returns the total number of non-zero elements in the dense matrix</span></div><div class="line">M1.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a02a1bbf19f177ae92462b94d730d7f92">nonZeros</a>( 2 );  <span class="comment">// Returns the number of non-zero elements in row 2</span></div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> M2( 4UL, 7UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initializing the sparse matrix</span></div><div class="line"></div><div class="line">M2.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a02a1bbf19f177ae92462b94d730d7f92">nonZeros</a>();     <span class="comment">// Returns the total number of non-zero elements in the sparse matrix</span></div><div class="line">M2.<a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a02a1bbf19f177ae92462b94d730d7f92">nonZeros</a>( 3 );  <span class="comment">// Returns the number of non-zero elements in column 3</span></div></div><!-- fragment --><p>The free <code><a class="el" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923" title="Returns the total number of non-zero elements in the matrix. ">nonZeros()</a></code> function can also be used to query the number of non-zero elements in a matrix expression. However, the result is not the exact number of non-zero elements, but may be a rough estimation:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a>( M1 );     <span class="comment">// Has the same effect as the member function</span></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a>( M1, 2 );  <span class="comment">// Has the same effect as the member function</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a>( M2 );     <span class="comment">// Has the same effect as the member function</span></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a>( M2, 3 );  <span class="comment">// Has the same effect as the member function</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga2f34f7e65e4d2be9617f824285073923">nonZeros</a>( M1 * M2 );  <span class="comment">// Estimates the number of non-zero elements in the matrix expression</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isnan"></a>
isnan()</h2>
<p>The <code><a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08" title="Returns whether the represented element is not a number. ">isnan()</a></code> function provides the means to check a dense or sparse matrix for non-a-number elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><p>If at least one element of the matrix is not-a-number, the function returns <code>true</code>, otherwise it returns <code>false</code>. Please note that this function only works for matrices with floating point elements. The attempt to use it for a matrix with a non-floating point element type results in a compile time error.</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isdefault"></a>
isDefault()</h2>
<p>The <code><a class="el" href="../../d0/d6e/group__compressed__matrix.html#gac2bf9be3eaba4d6c7e6d23ba35c3f306" title="Returns whether the given compressed matrix is in default state. ">isDefault()</a></code> function returns whether the given dense or sparse matrix is in default state:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d6/d60/classblaze_1_1HybridMatrix.html">blaze::HybridMatrix&lt;int,5UL,4UL&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d6e/group__compressed__matrix.html#gac2bf9be3eaba4d6c7e6d23ba35c3f306">isDefault</a>( A ) ) { ... }</div></div><!-- fragment --><p>A matrix is in default state if it appears to just have been default constructed. All resizable matrices (<code>HybridMatrix</code>, <code>DynamicMatrix</code>, or <code>CompressedMatrix</code>) and <code>CustomMatrix</code> are in default state if its size is equal to zero. A non-resizable matrix (<code>StaticMatrix</code> and all submatrices) is in default state if all its elements are in default state. For instance, in case the matrix is instantiated for a built-in integral or floating point data type, the function returns <code>true</code> in case all matrix elements are 0 and <code>false</code> in case any matrix element is not 0.</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isSquare"></a>
isSquare()</h2>
<p>Whether a dense or sparse matrix is a square matrix (i.e. if the number of rows is equal to the number of columns) can be checked via the <code><a class="el" href="../../dd/d7a/group__matrix.html#gaf5f9d43032028526b8b155eb736b87f2" title="Checks if the given matrix is a square matrix. ">isSquare()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../dd/d7a/group__matrix.html#gaf5f9d43032028526b8b155eb736b87f2">isSquare</a>( A ) ) { ... }</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_issymmetric"></a>
isSymmetric()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73" title="Checks if the given dense matrix is symmetric. ">isSymmetric()</a></code> function it is possible to check whether a dense or sparse matrix is symmetric:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be symmetric!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isUniform"></a>
isUniform()</h2>
<p>In order to check if all matrix elements are identical, the <code>isUniform</code> function can be used:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that in case of a sparse matrix also the zero elements are also taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_islower"></a>
isLower()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d" title="Checks if the given dense matrix is a lower triangular matrix. ">isLower()</a></code> function it is possible to check whether a dense or sparse matrix is lower triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be lower triangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isunilower"></a>
isUniLower()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9" title="Checks if the given dense matrix is a lower unitriangular matrix. ">isUniLower()</a></code> function it is possible to check whether a dense or sparse matrix is lower unitriangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">isUniLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be lower unitriangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isstrictlylower"></a>
isStrictlyLower()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7" title="Checks if the given dense matrix is a strictly lower triangular matrix. ">isStrictlyLower()</a></code> function it is possible to check whether a dense or sparse matrix is strictly lower triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">isStrictlyLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be strictly lower triangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isUpper"></a>
isUpper()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be" title="Checks if the given dense matrix is an upper triangular matrix. ">isUpper()</a></code> function it is possible to check whether a dense or sparse matrix is upper triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be upper triangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isuniupper"></a>
isUniUpper()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68" title="Checks if the given dense matrix is an upper unitriangular matrix. ">isUniUpper()</a></code> function it is possible to check whether a dense or sparse matrix is upper unitriangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">isUniUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be upper unitriangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isstrictlyupper"></a>
isStrictlyUpper()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf" title="Checks if the given dense matrix is a strictly upper triangular matrix. ">isStrictlyUpper()</a></code> function it is possible to check whether a dense or sparse matrix is strictly upper triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">isStrictlyUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be strictly upper triangular!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isdiagonal"></a>
isDiagonal()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee" title="Checks if the give dense matrix is diagonal. ">isDiagonal()</a></code> function checks if the given dense or sparse matrix is a diagonal matrix, i.e. if it has only elements on its diagonal and if the non-diagonal elements are default elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be diagonal!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_isidentity"></a>
isIdentity()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604" title="Checks if the give dense matrix is an identity matrix. ">isIdentity()</a></code> function checks if the given dense or sparse matrix is an identity matrix, i.e. if all diagonal elements are 1 and all non-diagonal elements are 0:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;float&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that non-square matrices are never considered to be identity matrices!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_matrix_determinant"></a>
det()</h2>
<p>The determinant of a square dense matrix can be computed by means of the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7" title="Computation of the determinant of the given dense square matrix. ">det()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordtype">double</span> d = <a class="code" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">det</a>( A );  <span class="comment">// Compute the determinant of A</span></div></div><!-- fragment --><p>In case the given dense matrix is not a square matrix, a <code>std::invalid_argument</code> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7" title="Computation of the determinant of the given dense square matrix. ">det()</a></code> function can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type or with a sparse matrix results in a compile time error!</dd>
<dd>
The function is depending on LAPACK kernels. Thus the function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_matrix_trans"></a>
trans()</h2>
<p>Matrices can be transposed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08" title="Calculation of the transpose of the given dense matrix. ">trans()</a></code> function. Row-major matrices are transposed into a column-major matrix and vice versa:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> M1( 5UL, 2UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,columnMajor&gt;</a> M2( 3UL, 7UL );</div><div class="line"></div><div class="line">M1 = M2;            <span class="comment">// Assigning a column-major matrix to a row-major matrix</span></div><div class="line">M1 = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( M2 );   <span class="comment">// Assigning the transpose of M2 (i.e. a row-major matrix) to M1</span></div><div class="line">M1 += <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( M2 );  <span class="comment">// Addition assignment of two row-major matrices</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_ctrans"></a>
ctrans()</h2>
<p>The conjugate transpose of a dense or sparse matrix (also called adjoint matrix, Hermitian conjugate, or transjugate) can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e" title="Returns the conjugate transpose matrix of dm. ">ctrans()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;float&gt;</a>, <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a> &gt; M1( 5UL, 2UL );</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt; complex&lt;float&gt;</a>, <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">columnMajor</a> &gt; M2( 2UL, 5UL );</div><div class="line"></div><div class="line">M1 = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( M2 );  <span class="comment">// Compute the conjugate transpose matrix</span></div></div><!-- fragment --><p>Note that the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e" title="Returns the conjugate transpose matrix of dm. ">ctrans()</a></code> function has the same effect as manually applying the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf" title="Returns a matrix containing the complex conjugate of each single element of dm. ">conj()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08" title="Calculation of the transpose of the given dense matrix. ">trans()</a></code> function in any order:</p>
<div class="fragment"><div class="line">M1 = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( M2 ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div><div class="line">M1 = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( M2 ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_matrix_evaluate"></a>
eval() / evaluate()</h2>
<p>The <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> function forces an evaluation of the given matrix expression and enables an automatic deduction of the correct result type of an operation. The following code example demonstrates its intended use for the multiplication of a lower and a strictly lower dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/d08/classblaze_1_1StrictlyLowerMatrix.html">blaze::StrictlyLowerMatrix</a>;</div><div class="line"></div><div class="line">LowerMatrix&lt; DynamicMatrix&lt;double&gt; &gt; A;</div><div class="line">StrictlyLowerMatrix&lt; DynamicMatrix&lt;double&gt; &gt; B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> C = <a class="code" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af">evaluate</a>( A * B );</div></div><!-- fragment --><p>In this scenario, the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> function assists in deducing the exact result type of the operation via the <code>auto</code> keyword. Please note that if <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> is used in this way, no temporary matrix is created and no copy operation is performed. Instead, the result is directly written to the target matrix due to the return value optimization (RVO). However, if <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> is used in combination with an explicit target type, a temporary will be created and a copy operation will be performed if the used type differs from the type returned from the function:</p>
<div class="fragment"><div class="line">StrictlyLowerMatrix&lt; DynamicMatrix&lt;double&gt; &gt; D( A * B );  <span class="comment">// No temporary &amp; no copy operation</span></div><div class="line">LowerMatrix&lt; DynamicMatrix&lt;double&gt; &gt; E( A * B );          <span class="comment">// Temporary &amp; copy operation</span></div><div class="line">DynamicMatrix&lt;double&gt; F( A * B );                         <span class="comment">// Temporary &amp; copy operation</span></div><div class="line">D = <a class="code" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af">evaluate</a>( A * B );                                    <span class="comment">// Temporary &amp; copy operation</span></div></div><!-- fragment --><p>Sometimes it might be desirable to explicitly evaluate a sub-expression within a larger expression. However, please note that <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> is not intended to be used for this purpose. This task is more elegantly and efficiently handled by the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82" title="Forces the evaluation of the given dense matrix expression dm. ">eval()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C, D;</div><div class="line"></div><div class="line">D = A + <a class="code" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af">evaluate</a>( B * C );  <span class="comment">// Unnecessary creation of a temporary matrix</span></div><div class="line">D = A + <a class="code" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">eval</a>( B * C );      <span class="comment">// No creation of a temporary matrix</span></div></div><!-- fragment --><p>In contrast to the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga8bd813306e3dd78f7c61813a4392a2af" title="Evaluates the given matrix expression. ">evaluate()</a></code> function, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82" title="Forces the evaluation of the given dense matrix expression dm. ">eval()</a></code> can take the complete expression into account and therefore can guarantee the most efficient way to evaluate it (see also <a class="el" href="../../d2/dcb/intra_statement_optimization.html">Intra-Statement Optimization</a>).</p>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_modifying_operations"></a>
Modifying Operations</h1>
<hr/>
<h2><a class="anchor" id="matrix_operations_resize_reserve"></a>
.resize() / .reserve()</h2>
<p>The dimensions of a <code>StaticMatrix</code> are fixed at compile time by the second and third template parameter and a <code>CustomMatrix</code> cannot be resized. In contrast, the number or rows and columns of <code>DynamicMatrix</code>, <code>HybridMatrix</code>, and <code>CompressedMatrix</code> can be changed at runtime:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;int,rowMajor&gt; M1;</div><div class="line">CompressedMatrix&lt;int,columnMajor&gt; M2( 3UL, 2UL );</div><div class="line"></div><div class="line"><span class="comment">// Adapting the number of rows and columns via the resize() function. The (optional)</span></div><div class="line"><span class="comment">// third parameter specifies whether the existing elements should be preserved. Per</span></div><div class="line"><span class="comment">// default, the existing elements are preserved.</span></div><div class="line">M1.resize( 2UL, 2UL );         <span class="comment">// Resizing matrix M1 to 2x2 elements. Elements of built-in type</span></div><div class="line">                               <span class="comment">// remain uninitialized, elements of class type are default</span></div><div class="line">                               <span class="comment">// constructed.</span></div><div class="line">M1.resize( 3UL, 1UL, <span class="keyword">false</span> );  <span class="comment">// Resizing M1 to 3x1 elements. The old elements are lost, the</span></div><div class="line">                               <span class="comment">// new elements are NOT initialized!</span></div><div class="line">M2.resize( 5UL, 7UL, <span class="keyword">true</span> );   <span class="comment">// Resizing M2 to 5x7 elements. The old elements are preserved.</span></div><div class="line">M2.resize( 3UL, 2UL, <span class="keyword">false</span> );  <span class="comment">// Resizing M2 to 3x2 elements. The old elements are lost.</span></div></div><!-- fragment --><p>Note that resizing a matrix invalidates all existing views (see e.g. <a class="el" href="../../db/dd6/views_submatrices.html">Submatrices</a>) on the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a>  MatrixType;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d2/d67/classblaze_1_1Row.html">blaze::Row&lt;MatrixType&gt;</a>              RowType;</div><div class="line"></div><div class="line">MatrixType M1( 10UL, 20UL );    <span class="comment">// Creating a 10x20 matrix</span></div><div class="line">RowType row8 = <a class="code" href="../../d0/d48/group__views.html#ga062bf148d887c56afde41f4649897dbe">row</a>( M1, 8UL );  <span class="comment">// Creating a view on the 8th row of the matrix</span></div><div class="line">M1.resize( 6UL, 20UL );         <span class="comment">// Resizing the matrix invalidates the view</span></div></div><!-- fragment --><p>When the internal capacity of a matrix is no longer sufficient, the allocation of a larger junk of memory is triggered. In order to avoid frequent reallocations, the <code>reserve()</code> function can be used up front to set the internal capacity:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> M1;</div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a426ee42e366c0211ecab7dbe4cc9593b">reserve</a>( 100 );</div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab20e4417624cfceaf9083a7f7c181ec2">rows</a>();      <span class="comment">// Returns 0</span></div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a6120531af07c29fbc35c0f910f763b4e">capacity</a>();  <span class="comment">// Returns at least 100</span></div></div><!-- fragment --><p>Additionally it is possible to reserve memory in a specific row (for a row-major matrix) or column (for a column-major matrix):</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int&gt;</a> M1( 4UL, 6UL );</div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a426ee42e366c0211ecab7dbe4cc9593b">reserve</a>( 1, 4 );  <span class="comment">// Reserving enough space for four non-zero elements in row 1</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_shrinkToFit"></a>
.shrinkToFit()</h2>
<p>The internal capacity of matrices with dynamic memory is preserved in order to minimize the number of reallocations. For that reason, the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> and <code>reserve()</code> functions can lead to memory overhead. The <code><a class="el" href="../../dd/d7a/group__matrix.html#gad6adfa525ee4758bcabfc8f8d28fe7ed" title="Requesting the removal of unused capacity. ">shrinkToFit()</a></code> member function can be used to minimize the internal capacity:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int&gt;</a> M1( 100UL, 100UL );  <span class="comment">// Create a 100x100 integer matrix</span></div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a12614e6ea64ebee876e22576a7ad1bf6">resize</a>( 10UL, 10UL );                       <span class="comment">// Resize to 10x10, but the capacity is preserved</span></div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a7c255b3b9654c21338d1d4b57825b00f">shrinkToFit</a>();                              <span class="comment">// Remove the unused capacity</span></div></div><!-- fragment --><p>Please note that due to padding the capacity might not be reduced exactly to <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4" title="Returns the current number of rows of the matrix. ">rows()</a></code> times <code><a class="el" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d" title="Returns the current number of columns of the matrix. ">columns()</a></code>. Please also note that in case a reallocation occurs, all iterators (including <code><a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a></code> iterators), all pointers and references to elements of this matrix are invalidated.</p>
<h2><a class="anchor" id="matrix_operations_reset_clear"></a>
reset() / clear</h2>
<p>In order to reset all elements of a dense or sparse matrix, the <code><a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a></code> function can be used. The number of rows and columns of the matrix are preserved:</p>
<div class="fragment"><div class="line"><span class="comment">// Setting up a single precision row-major matrix, whose elements are initialized with 2.0F.</span></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> M1( 4UL, 5UL, 2.0F );</div><div class="line"></div><div class="line"><span class="comment">// Resetting all elements to 0.0F.</span></div><div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">reset</a>( M1 );  <span class="comment">// Resetting all elements</span></div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab20e4417624cfceaf9083a7f7c181ec2">rows</a>();    <span class="comment">// Returns 4: size and capacity remain unchanged</span></div></div><!-- fragment --><p>Alternatively, only a single row or column of the matrix can be resetted:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a>    M1( 7UL, 6UL, 5 );  <span class="comment">// Setup of a row-major matrix</span></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::columnMajor&gt;</a> M2( 4UL, 5UL, 4 );  <span class="comment">// Setup of a column-major matrix</span></div><div class="line"></div><div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">reset</a>( M1, 2UL );  <span class="comment">// Resetting the 2nd row of the row-major matrix</span></div><div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">reset</a>( M2, 3UL );  <span class="comment">// Resetting the 3rd column of the column-major matrix</span></div></div><!-- fragment --><p>In order to reset a row of a column-major matrix or a column of a row-major matrix, use a row or column view (see <a class="el" href="../../d5/dc1/views_rows.html">Rows</a> and views_colums).</p>
<p>In order to return a matrix to its default state (i.e. the state of a default constructed matrix), the <code><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga651f845e3f416827bacc7be86463ad72" title="Clearing the given compressed matrix. ">clear()</a></code> function can be used:</p>
<div class="fragment"><div class="line"><span class="comment">// Setting up a single precision row-major matrix, whose elements are initialized with 2.0F.</span></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float&gt;</a> M1( 4UL, 5UL, 2.0F );</div><div class="line"></div><div class="line"><span class="comment">// Resetting all elements to 0.0F.</span></div><div class="line"><a class="code" href="../../d0/d6e/group__compressed__matrix.html#ga651f845e3f416827bacc7be86463ad72">clear</a>( M1 );  <span class="comment">// Resetting the entire matrix</span></div><div class="line">M1.<a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab20e4417624cfceaf9083a7f7c181ec2">rows</a>();    <span class="comment">// Returns 0: size is reset, but capacity remains unchanged</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_matrix_transpose"></a>
transpose()</h2>
<p>In addition to the non-modifying <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08" title="Calculation of the transpose of the given dense matrix. ">trans()</a></code> function, matrices can be transposed in-place via the <code><a class="el" href="../../dd/d7a/group__matrix.html#gaa6ec40dcae1598b663c10eda754381cb" title="In-place transpose of the given matrix. ">transpose()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> M( 5UL, 2UL );</div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#gaa6ec40dcae1598b663c10eda754381cb">transpose</a>( M );  <span class="comment">// In-place transpose operation.</span></div><div class="line">M = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( M );  <span class="comment">// Same as above</span></div></div><!-- fragment --><p>Note however that the transpose operation fails if ...</p>
<ul>
<li>... the given matrix has a fixed size and is non-square;</li>
<li>... the given matrix is a triangular matrix;</li>
<li>... the given submatrix affects the restricted parts of a triangular matrix;</li>
<li>... the given submatrix would cause non-deterministic results in a symmetric/Hermitian matrix.</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_ctranspose"></a>
ctranspose()</h2>
<p>The <code><a class="el" href="../../dd/d7a/group__matrix.html#ga83307ec51c557abe636bf98cf539b77a" title="In-place conjugate transpose of the given matrix. ">ctranspose()</a></code> function can be used to perform an in-place conjugate transpose operation:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> M( 5UL, 2UL );</div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#ga83307ec51c557abe636bf98cf539b77a">ctranspose</a>( M );  <span class="comment">// In-place conjugate transpose operation.</span></div><div class="line">M = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( M );  <span class="comment">// Same as above</span></div></div><!-- fragment --><p>Note however that the conjugate transpose operation fails if ...</p>
<ul>
<li>... the given matrix has a fixed size and is non-square;</li>
<li>... the given matrix is a triangular matrix;</li>
<li>... the given submatrix affects the restricted parts of a triangular matrix;</li>
<li>... the given submatrix would cause non-deterministic results in a symmetric/Hermitian matrix.</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_swap"></a>
swap()</h2>
<p>Via the <code><code><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga72c078b1444dca25e2239357085649c3" title="Swapping the contents of two compressed matrices. ">swap()</a></code> function</code> it is possible to completely swap the contents of two matrices of the same type:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> M1( 10UL, 15UL );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> M2( 20UL, 10UL );</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d6e/group__compressed__matrix.html#ga72c078b1444dca25e2239357085649c3">swap</a>( M1, M2 );  <span class="comment">// Swapping the contents of M1 and M2</span></div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_arithmetic_operations"></a>
Arithmetic Operations</h1>
<hr/>
<h2><a class="anchor" id="matrix_operations_min_max"></a>
min() / max()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a></code> and the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a></code> functions return the smallest and largest element of the given dense or sparse matrix, respectively:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> A{ { -5, 2, 7 },</div><div class="line">                                             {  4, 0, 1 } };</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> B{ { -5, 2, -7 },</div><div class="line">                                             { -4, 0, -1 } };</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( A );  <span class="comment">// Returns -5</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( B );  <span class="comment">// Returns -7</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>( A );  <span class="comment">// Returns 7</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>( B );  <span class="comment">// Returns 2</span></div></div><!-- fragment --><p>In case the matrix currently has 0 rows or 0 columns, both functions return 0. Additionally, in case a given sparse matrix is not completely filled, the zero elements are taken into account. For example: the following compressed matrix has only 2 non-zero elements. However, the minimum of this matrix is 0:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int&gt;</a> C( 2UL, 3UL );</div><div class="line">C(0,0) = 1;</div><div class="line">C(0,2) = 3;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( C );  <span class="comment">// Returns 0</span></div></div><!-- fragment --><p>Also note that the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a></code> functions can be used to compute the smallest and largest element of a matrix expression:</p>
<div class="fragment"><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( A + B + C );  <span class="comment">// Returns -9, i.e. the smallest value of the resulting matrix</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>( A - B - C );  <span class="comment">// Returns 11, i.e. the largest value of the resulting matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_trace"></a>
trace()</h2>
<p>The <code><a class="el" href="../../dd/d7a/group__matrix.html#gac49c56871f0559df0b80283bb2ff8377" title="Computes the trace of the given square matrix. ">trace()</a></code> function sums the diagonal elements of a square dense or sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,3UL,3UL&gt;</a> A{ { -1,  2, -3 }</div><div class="line">                                  , { -4, -5,  6 }</div><div class="line">                                  , {  7, -8, -9 } };</div><div class="line"></div><div class="line"><a class="code" href="../../dd/d7a/group__matrix.html#gac49c56871f0559df0b80283bb2ff8377">trace</a>( A );  <span class="comment">// Returns the sum of the diagonal elements, i.e. -15</span></div></div><!-- fragment --><p>In case the given matrix is not a square matrix, a <code>std::invalid_argument</code> exception is thrown.</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_abs"></a>
abs()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></code> function can be used to compute the absolute values of each element of a matrix. For instance, the following computation</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> A{ { -1,  2, -3 },</div><div class="line">                                             {  4, -5,  6 } };</div><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> B( <a class="code" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">abs</a>( A ) );</div></div><!-- fragment --><p>results in the matrix</p>
<p><img class="formulaInl" alt="$ B = \left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)$" src="../../form_176.png"/></p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_rounding_functions"></a>
floor() / ceil() / trunc() / round()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></code>, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></code>, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></code>, and <code><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></code> functions can be used to round down/up each element of a matrix, respectively:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,3UL&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">floor</a>( A );  <span class="comment">// Rounding down each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">ceil</a> ( A );  <span class="comment">// Rounding up each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">trunc</a>( A );  <span class="comment">// Truncating each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">round</a>( A );  <span class="comment">// Rounding each element of the matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_conj"></a>
conj()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf" title="Returns a matrix containing the complex conjugate of each single element of dm. ">conj()</a></code> function can be applied on a dense or sparse matrix to compute the complex conjugate of each element of the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::complex&lt;double&gt;  cplx;</div><div class="line"></div><div class="line"><span class="comment">// Creating the matrix</span></div><div class="line"><span class="comment">//    ( (1,0)  (-2,-1) )</span></div><div class="line"><span class="comment">//    ( (1,1)  ( 0, 1) )</span></div><div class="line">StaticMatrix&lt;cplx,2UL,2UL&gt; A{ { cplx( 1.0, 0.0 ), cplx( -2.0, -1.0 ) },</div><div class="line">                              { cplx( 1.0, 1.0 ), cplx(  0.0,  1.0 ) } };</div><div class="line"></div><div class="line"><span class="comment">// Computing the matrix of conjugate values</span></div><div class="line"><span class="comment">//    ( (1, 0)  (-2, 1) )</span></div><div class="line"><span class="comment">//    ( (1,-1)  ( 0,-1) )</span></div><div class="line">StaticMatrix&lt;cplx,2UL,2UL&gt; B;</div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( A );</div></div><!-- fragment --><p>Additionally, matrices can be conjugated in-place via the <code><a class="el" href="../../da/d5b/group__math__shims.html#gab000552f031178737cd6684ba61d7a4d" title="In-place conjugation of the given value/object. ">conjugate()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;cplx&gt;</a> C( 5UL, 2UL );</div><div class="line"></div><div class="line"><a class="code" href="../../da/d5b/group__math__shims.html#gab000552f031178737cd6684ba61d7a4d">conjugate</a>( C );  <span class="comment">// In-place conjugate operation.</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( C );   <span class="comment">// Same as above</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_real"></a>
real()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b" title="Returns a matrix containing the real part of each single element of dm. ">real()</a></code> function can be used on a dense or sparse matrix to extract the real part of each element of the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::complex&lt;double&gt;  cplx;</div><div class="line"></div><div class="line"><span class="comment">// Creating the matrix</span></div><div class="line"><span class="comment">//    ( (1,0)  (-2,-1) )</span></div><div class="line"><span class="comment">//    ( (1,1)  ( 0, 1) )</span></div><div class="line">StaticMatrix&lt;cplx,2UL,2UL&gt; A{ { cplx( 1.0, 0.0 ), cplx( -2.0, -1.0 ) },</div><div class="line">                              { cplx( 1.0, 1.0 ), cplx(  0.0,  1.0 ) } };</div><div class="line"></div><div class="line"><span class="comment">// Extracting the real part of each matrix element</span></div><div class="line"><span class="comment">//    ( 1 -2 )</span></div><div class="line"><span class="comment">//    ( 1  0 )</span></div><div class="line">StaticMatrix&lt;double,2UL,2UL&gt; B;</div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>( A );</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_imag"></a>
imag()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947" title="Returns a matrix containing the imaginary part of each single element of dm. ">imag()</a></code> function can be used on a dense or sparse matrix to extract the imaginary part of each element of the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::complex&lt;double&gt;  cplx;</div><div class="line"></div><div class="line"><span class="comment">// Creating the matrix</span></div><div class="line"><span class="comment">//    ( (1,0)  (-2,-1) )</span></div><div class="line"><span class="comment">//    ( (1,1)  ( 0, 1) )</span></div><div class="line">StaticMatrix&lt;cplx,2UL,2UL&gt; A{ { cplx( 1.0, 0.0 ), cplx( -2.0, -1.0 ) },</div><div class="line">                              { cplx( 1.0, 1.0 ), cplx(  0.0,  1.0 ) } };</div><div class="line"></div><div class="line"><span class="comment">// Extracting the imaginary part of each matrix element</span></div><div class="line"><span class="comment">//    ( 0 -1 )</span></div><div class="line"><span class="comment">//    ( 1  1 )</span></div><div class="line">StaticMatrix&lt;double,2UL,2UL&gt; B;</div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>( A );</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_sqrt"></a>
sqrt() / invsqrt()</h2>
<p>Via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></code> functions the (inverse) square root of each element of a matrix can be computed:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,3UL&gt;</a> A, B, C;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( A );     <span class="comment">// Computes the square root of each element</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">invsqrt</a>( A );  <span class="comment">// Computes the inverse square root of each element</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_cbrt"></a>
cbrt() / invcbrt()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></code> functions can be used to compute the the (inverse) cubic root of each element of a matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">cbrt</a>( A );     <span class="comment">// Computes the cubic root of each element</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">invcbrt</a>( A );  <span class="comment">// Computes the inverse cubic root of each element</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_clamp"></a>
clamp()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></code> function can be used to restrict all elements of a matrix to a specific range:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">clamp</a>( A, -1.0, 1.0 );  <span class="comment">// Restrict all elements to the range [-1..1]</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_pow"></a>
pow()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></code> function can be used to compute the exponential value of each element of a matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,3UL&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">pow</a>( A, 1.2 );  <span class="comment">// Computes the exponential value of each element</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_exp"></a>
exp()</h2>
<p><code><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></code>, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></code> compute the base e/2/10 exponential of each element of a matrix, respectively:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d6/d60/classblaze_1_1HybridMatrix.html">blaze::HybridMatrix&lt;double,3UL,3UL&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>( A );    <span class="comment">// Computes the base e exponential of each element</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">exp2</a>( A );   <span class="comment">// Computes the base 2 exponential of each element</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">exp10</a>( A );  <span class="comment">// Computes the base 10 exponential of each element</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_log"></a>
log() / log2() / log10()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></code>, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></code> functions can be used to compute the natural, binary and common logarithm of each element of a matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,3UL&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">log</a>( A );    <span class="comment">// Computes the natural logarithm of each element</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">log2</a>( A );   <span class="comment">// Computes the binary logarithm of each element</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">log10</a>( A );  <span class="comment">// Computes the common logarithm of each element</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_trigonometric_functions"></a>
sin() / cos() / tan() / asin() / acos() / atan()</h2>
<p>The following trigonometric functions are available for both dense and sparse matrices:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">sin</a>( A );  <span class="comment">// Computes the sine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">cos</a>( A );  <span class="comment">// Computes the cosine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">tan</a>( A );  <span class="comment">// Computes the tangent of each element of the matrix</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">asin</a>( A );  <span class="comment">// Computes the inverse sine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">acos</a>( A );  <span class="comment">// Computes the inverse cosine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">atan</a>( A );  <span class="comment">// Computes the inverse tangent of each element of the matrix</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_hyperbolic_functions"></a>
sinh() / cosh() / tanh() / asinh() / acosh() / atanh()</h2>
<p>The following hyperbolic functions are available for both dense and sparse matrices:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">sinh</a>( A );  <span class="comment">// Computes the hyperbolic sine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">cosh</a>( A );  <span class="comment">// Computes the hyperbolic cosine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">tanh</a>( A );  <span class="comment">// Computes the hyperbolic tangent of each element of the matrix</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">asinh</a>( A );  <span class="comment">// Computes the inverse hyperbolic sine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">acosh</a>( A );  <span class="comment">// Computes the inverse hyperbolic cosine of each element of the matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">atanh</a>( A );  <span class="comment">// Computes the inverse hyperbolic tangent of each element of the matrix</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operators_erf"></a>
erf() / erfc()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></code> and <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></code> functions compute the (complementary) error function of each element of a matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix&lt;double,3UL,3UL&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">erf</a>( A );   <span class="comment">// Computes the error function of each element</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">erfc</a>( A );  <span class="comment">// Computes the complementary error function of each element</span></div></div><!-- fragment --><p>Note that in case of sparse matrices only the non-zero elements are taken into account!</p>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_map"></a>
map() / forEach()</h2>
<p>Via the unary and binary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> functions it is possible to execute componentwise custom operations on matrices. The unary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> function can be used to apply a custom operation on each element of a dense or sparse matrix. For instance, the following example demonstrates a custom square root computation via a lambda:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, []( <span class="keywordtype">double</span> d ) { <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( d ); } );</div></div><!-- fragment --><p>The binary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> function can be used to apply an operation pairwise to the elements of two dense matrices. The following example demonstrates the merging of two matrices of double precision values into a matrix of double precision complex numbers:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>{ { 2.1, -4.2 }, { 1.0,  0.6 } };</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>{ { 0.3,  1.4 }, { 2.9, -3.4 } };</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; cplx;</div><div class="line"></div><div class="line"><span class="comment">// Creating the matrix</span></div><div class="line"><span class="comment">//    ( (-2.1,  0.3) (-4.2, -1.4) )</span></div><div class="line"><span class="comment">//    ( ( 1.0,  2.9) ( 0.6, -3.4) )</span></div><div class="line">cplx = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>, <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>, []( <span class="keywordtype">double</span> r, <span class="keywordtype">double</span> i ){ <span class="keywordflow">return</span> complex( r, i ); } );</div></div><!-- fragment --><p>Although the computation can be parallelized it is not vectorized and thus cannot perform at peak performance. However, it is also possible to create vectorized custom operations. See <a class="el" href="../../d4/de4/vector_and_matrix_customization.html#custom_operations">Custom Operations</a> for a detailed overview of the possibilities of custom operations.</p>
<p>Please note that unary custom operations on vectors have been introduced in <b>Blaze</b> 3.0 in form of the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></code> function. With the introduction of binary custom functions, the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></code> function has been renamed to <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code>. The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></code> function can still be used (even for binary custom operations), but the function might be deprecated in future releases of <b>Blaze</b>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_declaration_operations"></a>
Declaration Operations</h1>
<hr/>
<h2><a class="anchor" id="matrix_operations_declsym"></a>
declsym()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba" title="Declares the given dense matrix expression dm as symmetric. ">declsym()</a></code> operation can be used to explicitly declare any matrix or matrix expression as symmetric:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as symmetric via <code><a class="el" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba" title="Declares the given dense matrix expression dm as symmetric. ">declsym()</a></code> will gain all the benefits of a symmetric matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">SymmetricMatrix&lt; DynamicMatrix&lt;double&gt; &gt; S;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">S = <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A );  <span class="comment">// Omit any runtime check for symmetry</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A * B );  <span class="comment">// Declare the result of the matrix multiplication as symmetric,</span></div><div class="line">                       <span class="comment">// i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba" title="Declares the given dense matrix expression dm as symmetric. ">declsym()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-symmetric matrix or matrix expression as symmetric via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba" title="Declares the given dense matrix expression dm as symmetric. ">declsym()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_declherm"></a>
declherm()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679" title="Declares the given dense matrix expression dm as Hermitian. ">declherm()</a></code> operation can be used to explicitly declare any matrix or matrix expression as Hermitian:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as Hermitian via <code><a class="el" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679" title="Declares the given dense matrix expression dm as Hermitian. ">declherm()</a></code> will gain all the benefits of an Hermitian matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">HermitianMatrix&lt; DynamicMatrix&lt;double&gt; &gt; S;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">isHermitian</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">S = <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A );  <span class="comment">// Omit any runtime check for Hermitian symmetry</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A * B );  <span class="comment">// Declare the result of the matrix multiplication as Hermitian,</span></div><div class="line">                        <span class="comment">// i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679" title="Declares the given dense matrix expression dm as Hermitian. ">declherm()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-Hermitian matrix or matrix expression as Hermitian via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679" title="Declares the given dense matrix expression dm as Hermitian. ">declherm()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decllow"></a>
decllow()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429" title="Declares the given dense matrix expression dm as lower. ">decllow()</a></code> operation can be used to explicitly declare any matrix or matrix expression as lower triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as lower triangular via <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429" title="Declares the given dense matrix expression dm as lower. ">decllow()</a></code> will gain all the benefits of a lower triangular matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">LowerMatrix&lt; DynamicMatrix&lt;double&gt; &gt; L;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">L = <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A );  <span class="comment">// Omit any runtime check for A being a lower matrix</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A * B );  <span class="comment">// Declare the result of the matrix multiplication as lower triangular,</span></div><div class="line">                       <span class="comment">// i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429" title="Declares the given dense matrix expression dm as lower. ">decllow()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-lower matrix or matrix expression as lower triangular via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429" title="Declares the given dense matrix expression dm as lower. ">decllow()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_declupp"></a>
declupp()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247" title="Declares the given dense matrix expression dm as upper. ">declupp()</a></code> operation can be used to explicitly declare any matrix or matrix expression as upper triangular:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as upper triangular via <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247" title="Declares the given dense matrix expression dm as upper. ">declupp()</a></code> will gain all the benefits of a upper triangular matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d5/daf/classblaze_1_1UpperMatrix.html">blaze::UpperMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">UpperMatrix&lt; DynamicMatrix&lt;double&gt; &gt; U;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">U = <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A );  <span class="comment">// Omit any runtime check for A being a upper matrix</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A * B );  <span class="comment">// Declare the result of the matrix multiplication as upper triangular,</span></div><div class="line">                       <span class="comment">// i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247" title="Declares the given dense matrix expression dm as upper. ">declupp()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-upper matrix or matrix expression as upper triangular via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247" title="Declares the given dense matrix expression dm as upper. ">declupp()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decldiag"></a>
decldiag()</h2>
<p>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7" title="Declares the given dense matrix expression dm as diagonal. ">decldiag()</a></code> operation can be used to explicitly declare any matrix or matrix expression as diagonal:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as diagonal via <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7" title="Declares the given dense matrix expression dm as diagonal. ">decldiag()</a></code> will gain all the benefits of a diagonal matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">blaze::DiagonalMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">DiagonalMatrix&lt; DynamicMatrix&lt;double&gt; &gt; D;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">D = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A );  <span class="comment">// Omit any runtime check for A being a diagonal matrix</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A * B );  <span class="comment">// Declare the result of the matrix multiplication as diagonal,</span></div><div class="line">                        <span class="comment">// i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7" title="Declares the given dense matrix expression dm as diagonal. ">decldiag()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-diagonal matrix or matrix expression as diagonal via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7" title="Declares the given dense matrix expression dm as diagonal. ">decldiag()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_declid"></a>
declid()</h2>
<p>The <code><a class="el" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300" title="Declares the given matrix expression m as identity matrix. ">declid()</a></code> operation can be used to explicitly declare any matrix or matrix expression as identity matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line">B = <a class="code" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300">declid</a>( A );</div></div><!-- fragment --><p>Any matrix or matrix expression that has been declared as identity matrix via <code><a class="el" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300" title="Declares the given matrix expression m as identity matrix. ">declid()</a></code> will gain all the benefits of an identity matrix, which range from reduced runtime checking to a considerable speed-up in computations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d9/d3f/classblaze_1_1DiagonalMatrix.html">blaze::DiagonalMatrix</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double&gt; A, B, C;</div><div class="line">DiagonalMatrix&lt; DynamicMatrix&lt;double&gt; &gt; D;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( <a class="code" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300">declid</a>( A ) );  <span class="comment">// Will always return true without runtime effort</span></div><div class="line"></div><div class="line">D = <a class="code" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300">declid</a>( A );  <span class="comment">// Omit any runtime check for A being a diagonal matrix</span></div><div class="line"></div><div class="line">C = <a class="code" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300">declid</a>( A ) * B;  <span class="comment">// Declare the left operand of the matrix multiplication as an</span></div><div class="line">                      <span class="comment">// identity matrix, i.e. perform an optimized matrix multiplication</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <code><a class="el" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300" title="Declares the given matrix expression m as identity matrix. ">declid()</a></code> operation has the semantics of a cast: The caller is completely responsible and the system trusts the given information. Declaring a non-identity matrix or matrix expression as identity matrix via the <code><a class="el" href="../../d9/d18/group__identity__matrix.html#ga810257047b1fc2a9084d70d4ff3c8300" title="Declares the given matrix expression m as identity matrix. ">declid()</a></code> operation leads to undefined behavior (which can be violated invariants or wrong computation results)!</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_matrix_inversion"></a>
Matrix Inversion</h1>
<hr/>
<p>The inverse of a square dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;float,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A );  <span class="comment">// Compute the inverse of A</span></div></div><!-- fragment --><p>Alternatively, an in-place inversion of a dense matrix can be performed via the <code><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118" title="In-place inversion of the represented element. ">invert()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><a class="code" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118">invert</a>( A );  <span class="comment">// In-place matrix inversion</span></div></div><!-- fragment --><p>Both the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> and the <code><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118" title="In-place inversion of the represented element. ">invert()</a></code> functions will automatically select the most suited matrix inversion algorithm depending on the size and type of the given matrix. For small matrices of up to 6x6, both functions use manually optimized kernels for maximum performance. For matrices larger than 6x6 the inversion is performed by means of the most suited matrix decomposition method: In case of a general matrix the LU decomposition is used, for symmetric matrices the LDLT decomposition is applied, for Hermitian matrices the LDLH decomposition is performed, and for triangular matrices the inverse is computed via a forward or back substitution.</p>
<p>In case the type of the matrix does not provide additional compile time information about its structure (symmetric, lower, upper, diagonal, ...), the information can be provided manually when calling the <code><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118" title="In-place inversion of the represented element. ">invert()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce">blaze::asGeneral</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1">blaze::asSymmetric</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090">blaze::asHermitian</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e">blaze::asLower</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232">blaze::asUniLower</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97">blaze::asUpper</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826">blaze::asUniUpper</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5">blaze::asDiagonal</a>;</div><div class="line"></div><div class="line">invert&lt;asGeneral&gt;  ( A );  <span class="comment">// In-place inversion of a general matrix</span></div><div class="line">invert&lt;asSymmetric&gt;( A );  <span class="comment">// In-place inversion of a symmetric matrix</span></div><div class="line">invert&lt;asHermitian&gt;( A );  <span class="comment">// In-place inversion of a Hermitian matrix</span></div><div class="line">invert&lt;asLower&gt;    ( A );  <span class="comment">// In-place inversion of a lower triangular matrix</span></div><div class="line">invert&lt;asUniLower&gt; ( A );  <span class="comment">// In-place inversion of a lower unitriangular matrix</span></div><div class="line">invert&lt;asUpper&gt;    ( A );  <span class="comment">// In-place inversion of a upper triangular matrix</span></div><div class="line">invert&lt;asUniUpper&gt; ( A );  <span class="comment">// In-place inversion of a upper unitriangular matrix</span></div><div class="line">invert&lt;asDiagonal&gt; ( A );  <span class="comment">// In-place inversion of a diagonal matrix</span></div></div><!-- fragment --><p>Alternatively, via the <code><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118" title="In-place inversion of the represented element. ">invert()</a></code> function it is possible to explicitly specify the inversion algorithm:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402">blaze::byLU</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6">blaze::byLDLT</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb">blaze::byLDLH</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2">blaze::byLLH</a>;</div><div class="line"></div><div class="line"><span class="comment">// In-place inversion of a general matrix by means of an LU decomposition</span></div><div class="line">invert&lt;byLU&gt;( A );</div><div class="line"></div><div class="line"><span class="comment">// In-place inversion of a symmetric indefinite matrix by means of a Bunch-Kaufman decomposition</span></div><div class="line">invert&lt;byLDLT&gt;( A );</div><div class="line"></div><div class="line"><span class="comment">// In-place inversion of a Hermitian indefinite matrix by means of a Bunch-Kaufman decomposition</span></div><div class="line">invert&lt;byLDLH&gt;( A );</div><div class="line"></div><div class="line"><span class="comment">// In-place inversion of a positive definite matrix by means of a Cholesky decomposition</span></div><div class="line">invert&lt;byLLH&gt;( A );</div></div><!-- fragment --><p>Whereas the inversion by means of an LU decomposition works for every general square matrix, the inversion by LDLT only works for symmetric indefinite matrices, the inversion by LDLH is restricted to Hermitian indefinite matrices and the Cholesky decomposition (LLH) only works for Hermitian positive definite matrices. Please note that it is in the responsibility of the function caller to guarantee that the selected algorithm is suited for the given matrix. In case this precondition is violated the result can be wrong and might not represent the inverse of the given matrix!</p>
<p>For both the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> and <code><a class="el" href="../../dc/dca/group__hermitian__matrix.html#gadcadc3a730ea3ba104818694952b8118" title="In-place inversion of the represented element. ">invert()</a></code> function the matrix inversion fails if ...</p>
<ul>
<li>... the given matrix is not a square matrix;</li>
<li>... the given matrix is singular and not invertible.</li>
</ul>
<p>In all failure cases either a compilation error is created if the failure can be predicted at compile time or a <code>std::invalid_argument</code> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type or with a sparse matrix results in a compile time error!</dd>
<dd>
The functions invert the dense matrix by means of LAPACK kernels. Thus the functions can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd>
<dd>
It is not possible to use any kind of view on the expression object returned by the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> function. Also, it is not possible to access individual elements via the function call operator on the expression object:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d0/d48/group__views.html#ga062bf148d887c56afde41f4649897dbe">row</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A ), 2UL );  <span class="comment">// Compilation error: Views cannot be used on an inv() expression!</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A )(1,2);         <span class="comment">// Compilation error: It is not possible to access individual elements!</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The inversion functions do not provide any exception safety guarantee, i.e. in case an exception is thrown the matrix may already have been modified.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_decomposition"></a>
Matrix Decomposition</h1>
<hr/>
<dl class="section note"><dt>Note</dt><dd>All decomposition functions can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type or with a sparse matrix results in a compile time error!</dd>
<dd>
The functions decompose a dense matrix by means of LAPACK kernels. Thus the functions can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd></dl>
<h2><a class="anchor" id="matrix_operations_decomposition_lu"></a>
LU Decomposition</h2>
<p>The LU decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65" title="LU decomposition of the given dense matrix. ">lu()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == L * U * P );</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a column-major matrix</span></div><div class="line"></div><div class="line">assert( A == P * L * U );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices. Note, however, that the three matrices <code>A</code>, <code>L</code> and <code>U</code> are required to have the same storage order. Also, please note that the way the permutation matrix <code>P</code> needs to be applied differs between row-major and column-major matrices, since the algorithm uses column interchanges for row-major matrices and row interchanges for column-major matrices.</p>
<p>Furthermore, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65" title="LU decomposition of the given dense matrix. ">lu()</a></code> can be used with adaptors. For instance, the following example demonstrates the LU decomposition of a symmetric matrix into a lower and upper triangular matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; L;</div><div class="line"><a class="code" href="../../d5/daf/classblaze_1_1UpperMatrix.html">blaze::UpperMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; U;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decomposition_llh"></a>
Cholesky Decomposition</h2>
<p>The Cholesky (LLH) decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662" title="Cholesky (LLH) decomposition of the given dense matrix. ">llh()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> L;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">llh</a>( A, L );  <span class="comment">// LLH decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == L * <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( L ) );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices and the two matrices <code>A</code> and <code>L</code> can have any storage order.</p>
<p>Furthermore, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662" title="Cholesky (LLH) decomposition of the given dense matrix. ">llh()</a></code> can be used with adaptors. For instance, the following example demonstrates the LLH decomposition of a symmetric matrix into a lower triangular matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; L;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">llh</a>( A, L );  <span class="comment">// Cholesky decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decomposition_qr"></a>
QR Decomposition</h2>
<p>The QR decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6" title="QR decomposition of the given dense matrix. ">qr()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> R;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">qr</a>( A, Q, R );  <span class="comment">// QR decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == Q * R );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices and the three matrices <code>A</code>, <code>Q</code> and <code>R</code> can have any storage order.</p>
<p>Furthermore, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6" title="QR decomposition of the given dense matrix. ">qr()</a></code> can be used with adaptors. For instance, the following example demonstrates the QR decomposition of a symmetric matrix into a general matrix and an upper triangular matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> Q;</div><div class="line"><a class="code" href="../../d5/daf/classblaze_1_1UpperMatrix.html">blaze::UpperMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; R;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">qr</a>( A, Q, R );  <span class="comment">// QR decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decomposition_rq"></a>
RQ Decomposition</h2>
<p>Similar to the QR decomposition, the RQ decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba" title="RQ decomposition of the given dense matrix. ">rq()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> R;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">rq</a>( A, R, Q );  <span class="comment">// RQ decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == R * Q );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices and the three matrices <code>A</code>, <code>R</code> and <code>Q</code> can have any storage order.</p>
<p>Also the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba" title="RQ decomposition of the given dense matrix. ">rq()</a></code> function can be used in combination with matrix adaptors. For instance, the following example demonstrates the RQ decomposition of an Hermitian matrix into a general matrix and an upper triangular matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix&lt; blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>&gt; &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../d5/daf/classblaze_1_1UpperMatrix.html">blaze::UpperMatrix&lt; blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>&gt; &gt; R;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>&gt; Q;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">rq</a>( A, R, Q );  <span class="comment">// RQ decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decomposition_ql"></a>
QL Decomposition</h2>
<p>The QL decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f" title="QL decomposition of the given dense matrix. ">ql()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> Q;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">ql</a>( A, Q, L );  <span class="comment">// QL decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == Q * L );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices and the three matrices <code>A</code>, <code>Q</code> and <code>L</code> can have any storage order.</p>
<p>Also the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f" title="QL decomposition of the given dense matrix. ">ql()</a></code> function can be used in combination with matrix adaptors. For instance, the following example demonstrates the QL decomposition of a symmetric matrix into a general matrix and a lower triangular matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> Q;</div><div class="line"><a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix&lt; blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> &gt; L;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">ql</a>( A, Q, L );  <span class="comment">// QL decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="matrix_operations_decomposition_lq"></a>
LQ Decomposition</h2>
<p>The LQ decomposition of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2" title="LQ decomposition of the given dense matrix. ">lq()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> L;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">lq</a>( A, L, Q );  <span class="comment">// LQ decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == L * Q );</div></div><!-- fragment --><p>The function works for both <code>rowMajor</code> and <code>columnMajor</code> matrices and the three matrices <code>A</code>, <code>L</code> and <code>Q</code> can have any storage order.</p>
<p>Furthermore, <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2" title="LQ decomposition of the given dense matrix. ">lq()</a></code> can be used with adaptors. For instance, the following example demonstrates the LQ decomposition of an Hermitian matrix into a lower triangular matrix and a general matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix&lt; blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>&gt; &gt; A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../da/ddf/classblaze_1_1LowerMatrix.html">blaze::LowerMatrix&lt; blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>&gt; &gt; L;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;complex&lt;double&gt;</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>&gt; Q;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">lq</a>( A, L, Q );  <span class="comment">// LQ decomposition of A</span></div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_eigenvalues"></a>
Eigenvalues/Eigenvectors</h1>
<hr/>
<p>The eigenvalues and eigenvectors of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992" title="Eigenvalue computation of the given dense matrix. ">eigen()</a></code> functions:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d2/de9/namespaceblaze.html">blaze</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> SO, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( <span class="keyword">const</span> DenseMatrix&lt;MT,SO&gt;&amp; A, DenseVector&lt;VT,TF&gt;&amp; w );</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT1, <span class="keywordtype">bool</span> SO1, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF, <span class="keyword">typename</span> MT2, <span class="keywordtype">bool</span> SO2 &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( <span class="keyword">const</span> DenseMatrix&lt;MT1,SO1&gt;&amp; A, DenseVector&lt;VT,TF&gt;&amp; w, DenseMatrix&lt;MT2,SO2&gt;&amp; V );</div><div class="line"></div><div class="line">} <span class="comment">// namespace blaze</span></div></div><!-- fragment --><p>The first function computes only the eigenvalues of the given <em>n-by-<em>n</em> matrix</em>, the second function additionally computes the eigenvectors. The eigenvalues are returned in the given vector <em>w</em> and the eigenvectors are returned in the given matrix <em>V</em>, which are both resized to the correct dimensions (if possible and necessary).</p>
<p>Depending on the given matrix type, the resulting eigenvalues are either of floating point or complex type: In case the given matrix is either a compile time symmetric matrix with floating point elements or an Hermitian matrix with complex elements, the resulting eigenvalues will be of floating point type and therefore the elements of the given eigenvalue vector are expected to be of floating point type. In all other cases they are expected to be of complex type. Please note that for complex eigenvalues no order of eigenvalues can be assumed, except that complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>In case <em>A</em> is a row-major matrix, the left eigenvectors are returned in the rows of <em>V</em>, in case <em>A</em> is a column-major matrix, the right eigenvectors are returned in the columns of <em>V</em>. In case the given matrix is a compile time symmetric matrix with floating point elements, the resulting eigenvectors will be of floating point type and therefore the elements of the given eigenvector matrix are expected to be of floating point type. In all other cases they are expected to be of complex type.</p>
<p>The following examples give an impression of the computation of eigenvalues and eigenvectors for a general, a symmetric, and an Hermitian matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt; A( 5UL, 5UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a>&gt; w( 5UL );   <span class="comment">// The vector for the complex eigenvalues</span></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">SymmetricMatrix&lt; DynamicMatrix&lt;double,rowMajor&gt; &gt; A( 5UL, 5UL );  <span class="comment">// The symmetric matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; w( 5UL );       <span class="comment">// The vector for the real eigenvalues</span></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">HermitianMatrix&lt; DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; &gt; A( 5UL, 5UL );  <span class="comment">// The Hermitian matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt;      w( 5UL );       <span class="comment">// The vector for the real eigenvalues</span></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><p>The functions fail if ...</p>
<ul>
<li>... the given matrix <em>A</em> is not a square matrix;</li>
<li>... the given vector <em>w</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given matrix <em>V</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the eigenvalue computation fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>All <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992" title="Eigenvalue computation of the given dense matrix. ">eigen()</a></code> functions can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type or with a sparse matrix results in a compile time error!</dd>
<dd>
The functions compute the eigenvalues and/or eigenvectors of a dense matrix by means of LAPACK kernels. Thus the functions can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="matrix_operations_singularvalues"></a>
Singular Values/Singular Vectors</h1>
<hr/>
<p>The singular value decomposition (SVD) of a dense matrix can be computed via the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272" title="Singular value decomposition (SVD) of the given dense general matrix. ">svd()</a></code> functions:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d2/de9/namespaceblaze.html">blaze</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> SO, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( <span class="keyword">const</span> DenseMatrix&lt;MT,SO&gt;&amp; A, DenseVector&lt;VT,TF&gt;&amp; s );</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT1, <span class="keywordtype">bool</span> SO, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF, <span class="keyword">typename</span> MT2, <span class="keyword">typename</span> MT3 &gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( <span class="keyword">const</span> DenseMatrix&lt;MT1,SO&gt;&amp; A, DenseMatrix&lt;MT2,SO&gt;&amp; U, DenseVector&lt;VT,TF&gt;&amp; s, DenseMatrix&lt;MT3,SO&gt;&amp; V );</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> SO, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF, <span class="keyword">typename</span> ST &gt;</div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( <span class="keyword">const</span> DenseMatrix&lt;MT,SO&gt;&amp; A, DenseVector&lt;VT,TF&gt;&amp; s, ST low, ST upp );</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT1, <span class="keywordtype">bool</span> SO, <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> TF, <span class="keyword">typename</span> MT2, <span class="keyword">typename</span> MT3, <span class="keyword">typename</span> ST &gt;</div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( <span class="keyword">const</span> DenseMatrix&lt;MT1,SO&gt;&amp; A, DenseMatrix&lt;MT2,SO&gt;&amp; U, DenseVector&lt;VT,TF&gt;&amp; s, DenseMatrix&lt;MT3,SO&gt;&amp; V, ST low, ST upp );</div><div class="line"></div><div class="line">} <span class="comment">// namespace blaze</span></div></div><!-- fragment --><p>The first and third function compute only singular values of the given general <em>m-by-<em>n</em> matrix</em>, the second and fourth function additionally compute singular vectors. The resulting singular values are returned in the given vector <em>s</em>, the left singular vectors are returned in the given matrix <em>U</em>, and the right singular vectors are returned in the matrix <em>V</em>. <em>s</em>, <em>U</em>, and <em>V</em> are resized to the correct dimensions (if possible and necessary).</p>
<p>The third and fourth function allow for the specification of a subset of singular values and/or vectors. The number of singular values and vectors to be computed is specified by the lower bound <em>low</em> and the upper bound <em>upp</em>, which either form an integral or a floating point range.</p>
<p>In case <em>low</em> and <em>upp</em> form are of integral type, the function computes all singular values in the index range <img class="formulaInl" alt="$[low..upp]$" src="../../form_79.png"/>. The <em>num</em> resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a <em>num-dimensional</em> vector. The resulting left singular vectors are stored in the given matrix <em>U</em>, which is either resized (if possible) or expected to be a <em>m-by-<em>num</em> matrix</em>. The resulting right singular vectors are stored in the given matrix <em>V</em>, which is either resized (if possible) or expected to be a <em>num-by-<em>n</em> matrix</em>.</p>
<p>In case <em>low</em> and <em>upp</em> are of floating point type, the function computes all singular values in the half-open interval <img class="formulaInl" alt="$(low..upp]$" src="../../form_80.png"/>. The resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a min(<em>m</em>,<em>n</em>)-dimensional vector. The resulting left singular vectors are stored in the given matrix <em>U</em>, which is either resized (if possible) or expected to be a <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix. The resulting right singular vectors are stored in the given matrix <em>V</em>, which is either resized (if possible) or expected to be a min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix.</p>
<p>The functions fail if ...</p>
<ul>
<li>... the given matrix <em>U</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the given vector <em>s</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given matrix <em>V</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the given scalar values don't form a proper range;</li>
<li>... the singular value decomposition fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     U;  <span class="comment">// The matrix for the left singular vectors</span></div><div class="line">DynamicVector&lt;double,columnVector&gt; s;  <span class="comment">// The vector for the singular values</span></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     V;  <span class="comment">// The matrix for the right singular vectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, U, s, V );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; U;  <span class="comment">// The matrix for the left singular vectors</span></div><div class="line">DynamicVector&lt;double,columnVector&gt;      s;  <span class="comment">// The vector for the singular values</span></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; V;  <span class="comment">// The matrix for the right singular vectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, U, s, V, 0, 2 );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272" title="Singular value decomposition (SVD) of the given dense general matrix. ">svd()</a></code> functions can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type or with a sparse matrix results in a compile time error!</dd>
<dd>
The functions compute the singular values and/or singular vectors of a dense matrix by means of LAPACK kernels. Thus the functions can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd></dl>
<p><br />
 Previous: <a class="el" href="../../da/d37/matrix_types.html">Matrix Types</a> &#160; &#160; Next: <a class="el" href="../../d0/d34/adaptors.html">Adaptors</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
