<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::SparseVectorProxy&lt; PT, VT &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../dc/dbe/classblaze_1_1SparseVectorProxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::SparseVectorProxy&lt; PT, VT &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse vector types.The <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html" title="Proxy backend for sparse vector types.The SparseVectorProxy class serves as a backend for the Proxy c...">SparseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse vectors.  
 <a href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d3/ded/SparseVectorProxy_8h_source.html">SparseVectorProxy.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; PT, IsRowVector&lt; VT &gt;::value &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a51623e9dce73b0eae41b218776a1ae5e"><td class="memItemLeft" align="right" valign="top"><a id="a51623e9dce73b0eae41b218776a1ae5e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = VT::smpAssignable
 }<tr class="memdesc:a51623e9dce73b0eae41b218776a1ae5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments. <br /></td></tr>
</td></tr>
<tr class="separator:a51623e9dce73b0eae41b218776a1ae5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13b61a61f7a0c4e5e286f1077676282"><td class="memItemLeft" align="right" valign="top"><a id="ae13b61a61f7a0c4e5e286f1077676282"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ae13b61a61f7a0c4e5e286f1077676282">ResultType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a5a86db58851c76c3500769d8afdc759e">ResultType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:ae13b61a61f7a0c4e5e286f1077676282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:ae13b61a61f7a0c4e5e286f1077676282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b7e9762425043fbbdf53c42a5705db"><td class="memItemLeft" align="right" valign="top"><a id="a55b7e9762425043fbbdf53c42a5705db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a55b7e9762425043fbbdf53c42a5705db">TransposeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aca0f2ff41fa8f2a1a6ff10fe09817cd8">TransposeType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a55b7e9762425043fbbdf53c42a5705db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a55b7e9762425043fbbdf53c42a5705db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fc4e4619a652d861d983f09be33100"><td class="memItemLeft" align="right" valign="top"><a id="a61fc4e4619a652d861d983f09be33100"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a61fc4e4619a652d861d983f09be33100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse vector elements. <br /></td></tr>
<tr class="separator:a61fc4e4619a652d861d983f09be33100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a475440412d820fc26d6b2a03815a7a"><td class="memItemLeft" align="right" valign="top"><a id="a1a475440412d820fc26d6b2a03815a7a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a1a475440412d820fc26d6b2a03815a7a">ReturnType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa2e2edcdde49d73a7ca7d2515046b088">ReturnType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a1a475440412d820fc26d6b2a03815a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a1a475440412d820fc26d6b2a03815a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c049470ccd8113639e73297f292c5fd"><td class="memItemLeft" align="right" valign="top"><a id="a3c049470ccd8113639e73297f292c5fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a3c049470ccd8113639e73297f292c5fd">CompositeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#acf0851f216dd228db447fbf55718e18c">CompositeType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a3c049470ccd8113639e73297f292c5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a3c049470ccd8113639e73297f292c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52ca649b7450815d0b6af418921b34"><td class="memItemLeft" align="right" valign="top"><a id="a0d52ca649b7450815d0b6af418921b34"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0d52ca649b7450815d0b6af418921b34">Reference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a1285adb17e7a11f3dee9b2b0f03f8a89">Reference_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a0d52ca649b7450815d0b6af418921b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant vector value. <br /></td></tr>
<tr class="separator:a0d52ca649b7450815d0b6af418921b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2105b4b29268471c065ce933558fab8"><td class="memItemLeft" align="right" valign="top"><a id="ab2105b4b29268471c065ce933558fab8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ab2105b4b29268471c065ce933558fab8">ConstReference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a7428fec1f7754658bd4d765ed6e87841">ConstReference_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:ab2105b4b29268471c065ce933558fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant vector value. <br /></td></tr>
<tr class="separator:ab2105b4b29268471c065ce933558fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e640a2b42b73b6c9ccecb6db484e0"><td class="memItemLeft" align="right" valign="top"><a id="ac32e640a2b42b73b6c9ccecb6db484e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a55cefc4108da9a311933047654da11b1">Iterator_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:ac32e640a2b42b73b6c9ccecb6db484e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:ac32e640a2b42b73b6c9ccecb6db484e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca57cbb8d03a423ed89fcf2261937b9e"><td class="memItemLeft" align="right" valign="top"><a id="aca57cbb8d03a423ed89fcf2261937b9e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aca57cbb8d03a423ed89fcf2261937b9e">ConstIterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa1d864b56dde1649490ccd585cb20508">ConstIterator_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:aca57cbb8d03a423ed89fcf2261937b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:aca57cbb8d03a423ed89fcf2261937b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memItemLeft" align="right" valign="top"><a id="a4e76ca32c31f9077cb773fe1cc414a52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> = PT</td></tr>
<tr class="memdesc:a4e76ca32c31f9077cb773fe1cc414a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7721338a0234a4dee3200733d8056e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a7721338a0234a4dee3200733d8056e68">operator~</a> () noexcept</td></tr>
<tr class="memdesc:a7721338a0234a4dee3200733d8056e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a7721338a0234a4dee3200733d8056e68">More...</a><br /></td></tr>
<tr class="separator:a7721338a0234a4dee3200733d8056e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fea61cee277be4dcad4276b298237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a466fea61cee277be4dcad4276b298237">operator~</a> () const noexcept</td></tr>
<tr class="memdesc:a466fea61cee277be4dcad4276b298237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#a466fea61cee277be4dcad4276b298237">More...</a><br /></td></tr>
<tr class="separator:a466fea61cee277be4dcad4276b298237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:ad52b07f280b66b403445bc222c7b8137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0d52ca649b7450815d0b6af418921b34">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ad52b07f280b66b403445bc222c7b8137">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:ad52b07f280b66b403445bc222c7b8137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to vector elements.  <a href="#ad52b07f280b66b403445bc222c7b8137">More...</a><br /></td></tr>
<tr class="separator:ad52b07f280b66b403445bc222c7b8137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcb1d6e8597e9aaf861363677f20fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0d52ca649b7450815d0b6af418921b34">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#abfcb1d6e8597e9aaf861363677f20fb2">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:abfcb1d6e8597e9aaf861363677f20fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the vector elements.  <a href="#abfcb1d6e8597e9aaf861363677f20fb2">More...</a><br /></td></tr>
<tr class="separator:abfcb1d6e8597e9aaf861363677f20fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9401abd0cc7318f7fe7f8c82cd298b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a9401abd0cc7318f7fe7f8c82cd298b78">begin</a> () const</td></tr>
<tr class="memdesc:a9401abd0cc7318f7fe7f8c82cd298b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#a9401abd0cc7318f7fe7f8c82cd298b78">More...</a><br /></td></tr>
<tr class="separator:a9401abd0cc7318f7fe7f8c82cd298b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239e9bb43236f98d1ac5af385d6d1b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aca57cbb8d03a423ed89fcf2261937b9e">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ae239e9bb43236f98d1ac5af385d6d1b0">cbegin</a> () const</td></tr>
<tr class="memdesc:ae239e9bb43236f98d1ac5af385d6d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#ae239e9bb43236f98d1ac5af385d6d1b0">More...</a><br /></td></tr>
<tr class="separator:ae239e9bb43236f98d1ac5af385d6d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234e378b9ff9708805ef8fa3cb2feaba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba">end</a> () const</td></tr>
<tr class="memdesc:a234e378b9ff9708805ef8fa3cb2feaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#a234e378b9ff9708805ef8fa3cb2feaba">More...</a><br /></td></tr>
<tr class="separator:a234e378b9ff9708805ef8fa3cb2feaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69f910fa2ab3ef445375f6e9ec1700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aca57cbb8d03a423ed89fcf2261937b9e">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a4a69f910fa2ab3ef445375f6e9ec1700">cend</a> () const</td></tr>
<tr class="memdesc:a4a69f910fa2ab3ef445375f6e9ec1700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#a4a69f910fa2ab3ef445375f6e9ec1700">More...</a><br /></td></tr>
<tr class="separator:a4a69f910fa2ab3ef445375f6e9ec1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a00b4ce86bac66a7e547fe66930d9766d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a00b4ce86bac66a7e547fe66930d9766d">size</a> () const</td></tr>
<tr class="memdesc:a00b4ce86bac66a7e547fe66930d9766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="#a00b4ce86bac66a7e547fe66930d9766d">More...</a><br /></td></tr>
<tr class="separator:a00b4ce86bac66a7e547fe66930d9766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb634a1abcbb80bce0f23a07e55e2c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#abb634a1abcbb80bce0f23a07e55e2c79">capacity</a> () const</td></tr>
<tr class="memdesc:abb634a1abcbb80bce0f23a07e55e2c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="#abb634a1abcbb80bce0f23a07e55e2c79">More...</a><br /></td></tr>
<tr class="separator:abb634a1abcbb80bce0f23a07e55e2c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047af54c3fd70760b677f208d360e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a4047af54c3fd70760b677f208d360e1d">nonZeros</a> () const</td></tr>
<tr class="memdesc:a4047af54c3fd70760b677f208d360e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="#a4047af54c3fd70760b677f208d360e1d">More...</a><br /></td></tr>
<tr class="separator:a4047af54c3fd70760b677f208d360e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfec80116555681a062e48b663ab75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a7acfec80116555681a062e48b663ab75">reset</a> () const</td></tr>
<tr class="memdesc:a7acfec80116555681a062e48b663ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial value.  <a href="#a7acfec80116555681a062e48b663ab75">More...</a><br /></td></tr>
<tr class="separator:a7acfec80116555681a062e48b663ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdd57b7024c72d6d173b47908808d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a3fdd57b7024c72d6d173b47908808d4a">clear</a> () const</td></tr>
<tr class="memdesc:a3fdd57b7024c72d6d173b47908808d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented vector.  <a href="#a3fdd57b7024c72d6d173b47908808d4a">More...</a><br /></td></tr>
<tr class="separator:a3fdd57b7024c72d6d173b47908808d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42863abd446c27886c6d326197128feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a42863abd446c27886c6d326197128feb">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true) const</td></tr>
<tr class="memdesc:a42863abd446c27886c6d326197128feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented vector.  <a href="#a42863abd446c27886c6d326197128feb">More...</a><br /></td></tr>
<tr class="separator:a42863abd446c27886c6d326197128feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c3fccd166513b5d424fde4cbc300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0768c3fccd166513b5d424fde4cbc300">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n) const</td></tr>
<tr class="memdesc:a0768c3fccd166513b5d424fde4cbc300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the represented vector.  <a href="#a0768c3fccd166513b5d424fde4cbc300">More...</a><br /></td></tr>
<tr class="separator:a0768c3fccd166513b5d424fde4cbc300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion functions</div></td></tr>
<tr class="memitem:af1576af17a405afe6ec9fdd6c849ead5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#af1576af17a405afe6ec9fdd6c849ead5">set</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;value) const</td></tr>
<tr class="memdesc:af1576af17a405afe6ec9fdd6c849ead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an element of the represented sparse vector.  <a href="#af1576af17a405afe6ec9fdd6c849ead5">More...</a><br /></td></tr>
<tr class="separator:af1576af17a405afe6ec9fdd6c849ead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b380caad7902856292a42d06b67020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a27b380caad7902856292a42d06b67020">insert</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;value) const</td></tr>
<tr class="memdesc:a27b380caad7902856292a42d06b67020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the represented sparse vector.  <a href="#a27b380caad7902856292a42d06b67020">More...</a><br /></td></tr>
<tr class="separator:a27b380caad7902856292a42d06b67020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894fd9694621e6094ba81ef72fe317f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a9894fd9694621e6094ba81ef72fe317f">append</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;value, bool check=false) const</td></tr>
<tr class="memdesc:a9894fd9694621e6094ba81ef72fe317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending an element to the represented sparse vector.  <a href="#a9894fd9694621e6094ba81ef72fe317f">More...</a><br /></td></tr>
<tr class="separator:a9894fd9694621e6094ba81ef72fe317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Erase functions</div></td></tr>
<tr class="memitem:a76d69c9009c557124e508e54bfa1dadf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a76d69c9009c557124e508e54bfa1dadf">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:a76d69c9009c557124e508e54bfa1dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse vector.  <a href="#a76d69c9009c557124e508e54bfa1dadf">More...</a><br /></td></tr>
<tr class="separator:a76d69c9009c557124e508e54bfa1dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba94fde0d1f76013072aa95ddb71b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#abba94fde0d1f76013072aa95ddb71b52">erase</a> (<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> pos) const</td></tr>
<tr class="memdesc:abba94fde0d1f76013072aa95ddb71b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse vector.  <a href="#abba94fde0d1f76013072aa95ddb71b52">More...</a><br /></td></tr>
<tr class="separator:abba94fde0d1f76013072aa95ddb71b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef97555899f0625e821e513814cc9b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aaef97555899f0625e821e513814cc9b9">erase</a> (<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> first, <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> last) const</td></tr>
<tr class="memdesc:aaef97555899f0625e821e513814cc9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing a range of elements from the sparse vector.  <a href="#aaef97555899f0625e821e513814cc9b9">More...</a><br /></td></tr>
<tr class="separator:aaef97555899f0625e821e513814cc9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a80c10360b6f202b3e55b18af81c8fe"><td class="memTemplParams" colspan="2">template&lt;typename Pred , typename  = DisableIf_&lt; IsIntegral&lt;Pred&gt; &gt;&gt; </td></tr>
<tr class="memitem:a5a80c10360b6f202b3e55b18af81c8fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a5a80c10360b6f202b3e55b18af81c8fe">erase</a> (Pred predicate)</td></tr>
<tr class="memdesc:a5a80c10360b6f202b3e55b18af81c8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing specific elements from the sparse vector.  <a href="#a5a80c10360b6f202b3e55b18af81c8fe">More...</a><br /></td></tr>
<tr class="separator:a5a80c10360b6f202b3e55b18af81c8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50c9a9bcb73e7682b1331780104f7bd"><td class="memTemplParams" colspan="2">template&lt;typename Pred &gt; </td></tr>
<tr class="memitem:ae50c9a9bcb73e7682b1331780104f7bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ae50c9a9bcb73e7682b1331780104f7bd">erase</a> (<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> first, <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> last, Pred predicate)</td></tr>
<tr class="memdesc:ae50c9a9bcb73e7682b1331780104f7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing specific elements from a range of the sparse vector.  <a href="#ae50c9a9bcb73e7682b1331780104f7bd">More...</a><br /></td></tr>
<tr class="separator:ae50c9a9bcb73e7682b1331780104f7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:a3f68f53c66d6784af9015bd9706b554c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a3f68f53c66d6784af9015bd9706b554c">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:a3f68f53c66d6784af9015bd9706b554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific vector element.  <a href="#a3f68f53c66d6784af9015bd9706b554c">More...</a><br /></td></tr>
<tr class="separator:a3f68f53c66d6784af9015bd9706b554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18a6b5c92f211a0fd207b530283786c"><td class="memItemLeft" align="right" valign="top"><a id="ab18a6b5c92f211a0fd207b530283786c"></a>
<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="separator:ab18a6b5c92f211a0fd207b530283786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a217b375cc99bc0b5b7b317f3e5ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a85a217b375cc99bc0b5b7b317f3e5ae1">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:a85a217b375cc99bc0b5b7b317f3e5ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#a85a217b375cc99bc0b5b7b317f3e5ae1">More...</a><br /></td></tr>
<tr class="separator:a85a217b375cc99bc0b5b7b317f3e5ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f098e7eee3c4a04fada0823ca637ad"><td class="memItemLeft" align="right" valign="top"><a id="a29f098e7eee3c4a04fada0823ca637ad"></a>
<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lowerBound</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="separator:a29f098e7eee3c4a04fada0823ca637ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cdf15b271b1ddd6e897f2f9227300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a68cdf15b271b1ddd6e897f2f9227300b">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:a68cdf15b271b1ddd6e897f2f9227300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#a68cdf15b271b1ddd6e897f2f9227300b">More...</a><br /></td></tr>
<tr class="separator:a68cdf15b271b1ddd6e897f2f9227300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32527567c66525b8442cf195752178ac"><td class="memItemLeft" align="right" valign="top"><a id="a32527567c66525b8442cf195752178ac"></a>
<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>upperBound</b> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="separator:a32527567c66525b8442cf195752178ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numeric functions</div></td></tr>
<tr class="memitem:a33dd94ced9ea4966d3b92dc1e03bda11"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a33dd94ced9ea4966d3b92dc1e03bda11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a33dd94ced9ea4966d3b92dc1e03bda11">scale</a> (const Other &amp;scalar) const</td></tr>
<tr class="memdesc:a33dd94ced9ea4966d3b92dc1e03bda11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the sparse vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>).  <a href="#a33dd94ced9ea4966d3b92dc1e03bda11">More...</a><br /></td></tr>
<tr class="separator:a33dd94ced9ea4966d3b92dc1e03bda11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PT, typename VT&gt;<br />
class blaze::SparseVectorProxy&lt; PT, VT &gt;</h3>

<p><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse vector types.</p>
<p>The <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html" title="Proxy backend for sparse vector types.The SparseVectorProxy class serves as a backend for the Proxy c...">SparseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse vectors. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9894fd9694621e6094ba81ef72fe317f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9894fd9694621e6094ba81ef72fe317f">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appending an element to the represented sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be appended. </td></tr>
    <tr><td class="paramname">check</td><td><em>true</em> if the new value should be checked for default values, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides a very efficient way to fill a sparse vector with elements. It appends a new element to the end of the sparse vector without any memory allocation. Therefore it is strictly necessary to keep the following preconditions in mind:</p>
<ul>
<li>the index of the new element must be strictly larger than the largest index of non-zero elements in the sparse vector</li>
<li>the current number of non-zero elements must be smaller than the capacity of the vector</li>
</ul>
<p>Ignoring these preconditions might result in undefined behavior! The optional <em>check</em> parameter specifies whether the new value should be tested for a default value. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the new value is a default value (for instance 0 in case of an integral element type) the value is not appended. Per default the values are not tested.</p>
<dl class="section note"><dt>Note</dt><dd>Although <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a9894fd9694621e6094ba81ef72fe317f" title="Appending an element to the represented sparse vector. ">append()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> functions! </dd></dl>

</div>
</div>
<a id="abfcb1d6e8597e9aaf861363677f20fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcb1d6e8597e9aaf861363677f20fb2">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0d52ca649b7450815d0b6af418921b34">Reference</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>Invalid vector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a reference to the accessed value at position <em>index</em>. In case the sparse vector does not yet store an element for index <em>index</em>, a new element is inserted into the sparse vector. In contrast to the subscript operator this function always performs a check of the given access index. </p>

</div>
</div>
<a id="a9401abd0cc7318f7fe7f8c82cd298b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9401abd0cc7318f7fe7f8c82cd298b78">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="abb634a1abcbb80bce0f23a07e55e2c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb634a1abcbb80bce0f23a07e55e2c79">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a id="ae239e9bb43236f98d1ac5af385d6d1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae239e9bb43236f98d1ac5af385d6d1b0">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aca57cbb8d03a423ed89fcf2261937b9e">ConstIterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="a4a69f910fa2ab3ef445375f6e9ec1700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a69f910fa2ab3ef445375f6e9ec1700">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#aca57cbb8d03a423ed89fcf2261937b9e">ConstIterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="a3fdd57b7024c72d6d173b47908808d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdd57b7024c72d6d173b47908808d4a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default initial state. </p>

</div>
</div>
<a id="a234e378b9ff9708805ef8fa3cb2feaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234e378b9ff9708805ef8fa3cb2feaba">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="a76d69c9009c557124e508e54bfa1dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d69c9009c557124e508e54bfa1dadf">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases an element from the sparse vector. </p>

</div>
</div>
<a id="abba94fde0d1f76013072aa95ddb71b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba94fde0d1f76013072aa95ddb71b52">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases an element from the sparse vector. </p>

</div>
</div>
<a id="aaef97555899f0625e821e513814cc9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef97555899f0625e821e513814cc9b9">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing a range of elements from the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a range of elements from the sparse vector. </p>

</div>
</div>
<a id="a5a80c10360b6f202b3e55b18af81c8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a80c10360b6f202b3e55b18af81c8fe">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<div class="memtemplate">
template&lt;typename Pred , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing specific elements from the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The unary predicate for the element selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void.</dd></dl>
<p>This function erases specific elements from the sparse vector. The elements are selected by the given unary predicate <em>predicate</em>, which is expected to accept a single argument of the type of the elements and to be pure.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate is required to be pure, i.e. to produce deterministic results for elements with the same value. The attempt to use an impure predicate leads to undefined behavior! </dd></dl>

</div>
</div>
<a id="ae50c9a9bcb73e7682b1331780104f7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50c9a9bcb73e7682b1331780104f7bd">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<div class="memtemplate">
template&lt;typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing specific elements from a range of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to first element of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element of the range. </td></tr>
    <tr><td class="paramname">predicate</td><td>The unary predicate for the element selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void.</dd></dl>
<p>This function erases specific elements from a range of elements of the sparse vector. The elements are selected by the given unary predicate <em>predicate</em>, which is expected to accept a single argument of the type of the elements and to be pure.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate is required to be pure, i.e. to produce deterministic results for elements with the same value. The attempt to use an impure predicate leads to undefined behavior! </dd></dl>

</div>
</div>
<a id="a3f68f53c66d6784af9015bd9706b554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f68f53c66d6784af9015bd9706b554c">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific vector element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse vector. It specifically searches for the element with index <em>index</em>. In case the element is found, the function returns an iterator to the element. Otherwise an iterator just past the last non-zero element of the sparse vector (the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> iterator) is returned. Note that the returned sparse vector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a27b380caad7902856292a42d06b67020" title="Inserting an element into the represented sparse vector. ">insert()</a> function! </p>

</div>
</div>
<a id="a27b380caad7902856292a42d06b67020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b380caad7902856292a42d06b67020">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the represented sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse vector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inserts a new element into the sparse vector. However, duplicate elements are not allowed. In case the sparse vector already contains an element with index <em>index</em>, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a85a217b375cc99bc0b5b7b317f3e5ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a217b375cc99bc0b5b7b317f3e5ae1">&#9670;&nbsp;</a></span>lowerBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index not less then the given index. In combination with the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a68cdf15b271b1ddd6e897f2f9227300b" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse vector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a27b380caad7902856292a42d06b67020" title="Inserting an element into the represented sparse vector. ">insert()</a> function! </p>

</div>
</div>
<a id="a4047af54c3fd70760b677f208d360e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4047af54c3fd70760b677f208d360e1d">&#9670;&nbsp;</a></span>nonZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always smaller than the current size of the sparse vector. </p>

</div>
</div>
<a id="ad52b07f280b66b403445bc222c7b8137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52b07f280b66b403445bc222c7b8137">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a0d52ca649b7450815d0b6af418921b34">Reference</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a reference to the accessed value at position <em>index</em>. In case the sparse vector does not yet store an element for index <em>index</em>, a new element is inserted into the sparse vector. A more efficient alternative for traversing the non-zero elements of the sparse vector are the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a9401abd0cc7318f7fe7f8c82cd298b78" title="Returns an iterator to the first element of the represented vector. ">begin()</a> and <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> functions. </p>

</div>
</div>
<a id="a7721338a0234a4dee3200733d8056e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7721338a0234a4dee3200733d8056e68">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; PT , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a466fea61cee277be4dcad4276b298237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fea61cee277be4dcad4276b298237">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; PT , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a0768c3fccd166513b5d424fde4cbc300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c3fccd166513b5d424fde4cbc300">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new minimum capacity of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function increases the capacity of the sparse vector to at least <em>n</em> elements. The current values of the vector elements are preserved. </p>

</div>
</div>
<a id="a7acfec80116555681a062e48b663ab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfec80116555681a062e48b663ab75">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial value. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the vector to the default initial values. </p>

</div>
</div>
<a id="a42863abd446c27886c6d326197128feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42863abd446c27886c6d326197128feb">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changing the size of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size of the vector. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the vector should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function changes the size of the vector. Depending on the type of the vector, during this operation new dynamic memory may be allocated in case the capacity of the vector is too small. Note that this function may invalidate all existing views (subvectors, ...) on the vector if it is used to shrink the vector. Additionally, the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a42863abd446c27886c6d326197128feb" title="Changing the size of the represented vector. ">resize()</a> operation potentially changes all vector elements. In order to preserve the old vector values, the <em>preserve</em> flag can be set to <em>true</em>. </p>

</div>
</div>
<a id="a33dd94ced9ea4966d3b92dc1e03bda11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dd94ced9ea4966d3b92dc1e03bda11">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the sparse vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the vector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function scales the vector by applying the given scalar value <em>scalar</em> to each element of the vector. For built-in and <code>complex</code> data types it has the same effect as using the multiplication assignment operator. </p>

</div>
</div>
<a id="af1576af17a405afe6ec9fdd6c849ead5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1576af17a405afe6ec9fdd6c849ead5">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a61fc4e4619a652d861d983f09be33100">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting an element of the represented sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the set value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse vector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value of an element of the sparse vector. In case the sparse vector already contains an element with index <em>index</em> its value is modified, else a new element with the given <em>value</em> is inserted. </p>

</div>
</div>
<a id="a00b4ce86bac66a7e547fe66930d9766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b4ce86bac66a7e547fe66930d9766d">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a id="a68cdf15b271b1ddd6e897f2f9227300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cdf15b271b1ddd6e897f2f9227300b">&#9670;&nbsp;</a></span>upperBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#ac32e640a2b42b73b6c9ccecb6db484e0">Iterator</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy</a>&lt; PT, VT &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a234e378b9ff9708805ef8fa3cb2feaba" title="Returns an iterator just past the last element of the represented vector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index greater then the given index. In combination with the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a85a217b375cc99bc0b5b7b317f3e5ae1" title="Returns an iterator to the first index not less then the given index. ">lowerBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse vector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#a27b380caad7902856292a42d06b67020" title="Inserting an element into the represented sparse vector. ">insert()</a> function! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/proxy/<a class="el" href="../../df/d8b/proxy_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/proxy/<a class="el" href="../../d3/ded/SparseVectorProxy_8h_source.html">SparseVectorProxy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:33 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
