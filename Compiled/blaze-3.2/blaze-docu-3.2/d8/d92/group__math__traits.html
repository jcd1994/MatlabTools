<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Expression traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Expression traits<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">blaze::AddExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluate the return type of an addition expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must either be scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be added, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dc4/structblaze_1_1AddExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">blaze::AddTrait&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class.  <a href="../../db/d18/structblaze_1_1AddTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html">blaze::BinaryMapExprTrait&lt; T1, T2, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a binary map expression.Via this type trait it is possible to evaluate the return type of a binary map expression. Given the two types <em>T1</em> and <em>T2</em>, which must either be vector or matrix types, and the custom operation type <em>OP</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if no binary map operation exists for the types, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html">blaze::BinaryMapTrait&lt; T1, T2, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html" title="Base template for the BinaryMapTrait class. ">BinaryMapTrait</a> class.  <a href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html">blaze::ColumnExprTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a column operation.Via this type trait it is possible to evaluate the return type of a column operation. Given the dense or sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d61/structblaze_1_1ColumnExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">blaze::ColumnTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class.  <a href="../../d5/d7f/structblaze_1_1ColumnTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">blaze::CrossExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a cross product expression.Via this type trait it is possible to evaluate the return type of a cross product expression. Given the two types <em>T1</em> and <em>T2</em>, which must be dense or sparse column vectors, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be used in a cross product, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d57/structblaze_1_1CrossExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">blaze::CrossTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class.  <a href="../../d4/d9c/structblaze_1_1CrossTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html">blaze::CTransExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible to evaluate the return type of a conjugate transpose expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no conjugate transpose operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d23/structblaze_1_1CTransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html">blaze::DeclDiagExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it is possible to evaluate the return type of a diagonal declaration (decldiag) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no decldiag operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html">blaze::DeclDiagTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html" title="Base template for the DeclDiagTrait class. ">DeclDiagTrait</a> class.  <a href="../../d1/d96/structblaze_1_1DeclDiagTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html">blaze::DeclHermExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait it is possible to evaluate the return type of an Hermitian declaration (declherm) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declherm operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html">blaze::DeclHermTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html" title="Base template for the DeclHermTrait class. ">DeclHermTrait</a> class.  <a href="../../d7/dfd/structblaze_1_1DeclHermTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html">blaze::DeclIdExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an identity declaration (declid) expression.Via this type trait it is possible to evaluate the return type of an identity declaration (declid) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declid operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d04/structblaze_1_1DeclIdExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html">blaze::DeclIdTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html" title="Base template for the DeclIdTrait class. ">DeclIdTrait</a> class.  <a href="../../d2/d77/structblaze_1_1DeclIdTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html">blaze::DeclLowExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is possible to evaluate the return type of a lower declaration (decllow) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no decllow operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html">blaze::DeclLowTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html" title="Base template for the DeclLowTrait class. ">DeclLowTrait</a> class.  <a href="../../d2/df4/structblaze_1_1DeclLowTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html">blaze::DeclSymExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it is possible to evaluate the return type of a symmetry declaration (declsym) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declsym operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html">blaze::DeclSymTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html" title="Base template for the DeclSymTrait class. ">DeclSymTrait</a> class.  <a href="../../d8/d7f/structblaze_1_1DeclSymTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html">blaze::DeclUppExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is possible to evaluate the return type of a upper declaration (declupp) expression. Given the type <em>T</em>, which must be a matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no declupp operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html">blaze::DeclUppTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html" title="Base template for the DeclUppTrait class. ">DeclUppTrait</a> class.  <a href="../../da/dfa/structblaze_1_1DeclUppTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html">blaze::DerestrictTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of the derestrict function.Via this type trait it is possible to evaluate the resulting return type of the derestrict function. Given the non-const vector or matrix type <em>T</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T</em> is neither a dense or sparse vector or matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/dc1/structblaze_1_1DerestrictTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">blaze::DivExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a division.Via this type trait it is possible to evaluate the return type of a division expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, where <em>T1</em> must either be a scalar, vector, or matrix type and <em>T2</em> which must be a scalar type, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be divided, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d73/structblaze_1_1DivExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">blaze::DivTrait&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class.  <a href="../../d2/d67/structblaze_1_1DivTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html">blaze::EvalExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evaluate the return type of an evaluation expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no evaluation operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/dc7/structblaze_1_1EvalExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html">blaze::ImagTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class.The <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template offers the possibility to select the resulting data type of a generic <em>imag</em> operation on the given type <em>T</em>. Given the type <em>T</em>, which must either be a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting data type of the operation. In case the type of <em>T</em> doesn't fit or if no <em>imag</em> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>. Note that <em>const</em> and <em>volatile</em> qualifiers and reference modifiers are generally ignored.  <a href="../../df/d0b/structblaze_1_1ImagTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html">blaze::InvExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an inversion expression.Via this type trait it is possible to evaluate the return type of an inversion expression. Given the type <em>T</em>, which must either a (complex) floating point type or a dense matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no inversion operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d78/structblaze_1_1InvExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">blaze::MultExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to evaluate the return type of a multiplication expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be multiplied, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da3/structblaze_1_1MultExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">blaze::MultTrait&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class.  <a href="../../df/daf/structblaze_1_1MultTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html">blaze::RealTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class.The <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template offers the possibility to select the resulting data type of a generic <em>real</em> operation on the given type <em>T</em>. Given the type <em>T</em>, which must either be a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting data type of the operation. In case the type of <em>T</em> doesn't fit or if no <em>real</em> operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>. Note that <em>const</em> and <em>volatile</em> qualifiers and reference modifiers are generally ignored.  <a href="../../dd/d50/structblaze_1_1RealTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html">blaze::RowExprTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a row operation.Via this type trait it is possible to evaluate the return type of a row operation. Given the dense or sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d25/structblaze_1_1RowExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">blaze::RowTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class.  <a href="../../df/d8f/structblaze_1_1RowTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html">blaze::SchurExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an Schur product expression.Via this type trait it is possible to evaluate the return type of a Schur product expression between matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be used in a Schur product, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d95/structblaze_1_1SchurExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html">blaze::SchurTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html" title="Base template for the SchurTrait class. ">SchurTrait</a> class.  <a href="../../dd/daf/structblaze_1_1SchurTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html">blaze::SerialExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to evaluate the return type of a serial evaluation expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no serial evaluation operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/de8/structblaze_1_1SerialExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">blaze::SubExprTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evaluate the return type of a subtraction expression between scalar, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be subtracted, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d9b/structblaze_1_1SubExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html">blaze::SubmatrixExprTrait&lt; MT, AF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to evaluate the return type of a submatrix operation. Given the dense or sparse matrix type <em>MT</em> and the alignment flag <em>AF</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">blaze::SubmatrixTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class.  <a href="../../de/d83/structblaze_1_1SubmatrixTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">blaze::SubTrait&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class.  <a href="../../dd/d27/structblaze_1_1SubTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html">blaze::SubvectorExprTrait&lt; VT, AF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to evaluate the return type of a subvector operation. Given the dense or sparse vector type <em>VT</em> and the alignment flag <em>AF</em>, the nested type <em>Type</em> corresponds to the resulting return type. In case the given type is neither a dense nor a sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">blaze::SubvectorTrait&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class.  <a href="../../df/d1b/structblaze_1_1SubvectorTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html">blaze::TransExprTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluate the return type of a transpose expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no transpose operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d9a/structblaze_1_1TransExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html">blaze::UnaryMapExprTrait&lt; T, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a unary map expression.Via this type trait it is possible to evaluate the return type of a unary map expression. Given the type <em>T</em>, which must either be a vector or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no unary map operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html">blaze::UnaryMapTrait&lt; T, OP &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html" title="Base template for the UnaryMapTrait class. ">UnaryMapTrait</a> class.  <a href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d1e/structblaze_1_1HighType.html">blaze::HighType&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> type trait.  <a href="../../dc/d1e/structblaze_1_1HighType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d00/structblaze_1_1LowType.html">blaze::LowType&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> type trait.  <a href="../../d5/d00/structblaze_1_1LowType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa8e44a329b04c220d865a66e33ebd605"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa8e44a329b04c220d865a66e33ebd605"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">blaze::AddExprTrait_</a> = typename <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">AddExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gaa8e44a329b04c220d865a66e33ebd605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template.The AddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">More...</a><br /></td></tr>
<tr class="separator:gaa8e44a329b04c220d865a66e33ebd605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719d2bf697506ad8e36243d837d72c0c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga719d2bf697506ad8e36243d837d72c0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga719d2bf697506ad8e36243d837d72c0c">blaze::AddTrait_</a> = typename <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">AddTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga719d2bf697506ad8e36243d837d72c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.The AddTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga719d2bf697506ad8e36243d837d72c0c">More...</a><br /></td></tr>
<tr class="separator:ga719d2bf697506ad8e36243d837d72c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9193c05a040482279b6ab5ec9053011"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename OP &gt; </td></tr>
<tr class="memitem:gac9193c05a040482279b6ab5ec9053011"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac9193c05a040482279b6ab5ec9053011">blaze::BinaryMapExprTrait_</a> = typename <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html">BinaryMapExprTrait</a>&lt; T1, T2, OP &gt;::Type</td></tr>
<tr class="memdesc:gac9193c05a040482279b6ab5ec9053011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html" title="Evaluation of the return type of a binary map expression.Via this type trait it is possible to evalua...">BinaryMapExprTrait</a> class template.The BinaryMapExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html" title="Evaluation of the return type of a binary map expression.Via this type trait it is possible to evalua...">BinaryMapExprTrait</a> class template. For instance, given the data types <em>T1</em> and and <em>T2</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac9193c05a040482279b6ab5ec9053011">More...</a><br /></td></tr>
<tr class="separator:gac9193c05a040482279b6ab5ec9053011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa4fd93fe21f3d88f1e0eab21519a2a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename OP &gt; </td></tr>
<tr class="memitem:ga1fa4fd93fe21f3d88f1e0eab21519a2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1fa4fd93fe21f3d88f1e0eab21519a2a">blaze::BinaryMapTrait_</a> = typename <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html">BinaryMapTrait</a>&lt; T1, T2, OP &gt;::Type</td></tr>
<tr class="memdesc:ga1fa4fd93fe21f3d88f1e0eab21519a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html" title="Base template for the BinaryMapTrait class. ">BinaryMapTrait</a> class template.The BinaryMapTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html" title="Base template for the BinaryMapTrait class. ">BinaryMapTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1fa4fd93fe21f3d88f1e0eab21519a2a">More...</a><br /></td></tr>
<tr class="separator:ga1fa4fd93fe21f3d88f1e0eab21519a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3507cda05675a7d310b22f91dce0059a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3507cda05675a7d310b22f91dce0059a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">blaze::ColumnExprTrait_</a> = typename <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html">ColumnExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga3507cda05675a7d310b22f91dce0059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> type trait.The ColumnExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">More...</a><br /></td></tr>
<tr class="separator:ga3507cda05675a7d310b22f91dce0059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gaeaffe2e5a832863701a9bfdccc7402aa">blaze::ColumnTrait_</a> = typename <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">ColumnTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> type trait.The ColumnTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gaeaffe2e5a832863701a9bfdccc7402aa">More...</a><br /></td></tr>
<tr class="separator:gaeaffe2e5a832863701a9bfdccc7402aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1fa52bdff3e1372cc0d2c43432ba44e4">blaze::CrossExprTrait_</a> = typename <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">CrossExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template.The CrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1fa52bdff3e1372cc0d2c43432ba44e4">More...</a><br /></td></tr>
<tr class="separator:ga1fa52bdff3e1372cc0d2c43432ba44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb2ac508bc7cc89a27414852be39391"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1eb2ac508bc7cc89a27414852be39391"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1eb2ac508bc7cc89a27414852be39391">blaze::CrossTrait_</a> = typename <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">CrossTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1eb2ac508bc7cc89a27414852be39391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.The CrossTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1eb2ac508bc7cc89a27414852be39391">More...</a><br /></td></tr>
<tr class="separator:ga1eb2ac508bc7cc89a27414852be39391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">blaze::CTransExprTrait_</a> = typename <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html">CTransExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template.The CTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">More...</a><br /></td></tr>
<tr class="separator:ga5faf6f7664cf7c2827db00ef19fe0b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4770bac8581804b7523ba6797d7e5719"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4770bac8581804b7523ba6797d7e5719"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4770bac8581804b7523ba6797d7e5719">blaze::DeclDiagExprTrait_</a> = typename <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html">DeclDiagExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4770bac8581804b7523ba6797d7e5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template.The DeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4770bac8581804b7523ba6797d7e5719">More...</a><br /></td></tr>
<tr class="separator:ga4770bac8581804b7523ba6797d7e5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045d76a59d7eb529827ba5822df99c40"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga045d76a59d7eb529827ba5822df99c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga045d76a59d7eb529827ba5822df99c40">blaze::DeclDiagTrait_</a> = typename <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html">DeclDiagTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga045d76a59d7eb529827ba5822df99c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html" title="Base template for the DeclDiagTrait class. ">DeclDiagTrait</a> type trait.The DeclDiagTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html" title="Base template for the DeclDiagTrait class. ">DeclDiagTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga045d76a59d7eb529827ba5822df99c40">More...</a><br /></td></tr>
<tr class="separator:ga045d76a59d7eb529827ba5822df99c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga5a0258d9003acc1088542228f3b2ab7e">blaze::DeclHermExprTrait_</a> = typename <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html">DeclHermExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga5a0258d9003acc1088542228f3b2ab7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template.The DeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga5a0258d9003acc1088542228f3b2ab7e">More...</a><br /></td></tr>
<tr class="separator:ga5a0258d9003acc1088542228f3b2ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52937601c4f783810b0207ab39535a27"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga52937601c4f783810b0207ab39535a27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga52937601c4f783810b0207ab39535a27">blaze::DeclHermTrait_</a> = typename <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html">DeclHermTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga52937601c4f783810b0207ab39535a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html" title="Base template for the DeclHermTrait class. ">DeclHermTrait</a> type trait.The DeclHermTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html" title="Base template for the DeclHermTrait class. ">DeclHermTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga52937601c4f783810b0207ab39535a27">More...</a><br /></td></tr>
<tr class="separator:ga52937601c4f783810b0207ab39535a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4649d74be857fd352c298becbc7ebb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab4649d74be857fd352c298becbc7ebb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gab4649d74be857fd352c298becbc7ebb4">blaze::DeclIdExprTrait_</a> = typename <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html">DeclIdExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gab4649d74be857fd352c298becbc7ebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html" title="Evaluation of the return type of an identity declaration (declid) expression.Via this type trait it i...">DeclIdExprTrait</a> class template.The DeclIdExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html" title="Evaluation of the return type of an identity declaration (declid) expression.Via this type trait it i...">DeclIdExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gab4649d74be857fd352c298becbc7ebb4">More...</a><br /></td></tr>
<tr class="separator:gab4649d74be857fd352c298becbc7ebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857f13cbf111c72cdc5db62648fc977b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga857f13cbf111c72cdc5db62648fc977b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga857f13cbf111c72cdc5db62648fc977b">blaze::DeclIdTrait_</a> = typename <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html">DeclIdTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga857f13cbf111c72cdc5db62648fc977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html" title="Base template for the DeclIdTrait class. ">DeclIdTrait</a> type trait.The DeclIdTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html" title="Base template for the DeclIdTrait class. ">DeclIdTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga857f13cbf111c72cdc5db62648fc977b">More...</a><br /></td></tr>
<tr class="separator:ga857f13cbf111c72cdc5db62648fc977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga609ba68116aea8bdbf2c6b612c42dd42">blaze::DeclLowExprTrait_</a> = typename <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html">DeclLowExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template.The DeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga609ba68116aea8bdbf2c6b612c42dd42">More...</a><br /></td></tr>
<tr class="separator:ga609ba68116aea8bdbf2c6b612c42dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185c7163ba10a4befb7ab00ce5ba0eb7"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga185c7163ba10a4befb7ab00ce5ba0eb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga185c7163ba10a4befb7ab00ce5ba0eb7">blaze::DeclLowTrait_</a> = typename <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html">DeclLowTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga185c7163ba10a4befb7ab00ce5ba0eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html" title="Base template for the DeclLowTrait class. ">DeclLowTrait</a> type trait.The DeclLowTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html" title="Base template for the DeclLowTrait class. ">DeclLowTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga185c7163ba10a4befb7ab00ce5ba0eb7">More...</a><br /></td></tr>
<tr class="separator:ga185c7163ba10a4befb7ab00ce5ba0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3d2f2754084b33dd5fbbfbdf73d783fd">blaze::DeclSymExprTrait_</a> = typename <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html">DeclSymExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template.The DeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3d2f2754084b33dd5fbbfbdf73d783fd">More...</a><br /></td></tr>
<tr class="separator:ga3d2f2754084b33dd5fbbfbdf73d783fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a069ba17c304cb07946ce4cf35283ce"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7a069ba17c304cb07946ce4cf35283ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7a069ba17c304cb07946ce4cf35283ce">blaze::DeclSymTrait_</a> = typename <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html">DeclSymTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga7a069ba17c304cb07946ce4cf35283ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html" title="Base template for the DeclSymTrait class. ">DeclSymTrait</a> type trait.The DeclSymTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html" title="Base template for the DeclSymTrait class. ">DeclSymTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7a069ba17c304cb07946ce4cf35283ce">More...</a><br /></td></tr>
<tr class="separator:ga7a069ba17c304cb07946ce4cf35283ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a151739d0d6d857a98ed77a02256bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9a151739d0d6d857a98ed77a02256bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gab9a151739d0d6d857a98ed77a02256bc">blaze::DeclUppExprTrait_</a> = typename <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html">DeclUppExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gab9a151739d0d6d857a98ed77a02256bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template.The DeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gab9a151739d0d6d857a98ed77a02256bc">More...</a><br /></td></tr>
<tr class="separator:gab9a151739d0d6d857a98ed77a02256bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe013f1fa1d9baf1deb72f0a0dbe4c76"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gabe013f1fa1d9baf1deb72f0a0dbe4c76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gabe013f1fa1d9baf1deb72f0a0dbe4c76">blaze::DeclUppTrait_</a> = typename <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html">DeclUppTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:gabe013f1fa1d9baf1deb72f0a0dbe4c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html" title="Base template for the DeclUppTrait class. ">DeclUppTrait</a> type trait.The DeclUppTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html" title="Base template for the DeclUppTrait class. ">DeclUppTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gabe013f1fa1d9baf1deb72f0a0dbe4c76">More...</a><br /></td></tr>
<tr class="separator:gabe013f1fa1d9baf1deb72f0a0dbe4c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga08891a64ab248d7865e4e06a9c7978e5">blaze::DerestrictTrait_</a> = typename <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html">DerestrictTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga08891a64ab248d7865e4e06a9c7978e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> type trait.The DerestrictTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga08891a64ab248d7865e4e06a9c7978e5">More...</a><br /></td></tr>
<tr class="separator:ga08891a64ab248d7865e4e06a9c7978e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">blaze::DivExprTrait_</a> = typename <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">DivExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template.The DivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">More...</a><br /></td></tr>
<tr class="separator:ga0ea0d1ac87097ec85286eb4c87c5011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9930015ba302dafe10a7fde170d597"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d9930015ba302dafe10a7fde170d597"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9d9930015ba302dafe10a7fde170d597">blaze::DivTrait_</a> = typename <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">DivTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga9d9930015ba302dafe10a7fde170d597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.The DivTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9d9930015ba302dafe10a7fde170d597">More...</a><br /></td></tr>
<tr class="separator:ga9d9930015ba302dafe10a7fde170d597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7d0e4cfa0e7313a34089a04d24b0411f">blaze::EvalExprTrait_</a> = typename <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html">EvalExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template.The EvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7d0e4cfa0e7313a34089a04d24b0411f">More...</a><br /></td></tr>
<tr class="separator:ga7d0e4cfa0e7313a34089a04d24b0411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga4a679b1673372cf8cf5a9eec83fa2642">blaze::ImagTrait_</a> = typename <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html">ImagTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template.The ImagTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga4a679b1673372cf8cf5a9eec83fa2642">More...</a><br /></td></tr>
<tr class="separator:ga4a679b1673372cf8cf5a9eec83fa2642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac9ba0283695fcacf41ccca9e1d7913a3">blaze::InvExprTrait_</a> = typename <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html">InvExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template.The InvExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac9ba0283695fcacf41ccca9e1d7913a3">More...</a><br /></td></tr>
<tr class="separator:gac9ba0283695fcacf41ccca9e1d7913a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec740e235d29a5e1421fd282593f6de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafec740e235d29a5e1421fd282593f6de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">blaze::MultExprTrait_</a> = typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gafec740e235d29a5e1421fd282593f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template.The MultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">More...</a><br /></td></tr>
<tr class="separator:gafec740e235d29a5e1421fd282593f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1236c0bfa656036b8a0224726100c008"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1236c0bfa656036b8a0224726100c008"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">blaze::MultTrait_</a> = typename <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga1236c0bfa656036b8a0224726100c008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.The MultTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">More...</a><br /></td></tr>
<tr class="separator:ga1236c0bfa656036b8a0224726100c008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae099d42e4a8c3bb4a0764c876c010813"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae099d42e4a8c3bb4a0764c876c010813"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae099d42e4a8c3bb4a0764c876c010813">blaze::RealTrait_</a> = typename <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html">RealTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gae099d42e4a8c3bb4a0764c876c010813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template.The RealTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae099d42e4a8c3bb4a0764c876c010813">More...</a><br /></td></tr>
<tr class="separator:gae099d42e4a8c3bb4a0764c876c010813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614ee434bf313751eaa652afefd61c46"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga614ee434bf313751eaa652afefd61c46"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">blaze::RowExprTrait_</a> = typename <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html">RowExprTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga614ee434bf313751eaa652afefd61c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> type trait.The RowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">More...</a><br /></td></tr>
<tr class="separator:ga614ee434bf313751eaa652afefd61c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488ff780f372a1c75e230257820d15c2"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga488ff780f372a1c75e230257820d15c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga488ff780f372a1c75e230257820d15c2">blaze::RowTrait_</a> = typename <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">RowTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga488ff780f372a1c75e230257820d15c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> type trait.The RowTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga488ff780f372a1c75e230257820d15c2">More...</a><br /></td></tr>
<tr class="separator:ga488ff780f372a1c75e230257820d15c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac920503d96a08186544fbad5968584d0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac920503d96a08186544fbad5968584d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gac920503d96a08186544fbad5968584d0">blaze::SchurExprTrait_</a> = typename <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html">SchurExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gac920503d96a08186544fbad5968584d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html" title="Evaluation of the return type of an Schur product expression.Via this type trait it is possible to ev...">SchurExprTrait</a> class template.The SchurExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html" title="Evaluation of the return type of an Schur product expression.Via this type trait it is possible to ev...">SchurExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gac920503d96a08186544fbad5968584d0">More...</a><br /></td></tr>
<tr class="separator:gac920503d96a08186544fbad5968584d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7871ed72b0942463d379f373cc82a2fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7871ed72b0942463d379f373cc82a2fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7871ed72b0942463d379f373cc82a2fa">blaze::SchurTrait_</a> = typename <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html">SchurTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga7871ed72b0942463d379f373cc82a2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html" title="Base template for the SchurTrait class. ">SchurTrait</a> class template.The SchurTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html" title="Base template for the SchurTrait class. ">SchurTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7871ed72b0942463d379f373cc82a2fa">More...</a><br /></td></tr>
<tr class="separator:ga7871ed72b0942463d379f373cc82a2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga2733a1b59d0d852447f25dabcbf181c0">blaze::SerialExprTrait_</a> = typename <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html">SerialExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga2733a1b59d0d852447f25dabcbf181c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template.The SerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga2733a1b59d0d852447f25dabcbf181c0">More...</a><br /></td></tr>
<tr class="separator:ga2733a1b59d0d852447f25dabcbf181c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">blaze::SubExprTrait_</a> = typename <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">SubExprTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:gae9375f8308fc6db4d92f3aea659d02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template.The SubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">More...</a><br /></td></tr>
<tr class="separator:gae9375f8308fc6db4d92f3aea659d02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool AF&gt; </td></tr>
<tr class="memitem:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">blaze::SubmatrixExprTrait_</a> = typename <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html">SubmatrixExprTrait</a>&lt; MT, AF &gt;::Type</td></tr>
<tr class="memdesc:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> type trait.The SubmatrixExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> class template. For instance, given the matrix type <em>MT</em> and the alignment flag <em>AF</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">More...</a><br /></td></tr>
<tr class="separator:ga3fc4a18930642ac1da2025b6b31e0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga7dbad8079bcef022b18f2988da0d7beb">blaze::SubmatrixTrait_</a> = typename <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a>&lt; MT &gt;::Type</td></tr>
<tr class="memdesc:ga7dbad8079bcef022b18f2988da0d7beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> type trait.The SubmatrixTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga7dbad8079bcef022b18f2988da0d7beb">More...</a><br /></td></tr>
<tr class="separator:ga7dbad8079bcef022b18f2988da0d7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga49f2e308fdf9e6148a1fa373cd7605d8">blaze::SubTrait_</a> = typename <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">SubTrait</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.The SubTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga49f2e308fdf9e6148a1fa373cd7605d8">More...</a><br /></td></tr>
<tr class="separator:ga49f2e308fdf9e6148a1fa373cd7605d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabb36a96e9d948974930ead876b6dfa"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF&gt; </td></tr>
<tr class="memitem:gafabb36a96e9d948974930ead876b6dfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">blaze::SubvectorExprTrait_</a> = typename <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html">SubvectorExprTrait</a>&lt; VT, AF &gt;::Type</td></tr>
<tr class="memdesc:gafabb36a96e9d948974930ead876b6dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> type trait.The SubvectorExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">More...</a><br /></td></tr>
<tr class="separator:gafabb36a96e9d948974930ead876b6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga305e56571fa64ea7dc4a0f513c7f42c8">blaze::SubvectorTrait_</a> = typename <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a>&lt; VT &gt;::Type</td></tr>
<tr class="memdesc:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> type trait.The SubvectorTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga305e56571fa64ea7dc4a0f513c7f42c8">More...</a><br /></td></tr>
<tr class="separator:ga305e56571fa64ea7dc4a0f513c7f42c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#gad0abaf03cc33775ce5bb24173eae3c84">blaze::TransExprTrait_</a> = typename <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html">TransExprTrait</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gad0abaf03cc33775ce5bb24173eae3c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template.The TransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#gad0abaf03cc33775ce5bb24173eae3c84">More...</a><br /></td></tr>
<tr class="separator:gad0abaf03cc33775ce5bb24173eae3c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e75fa936f261139162560711ab4ead1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:ga1e75fa936f261139162560711ab4ead1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga1e75fa936f261139162560711ab4ead1">blaze::UnaryMapExprTrait_</a> = typename <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html">UnaryMapExprTrait</a>&lt; T, OP &gt;::Type</td></tr>
<tr class="memdesc:ga1e75fa936f261139162560711ab4ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html" title="Evaluation of the return type of a unary map expression.Via this type trait it is possible to evaluat...">UnaryMapExprTrait</a> class template.The UnaryMapExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html" title="Evaluation of the return type of a unary map expression.Via this type trait it is possible to evaluat...">UnaryMapExprTrait</a> class template. For instance, given the data type <em>T</em> and custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga1e75fa936f261139162560711ab4ead1">More...</a><br /></td></tr>
<tr class="separator:ga1e75fa936f261139162560711ab4ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9faea3d0356bf8b79775a8735087fd51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr class="memitem:ga9faea3d0356bf8b79775a8735087fd51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html#ga9faea3d0356bf8b79775a8735087fd51">blaze::UnaryMapTrait_</a> = typename <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html">UnaryMapTrait</a>&lt; T, OP &gt;::Type</td></tr>
<tr class="memdesc:ga9faea3d0356bf8b79775a8735087fd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html" title="Base template for the UnaryMapTrait class. ">UnaryMapTrait</a> class template.The UnaryMapTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html" title="Base template for the UnaryMapTrait class. ">UnaryMapTrait</a> class template. For instance, given the type <em>T</em> and the custom operation type <em>OP</em> the following two type definitions are identical:  <a href="../../d8/d92/group__math__traits.html#ga9faea3d0356bf8b79775a8735087fd51">More...</a><br /></td></tr>
<tr class="separator:ga9faea3d0356bf8b79775a8735087fd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa8e44a329b04c220d865a66e33ebd605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8e44a329b04c220d865a66e33ebd605">&#9670;&nbsp;</a></span>AddExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gaa8e44a329b04c220d865a66e33ebd605">blaze::AddExprTrait_</a> = typedef typename <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">AddExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template.The AddExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html" title="Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluat...">AddExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga719d2bf697506ad8e36243d837d72c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga719d2bf697506ad8e36243d837d72c0c">&#9670;&nbsp;</a></span>AddTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga719d2bf697506ad8e36243d837d72c0c">blaze::AddTrait_</a> = typedef typename <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">AddTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.The AddTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac9193c05a040482279b6ab5ec9053011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9193c05a040482279b6ab5ec9053011">&#9670;&nbsp;</a></span>BinaryMapExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gac9193c05a040482279b6ab5ec9053011">blaze::BinaryMapExprTrait_</a> = typedef typename <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html">BinaryMapExprTrait</a>&lt;T1,T2,OP&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html" title="Evaluation of the return type of a binary map expression.Via this type trait it is possible to evalua...">BinaryMapExprTrait</a> class template.The BinaryMapExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d68/structblaze_1_1BinaryMapExprTrait.html" title="Evaluation of the return type of a binary map expression.Via this type trait it is possible to evalua...">BinaryMapExprTrait</a> class template. For instance, given the data types <em>T1</em> and and <em>T2</em> and the custom operation type <em>OP</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> BinaryMapExprTrait&lt;T1,T2,OP&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = BinaryMapExprTrait_&lt;T1,T2,OP&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1fa4fd93fe21f3d88f1e0eab21519a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa4fd93fe21f3d88f1e0eab21519a2a">&#9670;&nbsp;</a></span>BinaryMapTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga1fa4fd93fe21f3d88f1e0eab21519a2a">blaze::BinaryMapTrait_</a> = typedef typename <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html">BinaryMapTrait</a>&lt;T1,T2,OP&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html" title="Base template for the BinaryMapTrait class. ">BinaryMapTrait</a> class template.The BinaryMapTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d0b/structblaze_1_1BinaryMapTrait.html" title="Base template for the BinaryMapTrait class. ">BinaryMapTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> and the custom operation type <em>OP</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> BinaryMapTrait&lt;T1,T2,OP&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = BinaryMapTrait_&lt;T1,T2,OP&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3507cda05675a7d310b22f91dce0059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3507cda05675a7d310b22f91dce0059a">&#9670;&nbsp;</a></span>ColumnExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga3507cda05675a7d310b22f91dce0059a">blaze::ColumnExprTrait_</a> = typedef typename <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html">ColumnExprTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> type trait.The ColumnExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d61/structblaze_1_1ColumnExprTrait.html" title="Evaluation of the expression type type of a column operation.Via this type trait it is possible to ev...">ColumnExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> ColumnExprTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = ColumnExprTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaeaffe2e5a832863701a9bfdccc7402aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaffe2e5a832863701a9bfdccc7402aa">&#9670;&nbsp;</a></span>ColumnTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gaeaffe2e5a832863701a9bfdccc7402aa">blaze::ColumnTrait_</a> = typedef typename <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">ColumnTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> type trait.The ColumnTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> ColumnTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = ColumnTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1fa52bdff3e1372cc0d2c43432ba44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fa52bdff3e1372cc0d2c43432ba44e4">&#9670;&nbsp;</a></span>CrossExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga1fa52bdff3e1372cc0d2c43432ba44e4">blaze::CrossExprTrait_</a> = typedef typename <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">CrossExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template.The CrossExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html" title="Evaluation of the return type of a cross product expression.Via this type trait it is possible to eva...">CrossExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> CrossExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = CrossExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1eb2ac508bc7cc89a27414852be39391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eb2ac508bc7cc89a27414852be39391">&#9670;&nbsp;</a></span>CrossTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga1eb2ac508bc7cc89a27414852be39391">blaze::CrossTrait_</a> = typedef typename <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">CrossTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.The CrossTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> CrossTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = CrossTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5faf6f7664cf7c2827db00ef19fe0b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5faf6f7664cf7c2827db00ef19fe0b8b">&#9670;&nbsp;</a></span>CTransExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga5faf6f7664cf7c2827db00ef19fe0b8b">blaze::CTransExprTrait_</a> = typedef typename <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html">CTransExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template.The CTransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d23/structblaze_1_1CTransExprTrait.html" title="Evaluation of the return type of a conjugate transpose expression.Via this type trait it is possible ...">CTransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> CTransExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = CTransExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4770bac8581804b7523ba6797d7e5719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4770bac8581804b7523ba6797d7e5719">&#9670;&nbsp;</a></span>DeclDiagExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga4770bac8581804b7523ba6797d7e5719">blaze::DeclDiagExprTrait_</a> = typedef typename <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html">DeclDiagExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template.The DeclDiagExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d5f/structblaze_1_1DeclDiagExprTrait.html" title="Evaluation of the return type of a diagonal declaration (decldiag) expression.Via this type trait it ...">DeclDiagExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclDiagExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclDiagExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga045d76a59d7eb529827ba5822df99c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga045d76a59d7eb529827ba5822df99c40">&#9670;&nbsp;</a></span>DeclDiagTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga045d76a59d7eb529827ba5822df99c40">blaze::DeclDiagTrait_</a> = typedef typename <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html">DeclDiagTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html" title="Base template for the DeclDiagTrait class. ">DeclDiagTrait</a> type trait.The DeclDiagTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d96/structblaze_1_1DeclDiagTrait.html" title="Base template for the DeclDiagTrait class. ">DeclDiagTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclDiagTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclDiagTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5a0258d9003acc1088542228f3b2ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0258d9003acc1088542228f3b2ab7e">&#9670;&nbsp;</a></span>DeclHermExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga5a0258d9003acc1088542228f3b2ab7e">blaze::DeclHermExprTrait_</a> = typedef typename <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html">DeclHermExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template.The DeclHermExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d38/structblaze_1_1DeclHermExprTrait.html" title="Evaluation of the return type of an Hermitian declaration (declherm) expression.Via this type trait i...">DeclHermExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclHermExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclHermExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga52937601c4f783810b0207ab39535a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52937601c4f783810b0207ab39535a27">&#9670;&nbsp;</a></span>DeclHermTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga52937601c4f783810b0207ab39535a27">blaze::DeclHermTrait_</a> = typedef typename <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html">DeclHermTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html" title="Base template for the DeclHermTrait class. ">DeclHermTrait</a> type trait.The DeclHermTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dfd/structblaze_1_1DeclHermTrait.html" title="Base template for the DeclHermTrait class. ">DeclHermTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclHermTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclHermTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gab4649d74be857fd352c298becbc7ebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4649d74be857fd352c298becbc7ebb4">&#9670;&nbsp;</a></span>DeclIdExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gab4649d74be857fd352c298becbc7ebb4">blaze::DeclIdExprTrait_</a> = typedef typename <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html">DeclIdExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html" title="Evaluation of the return type of an identity declaration (declid) expression.Via this type trait it i...">DeclIdExprTrait</a> class template.The DeclIdExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d04/structblaze_1_1DeclIdExprTrait.html" title="Evaluation of the return type of an identity declaration (declid) expression.Via this type trait it i...">DeclIdExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclIdExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclIdExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga857f13cbf111c72cdc5db62648fc977b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857f13cbf111c72cdc5db62648fc977b">&#9670;&nbsp;</a></span>DeclIdTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga857f13cbf111c72cdc5db62648fc977b">blaze::DeclIdTrait_</a> = typedef typename <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html">DeclIdTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html" title="Base template for the DeclIdTrait class. ">DeclIdTrait</a> type trait.The DeclIdTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d77/structblaze_1_1DeclIdTrait.html" title="Base template for the DeclIdTrait class. ">DeclIdTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclIdTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclIdTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga609ba68116aea8bdbf2c6b612c42dd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609ba68116aea8bdbf2c6b612c42dd42">&#9670;&nbsp;</a></span>DeclLowExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga609ba68116aea8bdbf2c6b612c42dd42">blaze::DeclLowExprTrait_</a> = typedef typename <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html">DeclLowExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template.The DeclLowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d74/structblaze_1_1DeclLowExprTrait.html" title="Evaluation of the return type of a lower declaration (decllow) expression.Via this type trait it is p...">DeclLowExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclLowExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclLowExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga185c7163ba10a4befb7ab00ce5ba0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185c7163ba10a4befb7ab00ce5ba0eb7">&#9670;&nbsp;</a></span>DeclLowTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga185c7163ba10a4befb7ab00ce5ba0eb7">blaze::DeclLowTrait_</a> = typedef typename <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html">DeclLowTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html" title="Base template for the DeclLowTrait class. ">DeclLowTrait</a> type trait.The DeclLowTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df4/structblaze_1_1DeclLowTrait.html" title="Base template for the DeclLowTrait class. ">DeclLowTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclLowTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclLowTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d2f2754084b33dd5fbbfbdf73d783fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2f2754084b33dd5fbbfbdf73d783fd">&#9670;&nbsp;</a></span>DeclSymExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga3d2f2754084b33dd5fbbfbdf73d783fd">blaze::DeclSymExprTrait_</a> = typedef typename <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html">DeclSymExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template.The DeclSymExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/db6/structblaze_1_1DeclSymExprTrait.html" title="Evaluation of the return type of a symmetry declaration (declsym) expression.Via this type trait it i...">DeclSymExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclSymExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclSymExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7a069ba17c304cb07946ce4cf35283ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a069ba17c304cb07946ce4cf35283ce">&#9670;&nbsp;</a></span>DeclSymTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga7a069ba17c304cb07946ce4cf35283ce">blaze::DeclSymTrait_</a> = typedef typename <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html">DeclSymTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html" title="Base template for the DeclSymTrait class. ">DeclSymTrait</a> type trait.The DeclSymTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d7f/structblaze_1_1DeclSymTrait.html" title="Base template for the DeclSymTrait class. ">DeclSymTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclSymTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclSymTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gab9a151739d0d6d857a98ed77a02256bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a151739d0d6d857a98ed77a02256bc">&#9670;&nbsp;</a></span>DeclUppExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gab9a151739d0d6d857a98ed77a02256bc">blaze::DeclUppExprTrait_</a> = typedef typename <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html">DeclUppExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template.The DeclUppExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d1f/structblaze_1_1DeclUppExprTrait.html" title="Evaluation of the return type of a upper declaration (declupp) expression.Via this type trait it is p...">DeclUppExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclUppExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclUppExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gabe013f1fa1d9baf1deb72f0a0dbe4c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe013f1fa1d9baf1deb72f0a0dbe4c76">&#9670;&nbsp;</a></span>DeclUppTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gabe013f1fa1d9baf1deb72f0a0dbe4c76">blaze::DeclUppTrait_</a> = typedef typename <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html">DeclUppTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html" title="Base template for the DeclUppTrait class. ">DeclUppTrait</a> type trait.The DeclUppTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/dfa/structblaze_1_1DeclUppTrait.html" title="Base template for the DeclUppTrait class. ">DeclUppTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DeclUppTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DeclUppTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08891a64ab248d7865e4e06a9c7978e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08891a64ab248d7865e4e06a9c7978e5">&#9670;&nbsp;</a></span>DerestrictTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga08891a64ab248d7865e4e06a9c7978e5">blaze::DerestrictTrait_</a> = typedef typename <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html">DerestrictTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> type trait.The DerestrictTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc1/structblaze_1_1DerestrictTrait.html" title="Evaluation of the return type of the derestrict function.Via this type trait it is possible to evalua...">DerestrictTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DerestrictTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DerestrictTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0ea0d1ac87097ec85286eb4c87c5011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea0d1ac87097ec85286eb4c87c5011d">&#9670;&nbsp;</a></span>DivExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga0ea0d1ac87097ec85286eb4c87c5011d">blaze::DivExprTrait_</a> = typedef typename <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">DivExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template.The DivExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html" title="Evaluation of the resulting expression type of a division.Via this type trait it is possible to evalu...">DivExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DivExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DivExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9d9930015ba302dafe10a7fde170d597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9930015ba302dafe10a7fde170d597">&#9670;&nbsp;</a></span>DivTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga9d9930015ba302dafe10a7fde170d597">blaze::DivTrait_</a> = typedef typename <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">DivTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.The DivTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DivTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DivTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7d0e4cfa0e7313a34089a04d24b0411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d0e4cfa0e7313a34089a04d24b0411f">&#9670;&nbsp;</a></span>EvalExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga7d0e4cfa0e7313a34089a04d24b0411f">blaze::EvalExprTrait_</a> = typedef typename <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html">EvalExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template.The EvalExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dc7/structblaze_1_1EvalExprTrait.html" title="Evaluation of the return type of an evaluation expression.Via this type trait it is possible to evalu...">EvalExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> EvalExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = EvalExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4a679b1673372cf8cf5a9eec83fa2642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a679b1673372cf8cf5a9eec83fa2642">&#9670;&nbsp;</a></span>ImagTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga4a679b1673372cf8cf5a9eec83fa2642">blaze::ImagTrait_</a> = typedef typename <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html">ImagTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template.The ImagTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d0b/structblaze_1_1ImagTrait.html" title="Base template for the ImagTrait class.The ImagTrait class template offers the possibility to select t...">ImagTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> ImagTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = ImagTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac9ba0283695fcacf41ccca9e1d7913a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ba0283695fcacf41ccca9e1d7913a3">&#9670;&nbsp;</a></span>InvExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gac9ba0283695fcacf41ccca9e1d7913a3">blaze::InvExprTrait_</a> = typedef typename <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html">InvExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template.The InvExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d78/structblaze_1_1InvExprTrait.html" title="Evaluation of the return type of an inversion expression.Via this type trait it is possible to evalua...">InvExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> InvExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = InvExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gafec740e235d29a5e1421fd282593f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec740e235d29a5e1421fd282593f6de">&#9670;&nbsp;</a></span>MultExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gafec740e235d29a5e1421fd282593f6de">blaze::MultExprTrait_</a> = typedef typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template.The MultExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html" title="Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to...">MultExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MultExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MultExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1236c0bfa656036b8a0224726100c008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1236c0bfa656036b8a0224726100c008">&#9670;&nbsp;</a></span>MultTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga1236c0bfa656036b8a0224726100c008">blaze::MultTrait_</a> = typedef typename <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.The MultTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MultTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MultTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae099d42e4a8c3bb4a0764c876c010813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae099d42e4a8c3bb4a0764c876c010813">&#9670;&nbsp;</a></span>RealTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gae099d42e4a8c3bb4a0764c876c010813">blaze::RealTrait_</a> = typedef typename <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html">RealTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template.The RealTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d50/structblaze_1_1RealTrait.html" title="Base template for the RealTrait class.The RealTrait class template offers the possibility to select t...">RealTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RealTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RealTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga614ee434bf313751eaa652afefd61c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614ee434bf313751eaa652afefd61c46">&#9670;&nbsp;</a></span>RowExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga614ee434bf313751eaa652afefd61c46">blaze::RowExprTrait_</a> = typedef typename <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html">RowExprTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> type trait.The RowExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d25/structblaze_1_1RowExprTrait.html" title="Evaluation of the expression type type of a row operation.Via this type trait it is possible to evalu...">RowExprTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RowExprTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RowExprTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga488ff780f372a1c75e230257820d15c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488ff780f372a1c75e230257820d15c2">&#9670;&nbsp;</a></span>RowTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga488ff780f372a1c75e230257820d15c2">blaze::RowTrait_</a> = typedef typename <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">RowTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> type trait.The RowTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RowTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RowTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac920503d96a08186544fbad5968584d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac920503d96a08186544fbad5968584d0">&#9670;&nbsp;</a></span>SchurExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gac920503d96a08186544fbad5968584d0">blaze::SchurExprTrait_</a> = typedef typename <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html">SchurExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html" title="Evaluation of the return type of an Schur product expression.Via this type trait it is possible to ev...">SchurExprTrait</a> class template.The SchurExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d3/d95/structblaze_1_1SchurExprTrait.html" title="Evaluation of the return type of an Schur product expression.Via this type trait it is possible to ev...">SchurExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SchurExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SchurExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7871ed72b0942463d379f373cc82a2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7871ed72b0942463d379f373cc82a2fa">&#9670;&nbsp;</a></span>SchurTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga7871ed72b0942463d379f373cc82a2fa">blaze::SchurTrait_</a> = typedef typename <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html">SchurTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html" title="Base template for the SchurTrait class. ">SchurTrait</a> class template.The SchurTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/daf/structblaze_1_1SchurTrait.html" title="Base template for the SchurTrait class. ">SchurTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SchurTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SchurTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2733a1b59d0d852447f25dabcbf181c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2733a1b59d0d852447f25dabcbf181c0">&#9670;&nbsp;</a></span>SerialExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga2733a1b59d0d852447f25dabcbf181c0">blaze::SerialExprTrait_</a> = typedef typename <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html">SerialExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template.The SerialExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/de8/structblaze_1_1SerialExprTrait.html" title="Evaluation of the return type of a serial evaluation expression.Via this type trait it is possible to...">SerialExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SerialExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SerialExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gae9375f8308fc6db4d92f3aea659d02cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9375f8308fc6db4d92f3aea659d02cd">&#9670;&nbsp;</a></span>SubExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gae9375f8308fc6db4d92f3aea659d02cd">blaze::SubExprTrait_</a> = typedef typename <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">SubExprTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template.The SubExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html" title="Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evalu...">SubExprTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubExprTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubExprTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3fc4a18930642ac1da2025b6b31e0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fc4a18930642ac1da2025b6b31e0a19">&#9670;&nbsp;</a></span>SubmatrixExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga3fc4a18930642ac1da2025b6b31e0a19">blaze::SubmatrixExprTrait_</a> = typedef typename <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html">SubmatrixExprTrait</a>&lt;MT,AF&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> type trait.The SubmatrixExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d6d/structblaze_1_1SubmatrixExprTrait.html" title="Evaluation of the expression type type of a submatrix operation.Via this type trait it is possible to...">SubmatrixExprTrait</a> class template. For instance, given the matrix type <em>MT</em> and the alignment flag <em>AF</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubmatrixExprTrait&lt;MT,AF&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubmatrixExprTrait_&lt;MT,AF&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7dbad8079bcef022b18f2988da0d7beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dbad8079bcef022b18f2988da0d7beb">&#9670;&nbsp;</a></span>SubmatrixTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga7dbad8079bcef022b18f2988da0d7beb">blaze::SubmatrixTrait_</a> = typedef typename <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a>&lt;MT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> type trait.The SubmatrixTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class template. For instance, given the matrix type <em>MT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubmatrixTrait&lt;MT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubmatrixTrait_&lt;MT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga49f2e308fdf9e6148a1fa373cd7605d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f2e308fdf9e6148a1fa373cd7605d8">&#9670;&nbsp;</a></span>SubTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga49f2e308fdf9e6148a1fa373cd7605d8">blaze::SubTrait_</a> = typedef typename <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">SubTrait</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.The SubTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubTrait&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubTrait_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gafabb36a96e9d948974930ead876b6dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafabb36a96e9d948974930ead876b6dfa">&#9670;&nbsp;</a></span>SubvectorExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gafabb36a96e9d948974930ead876b6dfa">blaze::SubvectorExprTrait_</a> = typedef typename <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html">SubvectorExprTrait</a>&lt;VT,AF&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> type trait.The SubvectorExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df0/structblaze_1_1SubvectorExprTrait.html" title="Evaluation of the expression type type of a subvector operation.Via this type trait it is possible to...">SubvectorExprTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubvectorExprTrait&lt;VT,AF&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubvectorExprTrait_&lt;VT,AF&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga305e56571fa64ea7dc4a0f513c7f42c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305e56571fa64ea7dc4a0f513c7f42c8">&#9670;&nbsp;</a></span>SubvectorTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga305e56571fa64ea7dc4a0f513c7f42c8">blaze::SubvectorTrait_</a> = typedef typename <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a>&lt;VT&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> type trait.The SubvectorTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class template. For instance, given the vector type <em>VT</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> SubvectorTrait&lt;VT&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = SubvectorTrait_&lt;VT&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad0abaf03cc33775ce5bb24173eae3c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0abaf03cc33775ce5bb24173eae3c84">&#9670;&nbsp;</a></span>TransExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#gad0abaf03cc33775ce5bb24173eae3c84">blaze::TransExprTrait_</a> = typedef typename <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html">TransExprTrait</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template.The TransExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d1/d9a/structblaze_1_1TransExprTrait.html" title="Evaluation of the return type of a transpose expression.Via this type trait it is possible to evaluat...">TransExprTrait</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> TransExprTrait&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = TransExprTrait_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1e75fa936f261139162560711ab4ead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e75fa936f261139162560711ab4ead1">&#9670;&nbsp;</a></span>UnaryMapExprTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga1e75fa936f261139162560711ab4ead1">blaze::UnaryMapExprTrait_</a> = typedef typename <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html">UnaryMapExprTrait</a>&lt;T,OP&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html" title="Evaluation of the return type of a unary map expression.Via this type trait it is possible to evaluat...">UnaryMapExprTrait</a> class template.The UnaryMapExprTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/df5/structblaze_1_1UnaryMapExprTrait.html" title="Evaluation of the return type of a unary map expression.Via this type trait it is possible to evaluat...">UnaryMapExprTrait</a> class template. For instance, given the data type <em>T</em> and custom operation type <em>OP</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnaryMapExprTrait&lt;T,OP&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnaryMapExprTrait_&lt;T,OP&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9faea3d0356bf8b79775a8735087fd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9faea3d0356bf8b79775a8735087fd51">&#9670;&nbsp;</a></span>UnaryMapTrait_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d92/group__math__traits.html#ga9faea3d0356bf8b79775a8735087fd51">blaze::UnaryMapTrait_</a> = typedef typename <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html">UnaryMapTrait</a>&lt;T,OP&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html" title="Base template for the UnaryMapTrait class. ">UnaryMapTrait</a> class template.The UnaryMapTrait_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d8/d6f/structblaze_1_1UnaryMapTrait.html" title="Base template for the UnaryMapTrait class. ">UnaryMapTrait</a> class template. For instance, given the type <em>T</em> and the custom operation type <em>OP</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnaryMapTrait&lt;T,OP&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnaryMapTrait_&lt;T,OP&gt;;</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:24 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
