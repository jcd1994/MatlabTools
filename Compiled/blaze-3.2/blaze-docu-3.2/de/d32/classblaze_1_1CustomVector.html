<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::CustomVector&lt; Type, AF, PF, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d4/d2e/classblaze_1_1CustomVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::CustomVector&lt; Type, AF, PF, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a> &raquo; <a class="el" href="../../de/d90/group__dense__vector.html">Dense Vectors</a> &raquo; <a class="el" href="../../d5/d32/group__custom__vector.html">CustomVector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a customizable vector.  
 <a href="../../de/d32/classblaze_1_1CustomVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/db3/dense_2CustomVector_8h_source.html">CustomVector.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; CustomVector&lt; Type, AF, PF, TF &gt;, TF &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dee/structblaze_1_1CustomVector_1_1Rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/dee/structblaze_1_1CustomVector_1_1Rebind.html" title="Rebind mechanism to obtain a CustomVector with different data/element type. ">Rebind</a> mechanism to obtain a <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> with different data/element type.  <a href="../../d9/dee/structblaze_1_1CustomVector_1_1Rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6c/structblaze_1_1CustomVector_1_1Resize.html">Resize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d6c/structblaze_1_1CustomVector_1_1Resize.html" title="Resize mechanism to obtain a CustomVector with a different fixed number of elements. ">Resize</a> mechanism to obtain a <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> with a different fixed number of elements.  <a href="../../da/d6c/structblaze_1_1CustomVector_1_1Resize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a38a9985b1e8b49d770d13c7ea9fb5844"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>simdEnabled</b> = IsVectorizable&lt;Type&gt;::value
 }<tr class="memdesc:a38a9985b1e8b49d770d13c7ea9fb5844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SIMD optimization.  <a href="../../de/d32/classblaze_1_1CustomVector.html#a38a9985b1e8b49d770d13c7ea9fb5844">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a38a9985b1e8b49d770d13c7ea9fb5844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945ebf68a7ca85907c343bfaa34665d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = !IsSMPAssignable&lt;Type&gt;::value
 }<tr class="memdesc:a7945ebf68a7ca85907c343bfaa34665d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../de/d32/classblaze_1_1CustomVector.html#a7945ebf68a7ca85907c343bfaa34665d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7945ebf68a7ca85907c343bfaa34665d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0386452000026b533b2d7294542d190"><td class="memItemLeft" align="right" valign="top"><a id="ac0386452000026b533b2d7294542d190"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ac0386452000026b533b2d7294542d190">This</a> = <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;</td></tr>
<tr class="memdesc:ac0386452000026b533b2d7294542d190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> instance. <br /></td></tr>
<tr class="separator:ac0386452000026b533b2d7294542d190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6549a12e6736e046448c1ac80f1dd0f6"><td class="memItemLeft" align="right" valign="top"><a id="a6549a12e6736e046448c1ac80f1dd0f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a6549a12e6736e046448c1ac80f1dd0f6">BaseType</a> = <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ac0386452000026b533b2d7294542d190">This</a>, TF &gt;</td></tr>
<tr class="memdesc:a6549a12e6736e046448c1ac80f1dd0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of this <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> instance. <br /></td></tr>
<tr class="separator:a6549a12e6736e046448c1ac80f1dd0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650a75481c9651c53af02f09aa9a97ee"><td class="memItemLeft" align="right" valign="top"><a id="a650a75481c9651c53af02f09aa9a97ee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a650a75481c9651c53af02f09aa9a97ee">ResultType</a> = <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a>&lt; Type &gt;, TF &gt;</td></tr>
<tr class="memdesc:a650a75481c9651c53af02f09aa9a97ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a650a75481c9651c53af02f09aa9a97ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad666c9e46f7928244ad9573f050393"><td class="memItemLeft" align="right" valign="top"><a id="a5ad666c9e46f7928244ad9573f050393"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a5ad666c9e46f7928244ad9573f050393">TransposeType</a> = <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a>&lt; Type &gt;,!TF &gt;</td></tr>
<tr class="memdesc:a5ad666c9e46f7928244ad9573f050393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a5ad666c9e46f7928244ad9573f050393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab102fcf41f23ebe0a78215fd0ebca47"><td class="memItemLeft" align="right" valign="top"><a id="aab102fcf41f23ebe0a78215fd0ebca47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aab102fcf41f23ebe0a78215fd0ebca47">ElementType</a> = Type</td></tr>
<tr class="memdesc:aab102fcf41f23ebe0a78215fd0ebca47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector elements. <br /></td></tr>
<tr class="separator:aab102fcf41f23ebe0a78215fd0ebca47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53900968e11d02f800020b4af2a21cf"><td class="memItemLeft" align="right" valign="top"><a id="af53900968e11d02f800020b4af2a21cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> = <a class="el" href="../../dc/d7b/group__simd.html#ga0b575b0b82167488f51b14b02b664ba2">SIMDTrait_</a>&lt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aab102fcf41f23ebe0a78215fd0ebca47">ElementType</a> &gt;</td></tr>
<tr class="memdesc:af53900968e11d02f800020b4af2a21cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type of the vector elements. <br /></td></tr>
<tr class="separator:af53900968e11d02f800020b4af2a21cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b694824b9d4f3d9f05604a3ad627fda"><td class="memItemLeft" align="right" valign="top"><a id="a6b694824b9d4f3d9f05604a3ad627fda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a6b694824b9d4f3d9f05604a3ad627fda">ReturnType</a> = const Type &amp;</td></tr>
<tr class="memdesc:a6b694824b9d4f3d9f05604a3ad627fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a6b694824b9d4f3d9f05604a3ad627fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2736249b2e0249c017858996f7a433"><td class="memItemLeft" align="right" valign="top"><a id="a1e2736249b2e0249c017858996f7a433"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a1e2736249b2e0249c017858996f7a433">CompositeType</a> = const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;</td></tr>
<tr class="memdesc:a1e2736249b2e0249c017858996f7a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a1e2736249b2e0249c017858996f7a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae248c263531bcc40bed9c1f7863fdd59"><td class="memItemLeft" align="right" valign="top"><a id="ae248c263531bcc40bed9c1f7863fdd59"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae248c263531bcc40bed9c1f7863fdd59">Reference</a> = Type &amp;</td></tr>
<tr class="memdesc:ae248c263531bcc40bed9c1f7863fdd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant vector value. <br /></td></tr>
<tr class="separator:ae248c263531bcc40bed9c1f7863fdd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4d836cf13c1377a92ac9b55f52dc4c"><td class="memItemLeft" align="right" valign="top"><a id="a7c4d836cf13c1377a92ac9b55f52dc4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7c4d836cf13c1377a92ac9b55f52dc4c">ConstReference</a> = const Type &amp;</td></tr>
<tr class="memdesc:a7c4d836cf13c1377a92ac9b55f52dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant vector value. <br /></td></tr>
<tr class="separator:a7c4d836cf13c1377a92ac9b55f52dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa143f79745bd5ea884d4a69a391adce8"><td class="memItemLeft" align="right" valign="top"><a id="aa143f79745bd5ea884d4a69a391adce8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa143f79745bd5ea884d4a69a391adce8">Pointer</a> = Type *</td></tr>
<tr class="memdesc:aa143f79745bd5ea884d4a69a391adce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant vector value. <br /></td></tr>
<tr class="separator:aa143f79745bd5ea884d4a69a391adce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a02c5d89b21a021d1149826465912a"><td class="memItemLeft" align="right" valign="top"><a id="a61a02c5d89b21a021d1149826465912a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a61a02c5d89b21a021d1149826465912a">ConstPointer</a> = const Type *</td></tr>
<tr class="memdesc:a61a02c5d89b21a021d1149826465912a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant vector value. <br /></td></tr>
<tr class="separator:a61a02c5d89b21a021d1149826465912a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445ff043bb703c01844c010a1e544f3c"><td class="memItemLeft" align="right" valign="top"><a id="a445ff043bb703c01844c010a1e544f3c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a445ff043bb703c01844c010a1e544f3c">Iterator</a> = <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt;</td></tr>
<tr class="memdesc:a445ff043bb703c01844c010a1e544f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a445ff043bb703c01844c010a1e544f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33811b0f8b93f182bbd8efeef964c52f"><td class="memItemLeft" align="right" valign="top"><a id="a33811b0f8b93f182bbd8efeef964c52f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a> = <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; const Type, AF &gt;</td></tr>
<tr class="memdesc:a33811b0f8b93f182bbd8efeef964c52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a33811b0f8b93f182bbd8efeef964c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memItemLeft" align="right" valign="top"><a id="a4e76ca32c31f9077cb773fe1cc414a52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> = VT</td></tr>
<tr class="memdesc:a4e76ca32c31f9077cb773fe1cc414a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b416ff2ad5b9c318a3af4f365c32d69"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t N&gt; </td></tr>
<tr class="memitem:a3b416ff2ad5b9c318a3af4f365c32d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3b416ff2ad5b9c318a3af4f365c32d69">operator=</a> (const Other(&amp;array)[N])</td></tr>
<tr class="memdesc:a3b416ff2ad5b9c318a3af4f365c32d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array assignment to all vector elements.  <a href="#a3b416ff2ad5b9c318a3af4f365c32d69">More...</a><br /></td></tr>
<tr class="separator:a3b416ff2ad5b9c318a3af4f365c32d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cbb09d6511b35d76c868604c6f51d6"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad9cbb09d6511b35d76c868604c6f51d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ad9cbb09d6511b35d76c868604c6f51d6">operator=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad9cbb09d6511b35d76c868604c6f51d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different vectors.  <a href="#ad9cbb09d6511b35d76c868604c6f51d6">More...</a><br /></td></tr>
<tr class="separator:ad9cbb09d6511b35d76c868604c6f51d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0569bf252f4f75b1ddccae66d881c140"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a0569bf252f4f75b1ddccae66d881c140"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a0569bf252f4f75b1ddccae66d881c140">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0569bf252f4f75b1ddccae66d881c140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_38.png"/>).  <a href="#a0569bf252f4f75b1ddccae66d881c140">More...</a><br /></td></tr>
<tr class="separator:a0569bf252f4f75b1ddccae66d881c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1724b554f9db254e381df7bedb3b73"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:acd1724b554f9db254e381df7bedb3b73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#acd1724b554f9db254e381df7bedb3b73">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acd1724b554f9db254e381df7bedb3b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_39.png"/>).  <a href="#acd1724b554f9db254e381df7bedb3b73">More...</a><br /></td></tr>
<tr class="separator:acd1724b554f9db254e381df7bedb3b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dbb4da350ef682bcab99bbfb326131"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a27dbb4da350ef682bcab99bbfb326131"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a27dbb4da350ef682bcab99bbfb326131">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a27dbb4da350ef682bcab99bbfb326131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_40.png"/>).  <a href="#a27dbb4da350ef682bcab99bbfb326131">More...</a><br /></td></tr>
<tr class="separator:a27dbb4da350ef682bcab99bbfb326131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae101a6ec8ffd01b13e160bba2385043a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ae101a6ec8ffd01b13e160bba2385043a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae101a6ec8ffd01b13e160bba2385043a">operator/=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae101a6ec8ffd01b13e160bba2385043a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a dense vector ( <img class="formulaInl" alt="$ \vec{a}/=\vec{b} $" src="../../form_41.png"/>).  <a href="#ae101a6ec8ffd01b13e160bba2385043a">More...</a><br /></td></tr>
<tr class="separator:ae101a6ec8ffd01b13e160bba2385043a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320b4c3dc1a2ed4dda4f2c45424bb71"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2320b4c3dc1a2ed4dda4f2c45424bb71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a2320b4c3dc1a2ed4dda4f2c45424bb71">operator%=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2320b4c3dc1a2ed4dda4f2c45424bb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}\times=\vec{b} $" src="../../form_42.png"/>).  <a href="#a2320b4c3dc1a2ed4dda4f2c45424bb71">More...</a><br /></td></tr>
<tr class="separator:a2320b4c3dc1a2ed4dda4f2c45424bb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6ca756bf46c71783e9fd9d92801c9"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a1fa6ca756bf46c71783e9fd9d92801c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a1fa6ca756bf46c71783e9fd9d92801c9">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a1fa6ca756bf46c71783e9fd9d92801c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_43.png"/>).  <a href="#a1fa6ca756bf46c71783e9fd9d92801c9">More...</a><br /></td></tr>
<tr class="separator:a1fa6ca756bf46c71783e9fd9d92801c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108b74e73ac3e54a2b750d890cb7e473"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a108b74e73ac3e54a2b750d890cb7e473"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a108b74e73ac3e54a2b750d890cb7e473">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:a108b74e73ac3e54a2b750d890cb7e473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_44.png"/>).  <a href="#a108b74e73ac3e54a2b750d890cb7e473">More...</a><br /></td></tr>
<tr class="separator:a108b74e73ac3e54a2b750d890cb7e473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db28ef07757b8957f2b5905c55d836"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac8db28ef07757b8957f2b5905c55d836"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ac8db28ef07757b8957f2b5905c55d836">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:ac8db28ef07757b8957f2b5905c55d836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>).  <a href="#ac8db28ef07757b8957f2b5905c55d836">More...</a><br /></td></tr>
<tr class="separator:ac8db28ef07757b8957f2b5905c55d836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950265827d5c8c989089e76ffa1b99f9"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a950265827d5c8c989089e76ffa1b99f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a950265827d5c8c989089e76ffa1b99f9">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a950265827d5c8c989089e76ffa1b99f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a950265827d5c8c989089e76ffa1b99f9">More...</a><br /></td></tr>
<tr class="separator:a950265827d5c8c989089e76ffa1b99f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a7ac3e93de076e1762ea1ec55ec54e"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ab9a7ac3e93de076e1762ea1ec55ec54e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ab9a7ac3e93de076e1762ea1ec55ec54e">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab9a7ac3e93de076e1762ea1ec55ec54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the assignment of a dense vector.  <a href="#ab9a7ac3e93de076e1762ea1ec55ec54e">More...</a><br /></td></tr>
<tr class="separator:ab9a7ac3e93de076e1762ea1ec55ec54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dace993e1fdeaf46fa91251793b7b20"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3dace993e1fdeaf46fa91251793b7b20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3dace993e1fdeaf46fa91251793b7b20">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3dace993e1fdeaf46fa91251793b7b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#a3dace993e1fdeaf46fa91251793b7b20">More...</a><br /></td></tr>
<tr class="separator:a3dace993e1fdeaf46fa91251793b7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90083d26ec56ecaf75dbe1a1bfe188b7"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a90083d26ec56ecaf75dbe1a1bfe188b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a90083d26ec56ecaf75dbe1a1bfe188b7">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a90083d26ec56ecaf75dbe1a1bfe188b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the addition assignment of a dense vector.  <a href="#a90083d26ec56ecaf75dbe1a1bfe188b7">More...</a><br /></td></tr>
<tr class="separator:a90083d26ec56ecaf75dbe1a1bfe188b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642029360cae3801d10964a2efb0427"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a1642029360cae3801d10964a2efb0427"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a1642029360cae3801d10964a2efb0427">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1642029360cae3801d10964a2efb0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#a1642029360cae3801d10964a2efb0427">More...</a><br /></td></tr>
<tr class="separator:a1642029360cae3801d10964a2efb0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372b9abaafac2779557337efcbae8769"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a372b9abaafac2779557337efcbae8769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a372b9abaafac2779557337efcbae8769">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a372b9abaafac2779557337efcbae8769"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the subtraction assignment of a dense vector.  <a href="#a372b9abaafac2779557337efcbae8769">More...</a><br /></td></tr>
<tr class="separator:a372b9abaafac2779557337efcbae8769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9779b5e7f8a3f4b1a30ccc0bb41d5280"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a9779b5e7f8a3f4b1a30ccc0bb41d5280"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a9779b5e7f8a3f4b1a30ccc0bb41d5280">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9779b5e7f8a3f4b1a30ccc0bb41d5280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a dense vector.  <a href="#a9779b5e7f8a3f4b1a30ccc0bb41d5280">More...</a><br /></td></tr>
<tr class="separator:a9779b5e7f8a3f4b1a30ccc0bb41d5280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ee575341d6e1e69c9ce2a7893af5a3"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a66ee575341d6e1e69c9ce2a7893af5a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a66ee575341d6e1e69c9ce2a7893af5a3">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a66ee575341d6e1e69c9ce2a7893af5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the multiplication assignment of a dense vector.  <a href="#a66ee575341d6e1e69c9ce2a7893af5a3">More...</a><br /></td></tr>
<tr class="separator:a66ee575341d6e1e69c9ce2a7893af5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1914321313e77eee836ed080feedf2a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa1914321313e77eee836ed080feedf2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedDivAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa1914321313e77eee836ed080feedf2a">divAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa1914321313e77eee836ed080feedf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the division assignment of a dense vector.  <a href="#aa1914321313e77eee836ed080feedf2a">More...</a><br /></td></tr>
<tr class="separator:aa1914321313e77eee836ed080feedf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36880b6f236e8187d8d42d26f84d204"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ab36880b6f236e8187d8d42d26f84d204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::BLAZE_TEMPLATE VectorizedDivAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ab36880b6f236e8187d8d42d26f84d204">divAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab36880b6f236e8187d8d42d26f84d204"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the division assignment of a dense vector.  <a href="#ab36880b6f236e8187d8d42d26f84d204">More...</a><br /></td></tr>
<tr class="separator:ab36880b6f236e8187d8d42d26f84d204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721338a0234a4dee3200733d8056e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a7721338a0234a4dee3200733d8056e68">operator~</a> () noexcept</td></tr>
<tr class="memdesc:a7721338a0234a4dee3200733d8056e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a7721338a0234a4dee3200733d8056e68">More...</a><br /></td></tr>
<tr class="separator:a7721338a0234a4dee3200733d8056e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fea61cee277be4dcad4276b298237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a466fea61cee277be4dcad4276b298237">operator~</a> () const noexcept</td></tr>
<tr class="memdesc:a466fea61cee277be4dcad4276b298237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#a466fea61cee277be4dcad4276b298237">More...</a><br /></td></tr>
<tr class="separator:a466fea61cee277be4dcad4276b298237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ae1b7308f348f41ddeb914c852b77b7d9"><td class="memItemLeft" align="right" valign="top"><a id="ae1b7308f348f41ddeb914c852b77b7d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae1b7308f348f41ddeb914c852b77b7d9">CustomVector</a> ()</td></tr>
<tr class="memdesc:ae1b7308f348f41ddeb914c852b77b7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>. <br /></td></tr>
<tr class="separator:ae1b7308f348f41ddeb914c852b77b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501e1414cc378478ebd28cc1c905b799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a501e1414cc378478ebd28cc1c905b799">CustomVector</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a501e1414cc378478ebd28cc1c905b799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for an unpadded custom vector of size <em>n</em>.  <a href="#a501e1414cc378478ebd28cc1c905b799">More...</a><br /></td></tr>
<tr class="separator:a501e1414cc378478ebd28cc1c905b799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8524712b2893a3b965e8f42d058b3fa7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a8524712b2893a3b965e8f42d058b3fa7">CustomVector</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nn)</td></tr>
<tr class="memdesc:a8524712b2893a3b965e8f42d058b3fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a padded custom vector of size <em>n</em> and capacity <em>nn</em>.  <a href="#a8524712b2893a3b965e8f42d058b3fa7">More...</a><br /></td></tr>
<tr class="separator:a8524712b2893a3b965e8f42d058b3fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec421f8b30baa6186ecd6b96ffb590"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aefec421f8b30baa6186ecd6b96ffb590">CustomVector</a> (const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;v)</td></tr>
<tr class="memdesc:aefec421f8b30baa6186ecd6b96ffb590"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>.  <a href="#aefec421f8b30baa6186ecd6b96ffb590">More...</a><br /></td></tr>
<tr class="separator:aefec421f8b30baa6186ecd6b96ffb590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602c0b0c5ff45a3313c3074e8274d14b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a602c0b0c5ff45a3313c3074e8274d14b">CustomVector</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&amp;v) noexcept</td></tr>
<tr class="memdesc:a602c0b0c5ff45a3313c3074e8274d14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>.  <a href="#a602c0b0c5ff45a3313c3074e8274d14b">More...</a><br /></td></tr>
<tr class="separator:a602c0b0c5ff45a3313c3074e8274d14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a5795fcc7c394414feb937c095d6c7ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae248c263531bcc40bed9c1f7863fdd59">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a5795fcc7c394414feb937c095d6c7ed2">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) noexcept</td></tr>
<tr class="memdesc:a5795fcc7c394414feb937c095d6c7ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a5795fcc7c394414feb937c095d6c7ed2">More...</a><br /></td></tr>
<tr class="separator:a5795fcc7c394414feb937c095d6c7ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3778c719ee712688f377d489e312a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7c4d836cf13c1377a92ac9b55f52dc4c">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a8c3778c719ee712688f377d489e312a2">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a8c3778c719ee712688f377d489e312a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a8c3778c719ee712688f377d489e312a2">More...</a><br /></td></tr>
<tr class="separator:a8c3778c719ee712688f377d489e312a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af4b2cad97ec05f09466378a6981844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae248c263531bcc40bed9c1f7863fdd59">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3af4b2cad97ec05f09466378a6981844">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a3af4b2cad97ec05f09466378a6981844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the vector elements.  <a href="#a3af4b2cad97ec05f09466378a6981844">More...</a><br /></td></tr>
<tr class="separator:a3af4b2cad97ec05f09466378a6981844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73f8069b5c245f9bfea2a40fe5511e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7c4d836cf13c1377a92ac9b55f52dc4c">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ab73f8069b5c245f9bfea2a40fe5511e4">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:ab73f8069b5c245f9bfea2a40fe5511e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the vector elements.  <a href="#ab73f8069b5c245f9bfea2a40fe5511e4">More...</a><br /></td></tr>
<tr class="separator:ab73f8069b5c245f9bfea2a40fe5511e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79cf668f1c4fd8e584d5dea9bb2709d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa143f79745bd5ea884d4a69a391adce8">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae79cf668f1c4fd8e584d5dea9bb2709d">data</a> () noexcept</td></tr>
<tr class="memdesc:ae79cf668f1c4fd8e584d5dea9bb2709d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#ae79cf668f1c4fd8e584d5dea9bb2709d">More...</a><br /></td></tr>
<tr class="separator:ae79cf668f1c4fd8e584d5dea9bb2709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682cfb2c618c04ce55d66fc2bc3e0d34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a61a02c5d89b21a021d1149826465912a">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a682cfb2c618c04ce55d66fc2bc3e0d34">data</a> () const noexcept</td></tr>
<tr class="memdesc:a682cfb2c618c04ce55d66fc2bc3e0d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#a682cfb2c618c04ce55d66fc2bc3e0d34">More...</a><br /></td></tr>
<tr class="separator:a682cfb2c618c04ce55d66fc2bc3e0d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343750fe0c29b3abc3c48bda917cee43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a445ff043bb703c01844c010a1e544f3c">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a343750fe0c29b3abc3c48bda917cee43">begin</a> () noexcept</td></tr>
<tr class="memdesc:a343750fe0c29b3abc3c48bda917cee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the custom vector.  <a href="#a343750fe0c29b3abc3c48bda917cee43">More...</a><br /></td></tr>
<tr class="separator:a343750fe0c29b3abc3c48bda917cee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868d5f62ebb01013d8137f8e4571c17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a868d5f62ebb01013d8137f8e4571c17e">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a868d5f62ebb01013d8137f8e4571c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the custom vector.  <a href="#a868d5f62ebb01013d8137f8e4571c17e">More...</a><br /></td></tr>
<tr class="separator:a868d5f62ebb01013d8137f8e4571c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf748b277b3da49739873ed6c15e911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aadf748b277b3da49739873ed6c15e911">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aadf748b277b3da49739873ed6c15e911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the custom vector.  <a href="#aadf748b277b3da49739873ed6c15e911">More...</a><br /></td></tr>
<tr class="separator:aadf748b277b3da49739873ed6c15e911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116ad04051f6412d5be473c35b0eeaea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a445ff043bb703c01844c010a1e544f3c">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a116ad04051f6412d5be473c35b0eeaea">end</a> () noexcept</td></tr>
<tr class="memdesc:a116ad04051f6412d5be473c35b0eeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the custom vector.  <a href="#a116ad04051f6412d5be473c35b0eeaea">More...</a><br /></td></tr>
<tr class="separator:a116ad04051f6412d5be473c35b0eeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84398bfb341db99ea63ae3efdfe582bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a84398bfb341db99ea63ae3efdfe582bf">end</a> () const noexcept</td></tr>
<tr class="memdesc:a84398bfb341db99ea63ae3efdfe582bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the custom vector.  <a href="#a84398bfb341db99ea63ae3efdfe582bf">More...</a><br /></td></tr>
<tr class="separator:a84398bfb341db99ea63ae3efdfe582bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e2e865927c24b29387d860b7af577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a087e2e865927c24b29387d860b7af577">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a087e2e865927c24b29387d860b7af577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the custom vector.  <a href="#a087e2e865927c24b29387d860b7af577">More...</a><br /></td></tr>
<tr class="separator:a087e2e865927c24b29387d860b7af577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a29995a2b8b6be923e56200c41dc4343b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a29995a2b8b6be923e56200c41dc4343b">operator=</a> (const Type &amp;rhs)</td></tr>
<tr class="memdesc:a29995a2b8b6be923e56200c41dc4343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all vector elements.  <a href="#a29995a2b8b6be923e56200c41dc4343b">More...</a><br /></td></tr>
<tr class="separator:a29995a2b8b6be923e56200c41dc4343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2676e7786c96ec8408bec0ee9e4f83ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a2676e7786c96ec8408bec0ee9e4f83ef">operator=</a> (<a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; list)</td></tr>
<tr class="memdesc:a2676e7786c96ec8408bec0ee9e4f83ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">List assignment to all vector elements.  <a href="#a2676e7786c96ec8408bec0ee9e4f83ef">More...</a><br /></td></tr>
<tr class="separator:a2676e7786c96ec8408bec0ee9e4f83ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732a8b860f81d4e1d34fee732e245cb9"><td class="memTemplParams" colspan="2"><a id="a732a8b860f81d4e1d34fee732e245cb9"></a>
template&lt;typename Other , size_t N&gt; </td></tr>
<tr class="memitem:a732a8b860f81d4e1d34fee732e245cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Other(&amp;array)[N])</td></tr>
<tr class="separator:a732a8b860f81d4e1d34fee732e245cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e56c0859da0e1e9929d67eaa8b77be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a97e56c0859da0e1e9929d67eaa8b77be">operator=</a> (const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a97e56c0859da0e1e9929d67eaa8b77be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>.  <a href="#a97e56c0859da0e1e9929d67eaa8b77be">More...</a><br /></td></tr>
<tr class="separator:a97e56c0859da0e1e9929d67eaa8b77be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfe9262634f0d6e6abe8df473710b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a2cfe9262634f0d6e6abe8df473710b5b">operator=</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2cfe9262634f0d6e6abe8df473710b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>.  <a href="#a2cfe9262634f0d6e6abe8df473710b5b">More...</a><br /></td></tr>
<tr class="separator:a2cfe9262634f0d6e6abe8df473710b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dca3992b25dc456610c696159b6546"><td class="memTemplParams" colspan="2"><a id="a05dca3992b25dc456610c696159b6546"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a05dca3992b25dc456610c696159b6546"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a05dca3992b25dc456610c696159b6546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c8f6b0b79006dfb156cac95f2276c4"><td class="memTemplParams" colspan="2"><a id="ad8c8f6b0b79006dfb156cac95f2276c4"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad8c8f6b0b79006dfb156cac95f2276c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ad8c8f6b0b79006dfb156cac95f2276c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c61ee211a70e06f6b4349eb3845cd"><td class="memTemplParams" colspan="2"><a id="a318c61ee211a70e06f6b4349eb3845cd"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a318c61ee211a70e06f6b4349eb3845cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a318c61ee211a70e06f6b4349eb3845cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17be6117fec062f525c13831bc05f04d"><td class="memTemplParams" colspan="2"><a id="a17be6117fec062f525c13831bc05f04d"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a17be6117fec062f525c13831bc05f04d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a17be6117fec062f525c13831bc05f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a2edef598ce264cba2b25a36d83c44"><td class="memTemplParams" colspan="2"><a id="a09a2edef598ce264cba2b25a36d83c44"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a09a2edef598ce264cba2b25a36d83c44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a09a2edef598ce264cba2b25a36d83c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95762b1aa95f072cab72d71b3832eafb"><td class="memTemplParams" colspan="2"><a id="a95762b1aa95f072cab72d71b3832eafb"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a95762b1aa95f072cab72d71b3832eafb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a95762b1aa95f072cab72d71b3832eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed51b18fb5d63d95a835e89896ecb652"><td class="memTemplParams" colspan="2"><a id="aed51b18fb5d63d95a835e89896ecb652"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aed51b18fb5d63d95a835e89896ecb652"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:aed51b18fb5d63d95a835e89896ecb652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52376310c0da67d1cc6660485270a81"><td class="memTemplParams" colspan="2"><a id="af52376310c0da67d1cc6660485270a81"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:af52376310c0da67d1cc6660485270a81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:af52376310c0da67d1cc6660485270a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a37f791d580728ae1840805f03df1e8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a37f791d580728ae1840805f03df1e8d5">size</a> () const noexcept</td></tr>
<tr class="memdesc:a37f791d580728ae1840805f03df1e8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size/dimension of the vector.  <a href="#a37f791d580728ae1840805f03df1e8d5">More...</a><br /></td></tr>
<tr class="separator:a37f791d580728ae1840805f03df1e8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243da3ef6baa3c3dba28a21323e1a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa243da3ef6baa3c3dba28a21323e1a4a">spacing</a> () const noexcept</td></tr>
<tr class="memdesc:aa243da3ef6baa3c3dba28a21323e1a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum capacity of the vector.  <a href="#aa243da3ef6baa3c3dba28a21323e1a4a">More...</a><br /></td></tr>
<tr class="separator:aa243da3ef6baa3c3dba28a21323e1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7482c357a04ed1ad3258b2bb55c8aaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7482c357a04ed1ad3258b2bb55c8aaab">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a7482c357a04ed1ad3258b2bb55c8aaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the vector.  <a href="#a7482c357a04ed1ad3258b2bb55c8aaab">More...</a><br /></td></tr>
<tr class="separator:a7482c357a04ed1ad3258b2bb55c8aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e01237d2939a5466bd77a0702e7b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af2e01237d2939a5466bd77a0702e7b37">nonZeros</a> () const</td></tr>
<tr class="memdesc:af2e01237d2939a5466bd77a0702e7b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the vector.  <a href="#af2e01237d2939a5466bd77a0702e7b37">More...</a><br /></td></tr>
<tr class="separator:af2e01237d2939a5466bd77a0702e7b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d09dbdf8c5e3159eb1f1db40674cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a4d0d09dbdf8c5e3159eb1f1db40674cf">reset</a> ()</td></tr>
<tr class="memdesc:a4d0d09dbdf8c5e3159eb1f1db40674cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a4d0d09dbdf8c5e3159eb1f1db40674cf">More...</a><br /></td></tr>
<tr class="separator:a4d0d09dbdf8c5e3159eb1f1db40674cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d44399f3edef2f489f0312deb599b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa36d44399f3edef2f489f0312deb599b">clear</a> ()</td></tr>
<tr class="memdesc:aa36d44399f3edef2f489f0312deb599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the vector to its default state.  <a href="#aa36d44399f3edef2f489f0312deb599b">More...</a><br /></td></tr>
<tr class="separator:aa36d44399f3edef2f489f0312deb599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cfab6c7fc3ff1c37ba07a076baddfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a67cfab6c7fc3ff1c37ba07a076baddfa">swap</a> (<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;v) noexcept</td></tr>
<tr class="memdesc:a67cfab6c7fc3ff1c37ba07a076baddfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two vectors.  <a href="#a67cfab6c7fc3ff1c37ba07a076baddfa">More...</a><br /></td></tr>
<tr class="separator:a67cfab6c7fc3ff1c37ba07a076baddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numeric functions</div></td></tr>
<tr class="memitem:a53067f260ec75556269ce67ba9b1e354"><td class="memTemplParams" colspan="2"><a id="a53067f260ec75556269ce67ba9b1e354"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a53067f260ec75556269ce67ba9b1e354"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a53067f260ec75556269ce67ba9b1e354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resource management functions</div></td></tr>
<tr class="memitem:ab5b714b17164bcd308e4397d922d6b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ab5b714b17164bcd308e4397d922d6b01">reset</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ab5b714b17164bcd308e4397d922d6b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the custom vector and replaces the array of elements with the given array.  <a href="#ab5b714b17164bcd308e4397d922d6b01">More...</a><br /></td></tr>
<tr class="separator:ab5b714b17164bcd308e4397d922d6b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b8afeabf15f4f9334295de606d09f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a15b8afeabf15f4f9334295de606d09f6">reset</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nn)</td></tr>
<tr class="memdesc:a15b8afeabf15f4f9334295de606d09f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the custom vector and replaces the array of elements with the given array.  <a href="#a15b8afeabf15f4f9334295de606d09f6">More...</a><br /></td></tr>
<tr class="separator:a15b8afeabf15f4f9334295de606d09f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:acf774a86bb8549a88d2ffcd372685d45"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:acf774a86bb8549a88d2ffcd372685d45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#acf774a86bb8549a88d2ffcd372685d45">canAlias</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:acf774a86bb8549a88d2ffcd372685d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector can alias with the given address <em>alias</em>.  <a href="#acf774a86bb8549a88d2ffcd372685d45">More...</a><br /></td></tr>
<tr class="separator:acf774a86bb8549a88d2ffcd372685d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd8ca4778a221b3ff120e724861e7a"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a1edd8ca4778a221b3ff120e724861e7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a1edd8ca4778a221b3ff120e724861e7a">isAliased</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:a1edd8ca4778a221b3ff120e724861e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is aliased with the given address <em>alias</em>.  <a href="#a1edd8ca4778a221b3ff120e724861e7a">More...</a><br /></td></tr>
<tr class="separator:a1edd8ca4778a221b3ff120e724861e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fe3602be7a478f5d073a418ade2026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a31fe3602be7a478f5d073a418ade2026">isAligned</a> () const noexcept</td></tr>
<tr class="memdesc:a31fe3602be7a478f5d073a418ade2026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is properly aligned in memory.  <a href="#a31fe3602be7a478f5d073a418ade2026">More...</a><br /></td></tr>
<tr class="separator:a31fe3602be7a478f5d073a418ade2026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15215776c51376fd31eae588ba7f0bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a15215776c51376fd31eae588ba7f0bbf">canSMPAssign</a> () const noexcept</td></tr>
<tr class="memdesc:a15215776c51376fd31eae588ba7f0bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector can be used in SMP assignments.  <a href="#a15215776c51376fd31eae588ba7f0bbf">More...</a><br /></td></tr>
<tr class="separator:a15215776c51376fd31eae588ba7f0bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74375e9548ef59547dadb33b59400b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a74375e9548ef59547dadb33b59400b5a">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a74375e9548ef59547dadb33b59400b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load of a SIMD element of the vector.  <a href="#a74375e9548ef59547dadb33b59400b5a">More...</a><br /></td></tr>
<tr class="separator:a74375e9548ef59547dadb33b59400b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c98657b4aa87f8e3650f72c87bd12c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae6c98657b4aa87f8e3650f72c87bd12c">loada</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:ae6c98657b4aa87f8e3650f72c87bd12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of a SIMD element of the vector.  <a href="#ae6c98657b4aa87f8e3650f72c87bd12c">More...</a><br /></td></tr>
<tr class="separator:ae6c98657b4aa87f8e3650f72c87bd12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9a95dc7346020f4aa4ccfb6eef4380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a4e9a95dc7346020f4aa4ccfb6eef4380">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a4e9a95dc7346020f4aa4ccfb6eef4380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of a SIMD element of the vector.  <a href="#a4e9a95dc7346020f4aa4ccfb6eef4380">More...</a><br /></td></tr>
<tr class="separator:a4e9a95dc7346020f4aa4ccfb6eef4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb0c18ba84a90b73085aa7f56db710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#abdeb0c18ba84a90b73085aa7f56db710">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:abdeb0c18ba84a90b73085aa7f56db710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store of a SIMD element of the vector.  <a href="#abdeb0c18ba84a90b73085aa7f56db710">More...</a><br /></td></tr>
<tr class="separator:abdeb0c18ba84a90b73085aa7f56db710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937f103448f0edaf2f2d99f7d8633a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a937f103448f0edaf2f2d99f7d8633a2b">storea</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a937f103448f0edaf2f2d99f7d8633a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a SIMD element of the vector.  <a href="#a937f103448f0edaf2f2d99f7d8633a2b">More...</a><br /></td></tr>
<tr class="separator:a937f103448f0edaf2f2d99f7d8633a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e69256271fe7345da93aefa8e054a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a8e69256271fe7345da93aefa8e054a19">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a8e69256271fe7345da93aefa8e054a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a SIMD element of the vector.  <a href="#a8e69256271fe7345da93aefa8e054a19">More...</a><br /></td></tr>
<tr class="separator:a8e69256271fe7345da93aefa8e054a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b8b004e57b1dea57eb824afc3af616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ad2b8b004e57b1dea57eb824afc3af616">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ad2b8b004e57b1dea57eb824afc3af616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a SIMD element of the vector.  <a href="#ad2b8b004e57b1dea57eb824afc3af616">More...</a><br /></td></tr>
<tr class="separator:ad2b8b004e57b1dea57eb824afc3af616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1dff7bec36b451b5671435f5ff5ba3"><td class="memTemplParams" colspan="2"><a id="a0d1dff7bec36b451b5671435f5ff5ba3"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a0d1dff7bec36b451b5671435f5ff5ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a0d1dff7bec36b451b5671435f5ff5ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6690c0185dbac9685e125643e4e331"><td class="memTemplParams" colspan="2"><a id="a7f6690c0185dbac9685e125643e4e331"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7f6690c0185dbac9685e125643e4e331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a7f6690c0185dbac9685e125643e4e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccc70881ae0033f863f93bd1c0fb515"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3ccc70881ae0033f863f93bd1c0fb515"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3ccc70881ae0033f863f93bd1c0fb515">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3ccc70881ae0033f863f93bd1c0fb515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#a3ccc70881ae0033f863f93bd1c0fb515">More...</a><br /></td></tr>
<tr class="separator:a3ccc70881ae0033f863f93bd1c0fb515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9a9b90375046be4bc0ba15c0235317"><td class="memTemplParams" colspan="2"><a id="afc9a9b90375046be4bc0ba15c0235317"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:afc9a9b90375046be4bc0ba15c0235317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:afc9a9b90375046be4bc0ba15c0235317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f62f7905e4c8f9c8f0b749fec92936b"><td class="memTemplParams" colspan="2"><a id="a7f62f7905e4c8f9c8f0b749fec92936b"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7f62f7905e4c8f9c8f0b749fec92936b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a7f62f7905e4c8f9c8f0b749fec92936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3458944c83cf3dae7f272635aacf875"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ab3458944c83cf3dae7f272635aacf875"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ab3458944c83cf3dae7f272635aacf875">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab3458944c83cf3dae7f272635aacf875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#ab3458944c83cf3dae7f272635aacf875">More...</a><br /></td></tr>
<tr class="separator:ab3458944c83cf3dae7f272635aacf875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d91ac12e4ee5a2458c86e4e23af2ef"><td class="memTemplParams" colspan="2"><a id="a14d91ac12e4ee5a2458c86e4e23af2ef"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a14d91ac12e4ee5a2458c86e4e23af2ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a14d91ac12e4ee5a2458c86e4e23af2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dde362e06176ed21a9c6e8b07de262a"><td class="memTemplParams" colspan="2"><a id="a1dde362e06176ed21a9c6e8b07de262a"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a1dde362e06176ed21a9c6e8b07de262a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a1dde362e06176ed21a9c6e8b07de262a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70cdaf41933eed08b8d211a7dd6a1c0"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac70cdaf41933eed08b8d211a7dd6a1c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ac70cdaf41933eed08b8d211a7dd6a1c0">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac70cdaf41933eed08b8d211a7dd6a1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#ac70cdaf41933eed08b8d211a7dd6a1c0">More...</a><br /></td></tr>
<tr class="separator:ac70cdaf41933eed08b8d211a7dd6a1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2f58884bafde1fc0fac4162031da9"><td class="memTemplParams" colspan="2"><a id="a23d2f58884bafde1fc0fac4162031da9"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a23d2f58884bafde1fc0fac4162031da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a23d2f58884bafde1fc0fac4162031da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8878543e7792c108586058c35a36062e"><td class="memTemplParams" colspan="2"><a id="a8878543e7792c108586058c35a36062e"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a8878543e7792c108586058c35a36062e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a8878543e7792c108586058c35a36062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee0218ba15c5ad8988ed01ebf64b8a3"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a5ee0218ba15c5ad8988ed01ebf64b8a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a5ee0218ba15c5ad8988ed01ebf64b8a3">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5ee0218ba15c5ad8988ed01ebf64b8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a sparse vector.  <a href="#a5ee0218ba15c5ad8988ed01ebf64b8a3">More...</a><br /></td></tr>
<tr class="separator:a5ee0218ba15c5ad8988ed01ebf64b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548cde5272f2045def5939b30a1cc9c"><td class="memTemplParams" colspan="2"><a id="ae548cde5272f2045def5939b30a1cc9c"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ae548cde5272f2045def5939b30a1cc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedDivAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ae548cde5272f2045def5939b30a1cc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5136d14db8fd50cb114f7f0faf90d946"><td class="memTemplParams" colspan="2"><a id="a5136d14db8fd50cb114f7f0faf90d946"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a5136d14db8fd50cb114f7f0faf90d946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedDivAssign&lt; VT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a5136d14db8fd50cb114f7f0faf90d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af76a0e6de33142d66883090e18ce8638"><td class="memItemLeft" align="right" valign="top"><a id="af76a0e6de33142d66883090e18ce8638"></a>enum &#160;</td><td class="memItemRight" valign="bottom">: size_t { <b>SIMDSIZE</b> = SIMDTrait&lt;ElementType&gt;::size
 }<tr class="memdesc:af76a0e6de33142d66883090e18ce8638"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements packed within a single SIMD element. <br /></td></tr>
</td></tr>
<tr class="separator:af76a0e6de33142d66883090e18ce8638"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:ade648e35020ce181136871bb47f6bc80"><td class="memItemLeft" align="right" valign="top"><a id="ade648e35020ce181136871bb47f6bc80"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ade648e35020ce181136871bb47f6bc80">size_</a></td></tr>
<tr class="memdesc:ade648e35020ce181136871bb47f6bc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size/dimension of the custom vector. <br /></td></tr>
<tr class="separator:ade648e35020ce181136871bb47f6bc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34655028254912e56383fce504793bc9"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a34655028254912e56383fce504793bc9">v_</a></td></tr>
<tr class="memdesc:a34655028254912e56383fce504793bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The custom array of elements.  <a href="#a34655028254912e56383fce504793bc9">More...</a><br /></td></tr>
<tr class="separator:a34655028254912e56383fce504793bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt;<br />
class blaze::CustomVector&lt; Type, AF, PF, TF &gt;</h3>

<p>Efficient implementation of a customizable vector. </p>
<h1><a class="anchor" id="customvector_general"></a>
General</h1>
<p>The <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> class template provides the functionality to represent an external array of elements of arbitrary type and a fixed size as a native <b>Blaze</b> dense vector data structure. Thus in contrast to all other dense vector types a custom vector does not perform any kind of memory allocation by itself, but it is provided with an existing array of element during construction. A custom vector can therefore be considered an alias to the existing array.</p>
<p>The type of the elements, the properties of the given array of elements and the transpose flag of the vector can be specified via the following four template parameters:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> PF, <span class="keywordtype">bool</span> TF &gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="../../de/d32/classblaze_1_1CustomVector.html#ae1b7308f348f41ddeb914c852b77b7d9">CustomVector</a>;</div></div><!-- fragment --><ul>
<li>Type: specifies the type of the vector elements. <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>AF : specifies whether the represented, external arrays are properly aligned with respect to the available instruction set (SSE, AVX, ...) or not.</li>
<li>PF : specified whether the represented, external arrays are properly padded with respect to the available instruction set (SSE, AVX, ...) or not.</li>
<li>TF : specifies whether the vector is a row vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a></em>) or a column vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>.</li>
</ul>
<p>The following examples give an impression of several possible types of custom vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom column vector for unaligned, unpadded integer arrays</span></div><div class="line"><span class="keyword">using</span> UnalignedUnpadded = CustomVector&lt;int,unaligned,unpadded,columnVector&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom column vector for unaligned but padded &#39;float&#39; arrays</span></div><div class="line"><span class="keyword">using</span> UnalignedPadded = CustomVector&lt;float,unaligned,padded,columnVector&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom row vector for aligned, unpadded &#39;double&#39; arrays</span></div><div class="line"><span class="keyword">using</span> AlignedUnpadded = CustomVector&lt;double,aligned,unpadded,rowVector&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom row vector for aligned, padded &#39;complex&lt;double&gt;&#39; arrays</span></div><div class="line"><span class="keyword">using</span> AlignedPadded = CustomVector&lt;complex&lt;double&gt;,<a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">aligned</a>,<a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">padded</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">rowVector</a>&gt;;</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="customvector_special_properties"></a>
Special Properties of Custom Vectors</h1>
<p>In comparison with the remaining <b>Blaze</b> dense vector types <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> has several special characteristics. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> of these result from the fact that a custom vector is not performing any kind of memory allocation, but instead is given an existing array of elements. The following sections discuss all of these characteristics:</p>
<ol type="1">
<li><b><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#customvector_memory_management">Memory Management</a></b></li>
<li><b><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#customvector_copy_operations">Copy Operations</a></b></li>
<li><b><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#customvector_alignment">Alignment</a></b></li>
<li><b><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#customvector_padding">Padding</a></b></li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="customvector_memory_management"></a>
Memory Management</h2>
<p>The <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a> class template acts as an adaptor for an existing array of elements. As such it provides everything that is required to use the array just like a native <b>Blaze</b> dense vector data structure. However, this flexibility comes with the price that the user of a custom vector is responsible for the resource management.</p>
<p>The following examples give an impression of several possible types of custom vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a 3-dimensional custom vector with unaligned, unpadded and externally</span></div><div class="line"><span class="comment">// managed integer array. Note that the std::vector must be guaranteed to outlive the</span></div><div class="line"><span class="comment">// custom vector!</span></div><div class="line">std::vector&lt;int&gt; vec( 3UL );</div><div class="line">CustomVector&lt;int,unaligned,unpadded&gt; a( &amp;vec[0], 3UL );</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom vector with size 3 and capacity 16 with aligned, padded and</span></div><div class="line"><span class="comment">// externally managed integer array. Note that the std::unique_ptr must be guaranteed</span></div><div class="line"><span class="comment">// to outlive the custom vector!</span></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory( allocate&lt;int&gt;( 16UL ) );</div><div class="line">CustomVector&lt;int,aligned,padded&gt; b( memory.get(), 3UL, 16UL );</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="customvector_copy_operations"></a>
Copy Operations</h2>
<p>As with all dense vectors it is possible to copy construct a custom vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomVector&lt;int,unaligned,unpadded&gt;;</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vec( 5UL, 10 );  <span class="comment">// Vector of 5 integers of the value 10</span></div><div class="line">CustomType a( &amp;vec[0], 5UL );     <span class="comment">// Represent the std::vector as Blaze dense vector</span></div><div class="line">a[1] = 20;                        <span class="comment">// Also modifies the std::vector</span></div><div class="line"></div><div class="line">CustomType b( a );  <span class="comment">// Creating a copy of vector a</span></div><div class="line">b[2] = 20;          <span class="comment">// Also affects vector a and the std::vector</span></div></div><!-- fragment --><p>It is important to note that a custom vector acts as a reference to the specified array. Thus the result of the copy constructor is a new custom vector that is referencing and representing the same array as the original custom vector.</p>
<p>In contrast to copy construction, just as with references, copy assignment does not change which array is referenced by the custom vector, but modifies the values of the array:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec2( 5UL, 4 );  <span class="comment">// Vector of 5 integers of the value 4</span></div><div class="line">CustomType c( &amp;vec2[0], 5UL );    <span class="comment">// Represent the std::vector as Blaze dense vector</span></div><div class="line"></div><div class="line">a = c;  <span class="comment">// Copy assignment: Set all values of vector a and b to 4.</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="customvector_alignment"></a>
Alignment</h2>
<p>In case the custom vector is specified as <em>aligned</em> the passed array must be guaranteed to be aligned according to the requirements of the used instruction set (SSE, AVX, ...). For instance, if AVX is active an array of integers must be 32-bit aligned:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Allocation of 32-bit aligned memory</span></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory( allocate&lt;int&gt;( 5UL ) );</div><div class="line"></div><div class="line">CustomVector&lt;int,aligned,unpadded&gt; a( memory.get(), 5UL );</div></div><!-- fragment --><p>In case the alignment requirements are violated, a <em>std::invalid_argument</em> exception is thrown.</p>
<p><br />
 </p>
<h2><a class="anchor" id="customvector_padding"></a>
Padding</h2>
<p>Adding padding elements to the end of an array can have a significant impact on performance. For instance, assuming that AVX is available, then two aligned, padded, 3-dimensional vectors of double precision values can be added via a single SIMD addition operations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomVector&lt;double,aligned,padded&gt;;</div><div class="line"></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory1( allocate&lt;double&gt;( 4UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory2( allocate&lt;double&gt;( 4UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory3( allocate&lt;double&gt;( 4UL ) );</div><div class="line"></div><div class="line"><span class="comment">// Creating padded custom vectors of size 3 and a capacity of 4</span></div><div class="line">CustomType a( memory1.get(), 3UL, 4UL );</div><div class="line">CustomType b( memory2.get(), 3UL, 4UL );</div><div class="line">CustomType c( memory3.get(), 3UL, 4UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">c = a + b;  <span class="comment">// AVX-based vector addition</span></div></div><!-- fragment --><p>In this example, maximum performance is possible. However, in case no padding elements are inserted, a scalar addition has to be used:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomVector&lt;double,aligned,unpadded&gt;;</div><div class="line"></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory1( allocate&lt;double&gt;( 3UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory2( allocate&lt;double&gt;( 3UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory3( allocate&lt;double&gt;( 3UL ) );</div><div class="line"></div><div class="line"><span class="comment">// Creating unpadded custom vector of size 3</span></div><div class="line">CustomType a( allocate&lt;double&gt;( 3UL ), 3UL );</div><div class="line">CustomType b( allocate&lt;double&gt;( 3UL ), 3UL );</div><div class="line">CustomType c( allocate&lt;double&gt;( 3UL ), 3UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">c = a + b;  <span class="comment">// Scalar vector addition</span></div></div><!-- fragment --><p>Note the different number of constructor parameters for unpadded and padded custom vectors: In contrast to unpadded vectors, where during the construction only the size of the array has to be specified, during the construction of a padded custom vector it is additionally necessary to explicitly specify the capacity of the array.</p>
<p>The number of padding elements is required to be sufficient with respect to the available instruction set: In case of an aligned padded custom vector the added padding elements must guarantee that the capacity is greater or equal than the size and a multiple of the SIMD vector width. In case of unaligned padded vectors the number of padding elements can be greater or equal the number of padding elements of an aligned padded custom vector. In case the padding is insufficient with respect to the available instruction set, a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Please also note that <b>Blaze</b> will zero initialize the padding elements in order to achieve maximum performance!</p>
<p><br />
 </p>
<h1><a class="anchor" id="customvector_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The use of custom vectors in arithmetic operations is designed to be as natural and intuitive as possible. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> operations (addition, subtraction, multiplication, scaling, ...) can be expressed similar to a text book representation. Also, custom vectors can be combined with all other dense and sparse vectors and matrices. The following example gives an impression of the use of <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Non-initialized custom column vector of size 2. All given arrays are considered to be</span></div><div class="line"><span class="comment">// unaligned and unpadded. The memory is managed via a &#39;std::vector&#39;.</span></div><div class="line">std::vector&lt;double&gt; memory1( 2UL );</div><div class="line">CustomVector&lt;double,unaligned,unpadded&gt; a( memory1.data(), 2UL );</div><div class="line"></div><div class="line">a[0] = 1.0;  <span class="comment">// Initialization of the first element</span></div><div class="line">a[1] = 2.0;  <span class="comment">// Initialization of the second element</span></div><div class="line"></div><div class="line"><span class="comment">// Non-initialized custom column vector of size 2 and capacity 4. All given arrays are required</span></div><div class="line"><span class="comment">// to be properly aligned and padded. The memory is managed via a &#39;std::unique_ptr&#39;.</span></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory2( allocate&lt;double&gt;( 4UL ) );</div><div class="line">CustomVector&lt;double,aligned,padded&gt; b( memory2.get(), 2UL, 4UL );</div><div class="line"></div><div class="line">b = 2.0;  <span class="comment">// Homogeneous initialization of all elements</span></div><div class="line"></div><div class="line">CompressedVector&lt;float&gt; c( 2 );  <span class="comment">// Empty sparse single precision vector</span></div><div class="line">DynamicVector&lt;double&gt;   d;       <span class="comment">// Default constructed dynamic vector</span></div><div class="line">DynamicMatrix&lt;double&gt;   A;       <span class="comment">// Default constructed row-major matrix</span></div><div class="line"></div><div class="line">d = a + b;  <span class="comment">// Vector addition between custom vectors of equal element type</span></div><div class="line">d = a - c;  <span class="comment">// Vector subtraction between a dense and sparse vector with different element types</span></div><div class="line">d = a * b;  <span class="comment">// Component-wise vector multiplication</span></div><div class="line"></div><div class="line">a *= 2.0;      <span class="comment">// In-place scaling of vector</span></div><div class="line">d  = a * 2.0;  <span class="comment">// Scaling of vector a</span></div><div class="line">d  = 2.0 * a;  <span class="comment">// Scaling of vector a</span></div><div class="line"></div><div class="line">d += a - b;  <span class="comment">// Addition assignment</span></div><div class="line">d -= a + c;  <span class="comment">// Subtraction assignment</span></div><div class="line">d *= a * b;  <span class="comment">// Multiplication assignment</span></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( a ) * b;  <span class="comment">// Scalar/dot/inner product between two vectors</span></div><div class="line"></div><div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( b );  <span class="comment">// Outer product between two vectors</span></div></div><!-- fragment --> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a38a9985b1e8b49d770d13c7ea9fb5844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a9985b1e8b49d770d13c7ea9fb5844">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SIMD optimization. </p>
<p>The <em>simdEnabled</em> compilation flag indicates whether expressions the vector is involved in can be optimized via SIMD operations. In case the element type of the vector is a vectorizable data type, the <em>simdEnabled</em> compilation flag is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<a id="a7945ebf68a7ca85907c343bfaa34665d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7945ebf68a7ca85907c343bfaa34665d">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SMP assignments. </p>
<p>The <em>smpAssignable</em> compilation flag indicates whether the vector can be used in SMP (shared memory parallel) assignments (both on the left-hand and right-hand side of the assignment). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a501e1414cc378478ebd28cc1c905b799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501e1414cc378478ebd28cc1c905b799">&#9670;&nbsp;</a></span>CustomVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for an unpadded custom vector of size <em>n</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the vector. </td></tr>
    <tr><td class="paramname">n</td><td>The number of array elements to be used by the custom vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates an unpadded custom vector of size <em>n</em>. The construction fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...).</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is <b>NOT</b> available for padded custom vectors! </dd>
<dd>
The custom vector does <b>NOT</b> take responsibility for the given array of elements! </dd></dl>

</div>
</div>
<a id="a8524712b2893a3b965e8f42d058b3fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8524712b2893a3b965e8f42d058b3fa7">&#9670;&nbsp;</a></span>CustomVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a padded custom vector of size <em>n</em> and capacity <em>nn</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the vector. </td></tr>
    <tr><td class="paramname">n</td><td>The number of array elements to be used by the custom vector. </td></tr>
    <tr><td class="paramname">nn</td><td>The maximum size of the given array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a padded custom vector of size <em>n</em> and capacity <em>nn</em>. The construction fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...);</li>
<li>... the specified capacity <em>nn</em> is insufficient for the given data type <em>Type</em> and the available instruction set.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is <b>NOT</b> available for unpadded custom vectors! </dd>
<dd>
The custom vector does <b>NOT</b> take responsibility for the given array of elements! </dd></dl>

</div>
</div>
<a id="aefec421f8b30baa6186ecd6b96ffb590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefec421f8b30baa6186ecd6b96ffb590">&#9670;&nbsp;</a></span>CustomVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor initializes the custom vector as an exact copy of the given custom vector. </p>

</div>
</div>
<a id="a602c0b0c5ff45a3313c3074e8274d14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602c0b0c5ff45a3313c3074e8274d14b">&#9670;&nbsp;</a></span>CustomVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move constructor for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be moved into this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3458944c83cf3dae7f272635aacf875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3458944c83cf3dae7f272635aacf875">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a3dace993e1fdeaf46fa91251793b7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dace993e1fdeaf46fa91251793b7b20">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a90083d26ec56ecaf75dbe1a1bfe188b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90083d26ec56ecaf75dbe1a1bfe188b7">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a3ccc70881ae0033f863f93bd1c0fb515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccc70881ae0033f863f93bd1c0fb515">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a950265827d5c8c989089e76ffa1b99f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950265827d5c8c989089e76ffa1b99f9">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ab9a7ac3e93de076e1762ea1ec55ec54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a7ac3e93de076e1762ea1ec55ec54e">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a3af4b2cad97ec05f09466378a6981844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af4b2cad97ec05f09466378a6981844">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae248c263531bcc40bed9c1f7863fdd59">Reference</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid vector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the subscript operator this function always performs a check of the given access index. </p>

</div>
</div>
<a id="ab73f8069b5c245f9bfea2a40fe5511e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73f8069b5c245f9bfea2a40fe5511e4">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7c4d836cf13c1377a92ac9b55f52dc4c">ConstReference</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid vector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the subscript operator this function always performs a check of the given access index. </p>

</div>
</div>
<a id="a343750fe0c29b3abc3c48bda917cee43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343750fe0c29b3abc3c48bda917cee43">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a445ff043bb703c01844c010a1e544f3c">Iterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the custom vector. </dd></dl>

</div>
</div>
<a id="a868d5f62ebb01013d8137f8e4571c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868d5f62ebb01013d8137f8e4571c17e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the custom vector. </dd></dl>

</div>
</div>
<a id="acf774a86bb8549a88d2ffcd372685d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf774a86bb8549a88d2ffcd372685d45">&#9670;&nbsp;</a></span>canAlias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the vector. In contrast to the <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a1edd8ca4778a221b3ff120e724861e7a" title="Returns whether the vector is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a id="a15215776c51376fd31eae588ba7f0bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15215776c51376fd31eae588ba7f0bbf">&#9670;&nbsp;</a></span>canSMPAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the vector can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current size of the vector). </p>

</div>
</div>
<a id="a7482c357a04ed1ad3258b2bb55c8aaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7482c357a04ed1ad3258b2bb55c8aaab">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum capacity of the vector. </dd></dl>

</div>
</div>
<a id="aadf748b277b3da49739873ed6c15e911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf748b277b3da49739873ed6c15e911">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the custom vector. </dd></dl>

</div>
</div>
<a id="a087e2e865927c24b29387d860b7af577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087e2e865927c24b29387d860b7af577">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the custom vector. </dd></dl>

</div>
</div>
<a id="aa36d44399f3edef2f489f0312deb599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36d44399f3edef2f489f0312deb599b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the vector to its default state. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default state. In case the vector has been passed the responsibility to manage the given array, it disposes the resource via the specified deleter. </p>

</div>
</div>
<a id="ae79cf668f1c4fd8e584d5dea9bb2709d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79cf668f1c4fd8e584d5dea9bb2709d">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#aa143f79745bd5ea884d4a69a391adce8">Pointer</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the custom vector. </p>

</div>
</div>
<a id="a682cfb2c618c04ce55d66fc2bc3e0d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682cfb2c618c04ce55d66fc2bc3e0d34">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a61a02c5d89b21a021d1149826465912a">ConstPointer</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the custom vector. </p>

</div>
</div>
<a id="aa1914321313e77eee836ed080feedf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1914321313e77eee836ed080feedf2a">&#9670;&nbsp;</a></span>divAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedDivAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::divAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the division assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ab36880b6f236e8187d8d42d26f84d204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36880b6f236e8187d8d42d26f84d204">&#9670;&nbsp;</a></span>divAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedDivAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::divAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the division assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a116ad04051f6412d5be473c35b0eeaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116ad04051f6412d5be473c35b0eeaea">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a445ff043bb703c01844c010a1e544f3c">Iterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the custom vector. </dd></dl>

</div>
</div>
<a id="a84398bfb341db99ea63ae3efdfe582bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84398bfb341db99ea63ae3efdfe582bf">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a33811b0f8b93f182bbd8efeef964c52f">ConstIterator</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the custom vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the custom vector. </dd></dl>

</div>
</div>
<a id="a1edd8ca4778a221b3ff120e724861e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edd8ca4778a221b3ff120e724861e7a">&#9670;&nbsp;</a></span>isAliased()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the vector. In contrast to the <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#acf774a86bb8549a88d2ffcd372685d45" title="Returns whether the vector can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a id="a31fe3602be7a478f5d073a418ade2026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe3602be7a478f5d073a418ade2026">&#9670;&nbsp;</a></span>isAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the vector is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of the vector are guaranteed to conform to the alignment restrictions of the element type <em>Type</em>. </p>

</div>
</div>
<a id="a74375e9548ef59547dadb33b59400b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74375e9548ef59547dadb33b59400b5a">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs a load of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="ae6c98657b4aa87f8e3650f72c87bd12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c98657b4aa87f8e3650f72c87bd12c">&#9670;&nbsp;</a></span>loada()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::loada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs an aligned load of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a4e9a95dc7346020f4aa4ccfb6eef4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9a95dc7346020f4aa4ccfb6eef4380">&#9670;&nbsp;</a></span>loadu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs an unaligned load of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a5ee0218ba15c5ad8988ed01ebf64b8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee0218ba15c5ad8988ed01ebf64b8a3">&#9670;&nbsp;</a></span>multAssign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a9779b5e7f8a3f4b1a30ccc0bb41d5280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9779b5e7f8a3f4b1a30ccc0bb41d5280">&#9670;&nbsp;</a></span>multAssign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a66ee575341d6e1e69c9ce2a7893af5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ee575341d6e1e69c9ce2a7893af5a3">&#9670;&nbsp;</a></span>multAssign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="af2e01237d2939a5466bd77a0702e7b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e01237d2939a5466bd77a0702e7b37">&#9670;&nbsp;</a></span>nonZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a id="a2320b4c3dc1a2ed4dda4f2c45424bb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2320b4c3dc1a2ed4dda4f2c45424bb71">&#9670;&nbsp;</a></span>operator%=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}\times=\vec{b} $" src="../../form_42.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current size of any of the two vectors is not equal to 3, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a27dbb4da350ef682bcab99bbfb326131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dbb4da350ef682bcab99bbfb326131">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_40.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a1fa6ca756bf46c71783e9fd9d92801c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa6ca756bf46c71783e9fd9d92801c9">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt; &gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_43.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>

</div>
</div>
<a id="a0569bf252f4f75b1ddccae66d881c140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0569bf252f4f75b1ddccae66d881c140">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_38.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="acd1724b554f9db254e381df7bedb3b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1724b554f9db254e381df7bedb3b73">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_39.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="ae101a6ec8ffd01b13e160bba2385043a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae101a6ec8ffd01b13e160bba2385043a">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a dense vector ( <img class="formulaInl" alt="$ \vec{a}/=\vec{b} $" src="../../form_41.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a108b74e73ac3e54a2b750d890cb7e473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108b74e73ac3e54a2b750d890cb7e473">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt; &gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_44.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="a29995a2b8b6be923e56200c41dc4343b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29995a2b8b6be923e56200c41dc4343b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>

</div>
</div>
<a id="a2676e7786c96ec8408bec0ee9e4f83ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2676e7786c96ec8408bec0ee9e4f83ef">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The initializer list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to custom vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly assign to all elements of the vector by means of an initializer list:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> blaze::unaliged;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> array[4] = { 1, 2, 3, 4 };</div><div class="line"></div><div class="line">CustomVector&lt;double,unaligned,unpadded&gt; v( array, 4UL );</div><div class="line">v = { 5, 6, 7 };</div></div><!-- fragment --><p>The vector elements are assigned the values from the given initializer list. Missing values are reset to their default state. Note that in case the size of the initializer list exceeds the size of the vector, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a97e56c0859da0e1e9929d67eaa8b77be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e56c0859da0e1e9929d67eaa8b77be">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The vector is initialized as a copy of the given vector. In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a2cfe9262634f0d6e6abe8df473710b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfe9262634f0d6e6abe8df473710b5b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html" title="Efficient implementation of a customizable vector. ">CustomVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The vector to be moved into this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>

</div>
</div>
<a id="a3b416ff2ad5b9c318a3af4f365c32d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b416ff2ad5b9c318a3af4f365c32d69">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>N-dimensional array for the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid array size.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly set all elements of the vector. The following example demonstrates this by means of an unaligned, unpadded custom vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> blaze::unaliged;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> array[4] = { 1, 2, 3, 4 };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> init[4]  = { 5, 6, 7 };</div><div class="line"></div><div class="line">CustomVector&lt;double,unaligned,unpadded&gt; v( array, 4UL );</div><div class="line">v = init;</div></div><!-- fragment --><p>The vector is assigned the values from the given array. Missing values are initialized with default values (as e.g. the fourth element in the example). Note that the size of the array must match the size of the custom vector. Otherwise a <em>std::invalid_argument</em> exception is thrown. Also note that after the assignment <em>array</em> will have the same entries as <em>init</em>. </p>

</div>
</div>
<a id="ad9cbb09d6511b35d76c868604c6f51d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cbb09d6511b35d76c868604c6f51d6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The vector is initialized as a copy of the given vector. In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a5795fcc7c394414feb937c095d6c7ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5795fcc7c394414feb937c095d6c7ed2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#ae248c263531bcc40bed9c1f7863fdd59">Reference</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>This function only performs an index check in case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active. In contrast, the <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3af4b2cad97ec05f09466378a6981844" title="Checked access to the vector elements. ">at()</a> function is guaranteed to perform a check of the given access index. </p>

</div>
</div>
<a id="a8c3778c719ee712688f377d489e312a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3778c719ee712688f377d489e312a2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt;::<a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a7c4d836cf13c1377a92ac9b55f52dc4c">ConstReference</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>This function only performs an index check in case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active. In contrast, the <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#a3af4b2cad97ec05f09466378a6981844" title="Checked access to the vector elements. ">at()</a> function is guaranteed to perform a check of the given access index. </p>

</div>
</div>
<a id="a7721338a0234a4dee3200733d8056e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7721338a0234a4dee3200733d8056e68">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a466fea61cee277be4dcad4276b298237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fea61cee277be4dcad4276b298237">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a4d0d09dbdf8c5e3159eb1f1db40674cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0d09dbdf8c5e3159eb1f1db40674cf">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ab5b714b17164bcd308e4397d922d6b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b714b17164bcd308e4397d922d6b01">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the custom vector and replaces the array of elements with the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the vector. </td></tr>
    <tr><td class="paramname">n</td><td>The number of array elements to be used by the custom vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the custom vector to the given array of elements of size <em>n</em>. The function fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...).</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This function is <b>NOT</b> available for padded custom vectors! </dd>
<dd>
In case a deleter was specified, the previously referenced array will only be destroyed when the last custom vector referencing the array goes out of scope. </dd>
<dd>
The custom vector does NOT take responsibility for the new array of elements! </dd></dl>

</div>
</div>
<a id="a15b8afeabf15f4f9334295de606d09f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b8afeabf15f4f9334295de606d09f6">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the custom vector and replaces the array of elements with the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the vector. </td></tr>
    <tr><td class="paramname">n</td><td>The number of array elements to be used by the custom vector. </td></tr>
    <tr><td class="paramname">nn</td><td>The maximum size of the given array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the custom vector to the given array of elements of size <em>n</em> and capacity <em>nn</em>. The function fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...);</li>
<li>... the specified capacity <em>nn</em> is insufficient for the given data type <em>Type</em> and the available instruction set.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This function is <em>NOT</em> available for unpadded custom vectors! </dd>
<dd>
In case a deleter was specified, the previously referenced array will only be destroyed when the last custom vector referencing the array goes out of scope. </dd>
<dd>
The custom vector does NOT take responsibility for the new array of elements! </dd></dl>

</div>
</div>
<a id="ac8db28ef07757b8957f2b5905c55d836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8db28ef07757b8957f2b5905c55d836">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;&amp; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the vector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p>This function scales the vector by applying the given scalar value <em>scalar</em> to each element of the vector. For built-in and <code>complex</code> data types it has the same effect as using the multiplication assignment operator:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> blaze::unaliged;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line">CustomVector&lt;double,unaligned,unpadded&gt; v( ... );</div><div class="line"></div><div class="line">a *= 4;        <span class="comment">// Scaling of the vector</span></div><div class="line">a.scale( 4 );  <span class="comment">// Same effect as above</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a37f791d580728ae1840805f03df1e8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f791d580728ae1840805f03df1e8d5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size/dimension of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a id="aa243da3ef6baa3c3dba28a21323e1a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243da3ef6baa3c3dba28a21323e1a4a">&#9670;&nbsp;</a></span>spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::spacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum capacity of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum capacity of the vector.</dd></dl>
<p>This function returns the minimum capacity of the vector, which corresponds to the current size plus padding. </p>

</div>
</div>
<a id="abdeb0c18ba84a90b73085aa7f56db710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdeb0c18ba84a90b73085aa7f56db710">&#9670;&nbsp;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs a store of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a937f103448f0edaf2f2d99f7d8633a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937f103448f0edaf2f2d99f7d8633a2b">&#9670;&nbsp;</a></span>storea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::storea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a8e69256271fe7345da93aefa8e054a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e69256271fe7345da93aefa8e054a19">&#9670;&nbsp;</a></span>storeu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="ad2b8b004e57b1dea57eb824afc3af616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8b004e57b1dea57eb824afc3af616">&#9670;&nbsp;</a></span>stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html#af53900968e11d02f800020b4af2a21cf">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store of a specific SIMD element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="ac70cdaf41933eed08b8d211a7dd6a1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70cdaf41933eed08b8d211a7dd6a1c0">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a1642029360cae3801d10964a2efb0427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1642029360cae3801d10964a2efb0427">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a372b9abaafac2779557337efcbae8769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372b9abaafac2779557337efcbae8769">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt;Type,AF,PF,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt; <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a67cfab6c7fc3ff1c37ba07a076baddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cfab6c7fc3ff1c37ba07a076baddfa">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">CustomVector</a>&lt; Type, AF, PF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a34655028254912e56383fce504793bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34655028254912e56383fce504793bc9">&#9670;&nbsp;</a></span>v_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool TF = defaultTransposeFlag&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>&lt; Type, AF, PF, TF &gt;::v_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The custom array of elements. </p>
<p>Access to the array of elements is gained via the subscript operator. The order of the elements is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ \end{array}\right)\]" src="../../form_46.png"/>
</p>
 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/dense/<a class="el" href="../../d6/db3/dense_2CustomVector_8h_source.html">CustomVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
