<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Math module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d3/d7d/group__adaptors"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7d/group__adaptors.html">Adaptors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/df9/group__blas"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/df9/group__blas.html">BLAS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d95/group__math__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html">Compile time constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d7a/group__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dcf/group__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/de5/group__functors"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de5/group__functors.html">Functors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d70/group__lapack"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d70/group__lapack.html">LAPACK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d9b/group__math__serialization"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9b/group__math__serialization.html">Serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d5b/group__math__shims"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html">Shims</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d7b/group__simd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/group__simd.html">SIMD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d00/group__smp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html">Shared memory parallelization module</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d92/group__math__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html">Expression traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d7b/group__math__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html">Type traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d48/group__views"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html">Views</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">blaze::NegativeAccuracy&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative computation accuracy for floating point data types.The <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative computation accuracy of the Blaze library for any floating point data type. In order to assign a negative accuracy value, the <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../da/d32/classblaze_1_1NegativeAccuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">blaze::Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> accuracy for floating point data types.The <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the computation accuracy of the Blaze library for any floating point data type. In order to assign an accuracy value, the <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle accuracy values conveniently, the global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance <a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> is provided, which can be used wherever a floating point data value is required.  <a href="../../d6/d75/classblaze_1_1Accuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">blaze::DenseIterator&lt; Type, AF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic iterator for dense vectors and matrices.The <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> represents a generic random-access iterator that can be used for dense vectors and specific rows/columns of dense matrices.  <a href="../../dc/de8/classblaze_1_1DenseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">blaze::NegativeEpsilon&lt; E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative epsilon value for floating point data types.The <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative smallest difference between two values of any floating point data type. In order to assign a negative epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../d9/d70/classblaze_1_1NegativeEpsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">blaze::Epsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical epsilon value for floating point data types.The <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the smallest difference between two values of any floating point data type. In order to assign an epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle epsilon values conveniently, the global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance <a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> is provided, which can be used wherever a floating point data type is required.  <a href="../../dd/d28/classblaze_1_1Epsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html">blaze::AddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all addition expression templates.The <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> class serves as a tag for all expression templates that implement mathematical additions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical addition (vector additions and matrix additions) and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as addition expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class, the <a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html" title="Compile time check whether the given type is an addition expression template.This type trait class te...">IsAddExpr</a> type trait recognizes the class as valid addition expression template.  <a href="../../d5/d2f/structblaze_1_1AddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d02/structblaze_1_1BinaryMapExpr.html">blaze::BinaryMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all for-each expression templates.The <a class="el" href="../../db/d02/structblaze_1_1BinaryMapExpr.html" title="Base class for all for-each expression templates.The BinaryMapExpr class serves as a tag for all expr...">BinaryMapExpr</a> class serves as a tag for all expression templates that represent a binary map operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a binary map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as binary map expression template. Only in case a class is derived publicly from the <a class="el" href="../../db/d02/structblaze_1_1BinaryMapExpr.html" title="Base class for all for-each expression templates.The BinaryMapExpr class serves as a tag for all expr...">BinaryMapExpr</a> base class, the <a class="el" href="../../d2/da4/structblaze_1_1IsBinaryMapExpr.html" title="Compile time check whether the given type is a binary map expression template.This type trait class t...">IsBinaryMapExpr</a> type trait recognizes the class as valid binary map expression template.  <a href="../../db/d02/structblaze_1_1BinaryMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html">blaze::Computation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all compute expression templates.The <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> class serves as a tag for all computational expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as computational expression template. Only in case a class is derived from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class, the <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html" title="Compile time check whether the given type is a computational expression template.This type trait clas...">IsComputation</a> type trait recognizes the class as valid computational expression template.  <a href="../../de/dd5/structblaze_1_1Computation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html">blaze::CrossExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all cross product expression templates.The <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> class serves as a tag for all expression templates that implement mathematical cross products. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical cross product and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as cross product expression template. Only in case a class is derived publicly from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class, the <a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html" title="Compile time check whether the given type is a cross product expression template.This type trait clas...">IsCrossExpr</a> type trait recognizes the class as valid cross product expression template.  <a href="../../dc/dc0/structblaze_1_1CrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da2/structblaze_1_1Declaration.html">blaze::Declaration&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declaration expression templates.The <a class="el" href="../../d2/da2/structblaze_1_1Declaration.html" title="Base class for all declaration expression templates.The Declaration class serves as a tag for all dec...">Declaration</a> class serves as a tag for all declaration expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes that represent a declaration and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as declaration expression template. Only in case a class is derived publicly from the <a class="el" href="../../d2/da2/structblaze_1_1Declaration.html" title="Base class for all declaration expression templates.The Declaration class serves as a tag for all dec...">Declaration</a> base class, the <a class="el" href="../../da/ddc/structblaze_1_1IsDeclaration.html" title="Compile time check whether the given type is a declaration expression template.This type trait class ...">IsDeclaration</a> type trait recognizes the class as valid declaration expression template.  <a href="../../d2/da2/structblaze_1_1Declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html">blaze::DeclDiagExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all decldiag expression templates.The <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> class serves as a tag for all expression templates that represent an explicit diagonal declaration (decldiag) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a decldiag operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as decldiag expression template. Only in case a class is derived publicly from the <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> base class, the <a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html" title="Compile time check whether the given type is a decldiag expression template.This type trait class tes...">IsDeclDiagExpr</a> type trait recognizes the class as valid decldiag expression template.  <a href="../../dd/d42/structblaze_1_1DeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html">blaze::DeclExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix for-each expression templates.The <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> class serves as a tag for all expression templates that represent an explicit declaration operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declaration operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as declaration expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> base class, the <a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html" title="Compile time check whether the given type is a declaration expression template.This type trait class ...">IsDeclExpr</a> type trait recognizes the class as valid declaration expression template.  <a href="../../d5/d56/structblaze_1_1DeclExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html">blaze::DeclHermExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declherm expression templates.The <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> class serves as a tag for all expression templates that represent an explicit Hermitian declaration (declherm) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declherm operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as declherm expression template. Only in case a class is derived publicly from the <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> base class, the <a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html" title="Compile time check whether the given type is a declherm expression template.This type trait class tes...">IsDeclHermExpr</a> type trait recognizes the class as valid declherm expression template.  <a href="../../dc/dc8/structblaze_1_1DeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html">blaze::DeclLowExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all decllow expression templates.The <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> class serves as a tag for all expression templates that represent an explicit lower declaration (decllow) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a decllow operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as decllow expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> base class, the <a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html" title="Compile time check whether the given type is a decllow expression template.This type trait class test...">IsDeclLowExpr</a> type trait recognizes the class as valid decllow expression template.  <a href="../../d0/d14/structblaze_1_1DeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html">blaze::DeclSymExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declsym expression templates.The <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> class serves as a tag for all expression templates that represent an explicit symmetry declaration (declsym) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declsym operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as declsym expression template. Only in case a class is derived publicly from the <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> base class, the <a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html" title="Compile time check whether the given type is a declsym expression template.This type trait class test...">IsDeclSymExpr</a> type trait recognizes the class as valid declsym expression template.  <a href="../../d8/db3/structblaze_1_1DeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html">blaze::DeclUppExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all declupp expression templates.The <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> class serves as a tag for all expression templates that represent an explicit upper declaration (declupp) operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a declupp operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as declupp expression template. Only in case class is derived publicly from the <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> base class, the <a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html" title="Compile time check whether the given type is a declupp expression template.This type trait class test...">IsDeclUppExpr</a> type trait a recognizes the class as valid declupp expression template.  <a href="../../d1/dcc/structblaze_1_1DeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html">blaze::DivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all division expression templates.The <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> class serves as a tag for all expression templates that implement mathematical divisions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical division (vector/vector divisions, vector/scalar divisions and matrix/scalar divisions) and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as division expression template. Only in case a class is derived publicly from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class, the <a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html" title="Compile time check whether the given type is a division expression template.This type trait class tes...">IsDivExpr</a> type trait recognizes the class as valid division expression template.  <a href="../../dd/d46/structblaze_1_1DivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html">blaze::EvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all evaluation expression templates.The <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> class serves as a tag for all expression templates that implement an evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent an evaluation operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class, the <a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html" title="Compile time check whether the given type is an evaluation expression template.This type trait class ...">IsEvalExpr</a> type trait recognizes the class as valid evaluation expression template.  <a href="../../db/d24/structblaze_1_1EvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html">blaze::Expression&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all expression templates.The <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> class is the base class for all expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes that represent an expression and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class, the <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html" title="Compile time check whether the given type is an expression template.This type trait class tests wheth...">IsExpression</a> type trait recognizes the class as valid expression template.  <a href="../../d5/d2e/structblaze_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html">blaze::MatEvalExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix evaluation expression templates.The <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> class serves as a tag for all expression templates that implement a matrix evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix evaluation operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class, the <a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html" title="Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type Type is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive publicly from the MatEvalExpr base class. In case the given type is a valid matrix evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatEvalExpr</a> type trait recognizes the class as valid matrix evaluation expression template.  <a href="../../d5/d77/structblaze_1_1MatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html">blaze::MatInvExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix inversion expression templates.The <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> class serves as a tag for all expression templates that implement a matrix inversion operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix inversion operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix inversion expression template. Only in case a class is derived publicly from the <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> base class, the <a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html" title="Compile time check whether the given type is a matrix inversion expression template.This type trait class tests whether or not the given type Type is a matrix inversion expression template. In order to qualify as a valid matrix inversion expression template, the given type has to derive publicly from the MatInvExpr base class. In case the given type is a valid matrix inversion expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatInvExpr</a> type trait recognizes the class as valid matrix inversion expression template.  <a href="../../d1/d0d/structblaze_1_1MatInvExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d02/structblaze_1_1MatMapExpr.html">blaze::MatMapExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all unary matrix map expression templates.The <a class="el" href="../../d4/d02/structblaze_1_1MatMapExpr.html" title="Base class for all unary matrix map expression templates.The MatMapExpr class serves as a tag for all...">MatMapExpr</a> class serves as a tag for all expression templates that represent a unary map operation on a matrix. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a unary matrix map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as unary matrix map expression template. Only in case a class is derived publicly from the <a class="el" href="../../d4/d02/structblaze_1_1MatMapExpr.html" title="Base class for all unary matrix map expression templates.The MatMapExpr class serves as a tag for all...">MatMapExpr</a> base class, the <a class="el" href="../../d7/d62/structblaze_1_1IsMatMapExpr.html" title="Compile time check whether the given type is a unary matrix map expression template.This type trait class tests whether or not the given type Type is a unary matrix map expression template. In order to qualify as a valid unary matrix map expression template, the given type has to derive publicly from the MatMapExpr base class. In case the given type is a valid unary matrix map expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatMapExpr</a> type trait recognizes the class as valid unary matrix map expression template.  <a href="../../d4/d02/structblaze_1_1MatMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html">blaze::MatMatAddExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix addition expression templates.The <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix addition. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix addition and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix addition expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class, the <a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html" title="Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type Type is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive publicly from the MatMatAddExpr base class. In case the given type is a valid matrix addition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatMatAddExpr</a> type trait recognizes the class as valid matrix addition expression template.  <a href="../../d0/dea/structblaze_1_1MatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dbb/structblaze_1_1MatMatMapExpr.html">blaze::MatMatMapExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all binary matrix map expression templates.The <a class="el" href="../../d7/dbb/structblaze_1_1MatMatMapExpr.html" title="Base class for all binary matrix map expression templates.The MatMatMapExpr class serves as a tag for...">MatMatMapExpr</a> class serves as a tag for all expression templates that implement a binary matrix map operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a binary matrix map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as binary matrix map expression template. Only in case a class is derived publicly from the <a class="el" href="../../d7/dbb/structblaze_1_1MatMatMapExpr.html" title="Base class for all binary matrix map expression templates.The MatMatMapExpr class serves as a tag for...">MatMatMapExpr</a> base class, the <a class="el" href="../../d3/d5a/structblaze_1_1IsMatMatMapExpr.html" title="Compile time check whether the given type is a binary matrix map expression template.This type trait class tests whether or not the given type Type is a binary matrix map expression template. In order to qualify as a valid binary matrix map expression template, the given type has to derive publicly from the MatMatMapExpr base class. In case the given type is a valid binary matrix map expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatMatMapExpr</a> type trait recognizes the class as valid binary matrix map expression template.  <a href="../../d7/dbb/structblaze_1_1MatMatMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html">blaze::MatMatMultExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix multiplication expression templates.The <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class, the <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html" title="Compile time check whether the given type is a matrix/matrix multiplication expression template...">IsMatMatMultExpr</a> type trait recognizes the class as valid matrix multiplication expression template.  <a href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html">blaze::MatMatSubExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix subtraction expression templates.The <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix subtraction. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix subtraction and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix subtraction expression template. Only in case a class is derived publicly from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class, the <a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html" title="Compile time check whether the given type is a matrix/matrix subtraction expression template...">IsMatMatSubExpr</a> type trait recognizes the class as valid matrix subtraction expression template.  <a href="../../db/dbd/structblaze_1_1MatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html">blaze::MatScalarDivExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar division expression templates.The <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar division expression templates.The MatScalarDivExpr class serves as a...">MatScalarDivExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar division. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/scalar division and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix/scalar division expression template. Only in case a class is derived publicly from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar division expression templates.The MatScalarDivExpr class serves as a...">MatScalarDivExpr</a> base class, the <a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html" title="Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type Type is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive publicly from the MatScalarDivExpr base class. In case the given type is a valid matrix/scalar division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatScalarDivExpr</a> type trait recognizes the class as valid matrix/scalar division expression template.  <a href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html">blaze::MatScalarMultExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar multiplication expression templates.The <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix/scalar multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class, the <a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html" title="Compile time check whether the given type is a matrix/scalar multiplication expression template...">IsMatScalarMultExpr</a> type trait recognizes the class as valid matrix/scalar multiplication expression template.  <a href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html">blaze::MatSerialExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix serial evaluation expression templates.The <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a matrix. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix serialization operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix serial evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class, the <a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html" title="Compile time check whether the given type is a matrix serial evaluation expression template...">IsMatSerialExpr</a> type trait recognizes the class as valid matrix serial evaluation expression template.  <a href="../../d6/d2f/structblaze_1_1MatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html">blaze::MatTransExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix transposition expression templates.The <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> class serves as a tag for all expression templates that implement a matrix transposition operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix transposition operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix transposition expression template. Only in case a class is derived publicly from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class, the <a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html" title="Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type Type is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive publicly from the MatTransExpr base class. In case the given type is a valid matrix transposition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMatTransExpr</a> type trait recognizes the class as valid matrix transposition expression template.  <a href="../../d7/d54/structblaze_1_1MatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html">blaze::MatVecMultExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/vector multiplication expression templates.The <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> class serves as a tag for all expression templates that implement a matrix/vector multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a matrix/vector multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as matrix/vector multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class, the <a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html" title="Compile time check whether the given type is a matrix/vector multiplication expression template...">IsMatVecMultExpr</a> type trait recognizes the class as valid matrix/vector multiplication expression template.  <a href="../../db/de7/structblaze_1_1MatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html">blaze::MultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all multiplication expression templates.The <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> class serves as a tag for all expression templates that implement mathematical multiplications. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical multiplication (element-wise vector multiplications, matrix/vector multiplications, vector/matrix multiplications and matrix/matrix multiplications) and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class, the <a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html" title="Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type Type is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive publicly from the MultExpr base class. In case the given type is a valid multiplication expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsMultExpr</a> type trait recognizes the class as valid multiplication expression template.  <a href="../../df/dfd/structblaze_1_1MultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d53/structblaze_1_1Operation.html">blaze::Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all operational expression templates.The <a class="el" href="../../d9/d53/structblaze_1_1Operation.html" title="Base class for all operational expression templates.The Operation class serves as a tag for all opera...">Operation</a> class serves as a tag for all operational expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes that represent either a transformation (transpositions, ...) or a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as operational expression template. Only in case a class is derived from the <a class="el" href="../../d9/d53/structblaze_1_1Operation.html" title="Base class for all operational expression templates.The Operation class serves as a tag for all opera...">Operation</a> base class, the <a class="el" href="../../d0/db0/structblaze_1_1IsOperation.html" title="Compile time check whether the given type is an operational expression template.This type trait class...">IsOperation</a> type trait recognizes the class as valid operational expression template.  <a href="../../d9/d53/structblaze_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/structblaze_1_1SchurExpr.html">blaze::SchurExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all Schur product expression templates.The <a class="el" href="../../d0/d24/structblaze_1_1SchurExpr.html" title="Base class for all Schur product expression templates.The SchurExpr class serves as a tag for all exp...">SchurExpr</a> class serves as a tag for all expression templates that implement mathematical Schur products. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical Schur product and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as Schur product expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/d24/structblaze_1_1SchurExpr.html" title="Base class for all Schur product expression templates.The SchurExpr class serves as a tag for all exp...">SchurExpr</a> base class, the <a class="el" href="../../d4/d7c/structblaze_1_1IsSchurExpr.html" title="Compile time check whether the given type is a Schur product expression template.This type trait clas...">IsSchurExpr</a> type trait recognizes the class as valid Schur product expression template.  <a href="../../d0/d24/structblaze_1_1SchurExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html">blaze::SerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all serial evaluation expression templates.The <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a serialization operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as serial evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class, the <a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html" title="Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type Type is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive publicly from the SerialExpr base class. In case the given type is a valid serial evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsSerialExpr</a> type trait recognizes the class as valid serial evaluation expression template.  <a href="../../d5/d7c/structblaze_1_1SerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html">blaze::SubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all subtraction expression templates.The <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> class serves as a tag for all expression templates that implement mathematical subtractions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical subtraction (vector subtractions and matrix subtractions) and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as subtraction expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class, the <a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html" title="Compile time check whether the given type is a subtraction expression template.This type trait class ...">IsSubExpr</a> type trait recognizes the class as valid subtraction expression template.  <a href="../../d0/d7a/structblaze_1_1SubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html">blaze::TransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all transposition expression templates.The <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> class serves as a tag for all expression templates that implement mathematical transpositions. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical transposition (vector transpositions and matrix transpositions) and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as transposition expression template. Only in case a class is derived publicly from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class, the <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html" title="Compile time check whether the given type is a transposition expression template.This type trait clas...">IsTransExpr</a> type trait recognizes the class as valid transposition expression template.  <a href="../../dd/dfe/structblaze_1_1TransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d0a/structblaze_1_1Transformation.html">blaze::Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all transform expression templates.The <a class="el" href="../../d1/d0a/structblaze_1_1Transformation.html" title="Base class for all transform expression templates.The Transformation class serves as a tag for all tr...">Transformation</a> class serves as a tag for all transformation expression templates. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a transformation (e.g. transpositions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as transformation expression template. Only in case a class is derived from the <a class="el" href="../../d1/d0a/structblaze_1_1Transformation.html" title="Base class for all transform expression templates.The Transformation class serves as a tag for all tr...">Transformation</a> base class, the <a class="el" href="../../da/d9b/structblaze_1_1IsTransformation.html" title="Compile time check whether the given type is a transformation expression template.This type trait class tests whether the given type Type is a transformation expression template (e.g. a transpose operation). In order to qualify as a valid transformation expression template, the given type has to derive (publicly or privately) from the Transformation base class. In case the given type is a valid transformation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsTransformation</a> type trait recognizes the class as valid transformation expression template.  <a href="../../d1/d0a/structblaze_1_1Transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html">blaze::TVecMatMultExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/matrix multiplication expression templates.The <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> class serves as a tag for all expression templates that implement a vector/matrix multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/matrix multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector/matrix multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class, the <a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html" title="Compile time check whether the given type is a vector/matrix multiplication expression template...">IsTVecMatMultExpr</a> type trait recognizes the class as valid vector/matrix multiplication expression template.  <a href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d87/structblaze_1_1UnaryMapExpr.html">blaze::UnaryMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all for-each expression templates.The <a class="el" href="../../d0/d87/structblaze_1_1UnaryMapExpr.html" title="Base class for all for-each expression templates.The UnaryMapExpr class serves as a tag for all expre...">UnaryMapExpr</a> class serves as a tag for all expression templates that represent a unary map operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a unary map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as unary map expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/d87/structblaze_1_1UnaryMapExpr.html" title="Base class for all for-each expression templates.The UnaryMapExpr class serves as a tag for all expre...">UnaryMapExpr</a> base class, the <a class="el" href="../../d8/d71/structblaze_1_1IsUnaryMapExpr.html" title="Compile time check whether the given type is a unary map expression template.This type trait class te...">IsUnaryMapExpr</a> type trait recognizes the class as valid unary map expression template.  <a href="../../d0/d87/structblaze_1_1UnaryMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html">blaze::VecEvalExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector evaluation expression templates.The <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> class serves as a tag for all expression templates that implement a vector evaluation operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector evaluation operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class, the <a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html" title="Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type Type is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive publicly from the VecEvalExpr base class. In case the given type is a valid vector evaluation expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecEvalExpr</a> type trait recognizes the class as valid vector evaluation expression template.  <a href="../../da/d95/structblaze_1_1VecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d4d/structblaze_1_1VecMapExpr.html">blaze::VecMapExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all unary vector map expression templates.The <a class="el" href="../../da/d4d/structblaze_1_1VecMapExpr.html" title="Base class for all unary vector map expression templates.The VecMapExpr class serves as a tag for all...">VecMapExpr</a> class serves as a tag for all expression templates that represent a unary map operation on a vector. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a unary vector map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as unary vector map expression template. Only in case a class is derived publicly from the <a class="el" href="../../da/d4d/structblaze_1_1VecMapExpr.html" title="Base class for all unary vector map expression templates.The VecMapExpr class serves as a tag for all...">VecMapExpr</a> base class, the <a class="el" href="../../de/dcd/structblaze_1_1IsVecMapExpr.html" title="Compile time check whether the given type is a unary vector map expression template.This type trait class tests whether or not the given type Type is a unary vector map expression template. In order to qualify as a valid unary vector map expression template, the given type has to derive publicly from the VecMapExpr base class. In case the given type is a valid unary vector map expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecMapExpr</a> type trait recognizes the class as valid unary vector map expression template.  <a href="../../da/d4d/structblaze_1_1VecMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html">blaze::VecScalarDivExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar division expression templates.The <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> class serves as a tag for all expression templates that implement a vector/scalar division. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/scalar division and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector/scalar division expression template. Only in case a class is derived publicly from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class, the <a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html" title="Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type Type is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive publicly from the VecScalarDivExpr base class. In case the given type is a valid vector/scalar division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecScalarDivExpr</a> type trait recognizes the class as valid vector/scalar division expression template.  <a href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html">blaze::VecScalarMultExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar multiplication expression templates.The <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> class serves as a tag for all expression templates that implement a vector/scalar multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector/scalar multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class, the <a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html" title="Compile time check whether the given type is a vector/scalar multiplication expression template...">IsVecScalarMultExpr</a> type trait recognizes the class as valid vector/scalar multiplication expression template.  <a href="../../df/d01/structblaze_1_1VecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html">blaze::VecSerialExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector serial evaluation expression templates.The <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a vector. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector serialization operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector serial evaluation expression template. Only in case a class is derived publicly from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class, the <a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html" title="Compile time check whether the given type is a vector serial evaluation expression template...">IsVecSerialExpr</a> type trait recognizes the class as valid vector serial evaluation expression template.  <a href="../../d8/dfb/structblaze_1_1VecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html">blaze::VecTransExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector transposition expression templates.The <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> class serves as a tag for all expression templates that implement a vector transposition operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector transposition operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector transposition expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class, the <a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html" title="Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type Type is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive publicly from the VecTransExpr base class. In case the given type is a valid vector transposition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecTransExpr</a> type trait recognizes the class as valid vector transposition expression template.  <a href="../../d0/dec/structblaze_1_1VecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html">blaze::VecTVecMultExpr&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all outer product expression templates.The <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> class serves as a tag for all expression templates that implement mathematical outer products (i.e. multiplications between a column vector and a row vector). <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a mathematical outer product and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as outer product expression template. Only in case a class is derived publicly from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class, the <a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html" title="Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type Type is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive publicly from the VecTVecMultExpr base class. In case the given type is a valid outer product expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecTVecMultExpr</a> type trait recognizes the class as valid outer product expression template.  <a href="../../de/d08/structblaze_1_1VecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html">blaze::VecVecAddExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector addition expression templates.The <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> class serves as a tag for all expression templates that implement a vector/vector addition. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector addition and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector addition expression template. Only in case a class is derived publicly from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class, the <a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html" title="Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type Type is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive publicly from the VecVecAddExpr base class. In case the given type is a valid vector addition expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecVecAddExpr</a> type trait recognizes the class as valid vector addition expression template.  <a href="../../d0/d58/structblaze_1_1VecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html">blaze::VecVecDivExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector division expression templates.The <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> class serves as a tag for all expression templates that implement a vector/vector division. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector division and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector division expression template. Only in case a class is derived publicly from the <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> base class, the <a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html" title="Compile time check whether the given type is a vector/vector division expression template.This type trait class tests whether or not the given type Type is a vector/vector division expression template. In order to qualify as a valid vector division expression template, the given type has to derive publicly from the VecVecDivExpr base class. In case the given type is a valid vector division expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecVecDivExpr</a> type trait recognizes the class as valid vector division expression template.  <a href="../../de/dc6/structblaze_1_1VecVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/structblaze_1_1VecVecMapExpr.html">blaze::VecVecMapExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all binary vector map expression templates.The <a class="el" href="../../d9/d3c/structblaze_1_1VecVecMapExpr.html" title="Base class for all binary vector map expression templates.The VecVecMapExpr class serves as a tag for...">VecVecMapExpr</a> class serves as a tag for all expression templates that implement a binary vector map operation. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a binary vector map operation and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as binary vector map expression template. Only in case a class is derived publicly from the <a class="el" href="../../d9/d3c/structblaze_1_1VecVecMapExpr.html" title="Base class for all binary vector map expression templates.The VecVecMapExpr class serves as a tag for...">VecVecMapExpr</a> base class, the <a class="el" href="../../d7/d29/structblaze_1_1IsVecVecMapExpr.html" title="Compile time check whether the given type is a binary vector map expression template.This type trait class tests whether or not the given type Type is a binary vector map expression template. In order to qualify as a valid binary vector map expression template, the given type has to derive publicly from the VecVecMapExpr base class. In case the given type is a valid binary vector map expression template, the value member constant is set to true, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to false, Type is FalseType, and the class derives from FalseType. ">IsVecVecMapExpr</a> type trait recognizes the class as valid binary vector map expression template.  <a href="../../d9/d3c/structblaze_1_1VecVecMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html">blaze::VecVecMultExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector multiplication expression templates.The <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> class serves as a tag for all expression templates that implement a vector/vector multiplication. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector multiplication and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector multiplication expression template. Only in case a class is derived publicly from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class, the <a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html" title="Compile time check whether the given type is a vector/vector multiplication expression template...">IsVecVecMultExpr</a> type trait recognizes the class as valid vector multiplication expression template.  <a href="../../df/d10/structblaze_1_1VecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html">blaze::VecVecSubExpr&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector subtraction expression templates.The <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> class serves as a tag for all expression templates that implement a vector/vector subtraction. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes, that represent a vector subtraction and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as vector subtraction expression template. Only in case a class is derived publicly from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class, the <a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html" title="Compile time check whether the given type is a vector/vector subtraction expression template...">IsVecVecSubExpr</a> type trait recognizes the class as valid vector subtraction expression template.  <a href="../../d1/d87/structblaze_1_1VecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dae/structblaze_1_1View.html">blaze::View&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all views.The <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as a view. Only in case a class is derived publicly from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> classes that represent a view and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as a view. Only in case a class is derived publicly from the <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive publicly from this class in order to qualify as a view. Only in case a class is derived publicly from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> base class, the <a class="el" href="../../da/dbb/structblaze_1_1IsView.html" title="Compile time check for views.This type trait tests whether or not the given template parameter is a v...">IsView</a> type trait recognizes the class as valid view.  <a href="../../d4/dae/structblaze_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">blaze::NegativeInfinity&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity for built-in data types.The <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possibility to assign negative infinity values to built-in data types. As negative infinity value, the largest possible negative value of the corresponding data type is used. In order to assign the negative infinity value, the <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class can be implicitly converted to all signed integral and floating point data types:  <a href="../../db/da3/classblaze_1_1NegativeInfinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dff/classblaze_1_1Infinity.html">blaze::Infinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity for built-in data types.The <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possiblity to assign a positive infinity value to built-in data types. As positive infinity value, the largest possible positive value of the corresponding data type is used. In order to assign the positive infinity value, the <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class can be implicitly converted to the following 13 built-in integral and floating point data types:  <a href="../../da/dff/classblaze_1_1Infinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html">blaze::ComplexProxy&lt; PT, CT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for complex types.The <a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html" title="Proxy backend for complex types.The ComplexProxy class serves as a backend for the Proxy class...">ComplexProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a complex number and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of complex numbers.  <a href="../../d3/d8e/classblaze_1_1ComplexProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html">blaze::DefaultProxy&lt; PT, RT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default proxy backend for built-in and alternate user-specific class types.The <a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html" title="Default proxy backend for built-in and alternate user-specific class types.The DefaultProxy class ser...">DefaultProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a built-in or alternate user-specific class type. This proxy does not augment the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by any additional interface.  <a href="../../df/d30/classblaze_1_1DefaultProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">blaze::DenseMatrixProxy&lt; PT, MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense matrix types.The <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html" title="Proxy backend for dense matrix types.The DenseMatrixProxy class serves as a backend for the Proxy cla...">DenseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense matrices.  <a href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">blaze::DenseVectorProxy&lt; PT, VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense vector types.The <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html" title="Proxy backend for dense vector types.The DenseVectorProxy class serves as a backend for the Proxy cla...">DenseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense vectors.  <a href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html">blaze::Proxy&lt; PT, RT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> base class.The <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class is a base class for all proxy classes within the <b>Blaze</b> library that may represent non-numeric data types (vectors, matrices, ...). It augments the interface of the deriving proxy class depending on the data type represented by the proxy. In addition, it provides an abstraction from the actual type of the proxy, but enables a type-safe conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../de/df9/classblaze_1_1Proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy&lt; PT, MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse matrix types.The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html" title="Proxy backend for sparse matrix types.The SparseMatrixProxy class serves as a backend for the Proxy c...">SparseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse matrices.  <a href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy&lt; PT, VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse vector types.The <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html" title="Proxy backend for sparse vector types.The SparseVectorProxy class serves as a backend for the Proxy c...">SparseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse vectors.  <a href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db5/structblaze_1_1SparseElement.html">blaze::SparseElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all sparse element types.The <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> class is the base class for all sparse element types. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> types that conceptually represent a sparse vector or matrix element and that provide a <code>value()</code> and an <code>index()</code> member function have to derive from this class in order to qualify as sparse element. Only in case a class is derived from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class, the <a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html" title="Compile time check whether the given type is a sparse element type.This type trait class tests whethe...">IsSparseElement</a> type trait recognizes the class as valid sparse element.  <a href="../../db/db5/structblaze_1_1SparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html">blaze::ValueIndexPair&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-value-pair for sparse vectors and matrices.The <a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html" title="Index-value-pair for sparse vectors and matrices.The ValueIndexPair class represents a single index-v...">ValueIndexPair</a> class represents a single index-value-pair of a sparse vector or sparse matrix.  <a href="../../db/dc7/classblaze_1_1ValueIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">blaze::initializer_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list type of the Blaze library.  <a href="../../d8/dd9/classblaze_1_1initializer__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga090953147f8df6ac6a13b15403d51dcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga090953147f8df6ac6a13b15403d51dcf">BLAZE_THROW_DIVISION_BY_ZERO</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga2d588d35b3322949abb3a1e1c5ea3355">BLAZE_THROW_RUNTIME_ERROR</a>( MESSAGE )</td></tr>
<tr class="memdesc:ga090953147f8df6ac6a13b15403d51dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of an exception on detection of a division by zero.This macro encapsulates the default way of <b>Blaze</b> to throw an exception on detection of a division by zero. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#ga090953147f8df6ac6a13b15403d51dcf">More...</a><br /></td></tr>
<tr class="separator:ga090953147f8df6ac6a13b15403d51dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae8e50beff90b25ee70e807154f350f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafae8e50beff90b25ee70e807154f350f">BLAZE_THROW_LAPACK_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga2d588d35b3322949abb3a1e1c5ea3355">BLAZE_THROW_RUNTIME_ERROR</a>( MESSAGE )</td></tr>
<tr class="memdesc:gafae8e50beff90b25ee70e807154f350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of an exception on detection of a LAPACK error.This macro encapsulates the default way of <b>Blaze</b> to throw an exception when encountering a LAPACK error (for instance when trying to invert a singular matrix). Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#gafae8e50beff90b25ee70e807154f350f">More...</a><br /></td></tr>
<tr class="separator:gafae8e50beff90b25ee70e807154f350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga629e225abfa7be1f41cff40ecd17d5d5">blaze::InversionFlag</a> { <br />
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402">blaze::byLU</a> = 0, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6">blaze::byLDLT</a> = 1, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb">blaze::byLDLH</a> = 2, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2">blaze::byLLH</a> = 3, 
<br />
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce">blaze::asGeneral</a> = 4, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1">blaze::asSymmetric</a> = 5, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090">blaze::asHermitian</a> = 6, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e">blaze::asLower</a> = 7, 
<br />
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232">blaze::asUniLower</a> = 8, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97">blaze::asUpper</a> = 9, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826">blaze::asUniUpper</a> = 10, 
<a class="el" href="../../de/df1/group__math.html#gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5">blaze::asDiagonal</a> = 11
<br />
 }<tr class="memdesc:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion flag.The InversionFlag type enumeration represents the different types of matrix inversion algorithms that are available within the Blaze library. The following flags are available:  <a href="../../de/df1/group__math.html#ga629e225abfa7be1f41cff40ecd17d5d5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga629e225abfa7be1f41cff40ecd17d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab1425959f644eecd4d8a17f4c3b3220a">blaze::determineColumns</a> (<a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; <a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; &gt; list) noexcept</td></tr>
<tr class="memdesc:gab1425959f644eecd4d8a17f4c3b3220a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the maximum number of columns specified by the given initializer list.  <a href="../../de/df1/group__math.html#gab1425959f644eecd4d8a17f4c3b3220a">More...</a><br /></td></tr>
<tr class="separator:gab1425959f644eecd4d8a17f4c3b3220a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d47826408e31a3384c39360dee2344"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename &gt; </td></tr>
<tr class="memitem:gaa3d47826408e31a3384c39360dee2344"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa3d47826408e31a3384c39360dee2344">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa3d47826408e31a3384c39360dee2344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gaa3d47826408e31a3384c39360dee2344">More...</a><br /></td></tr>
<tr class="separator:gaa3d47826408e31a3384c39360dee2344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a60a1b44ec5ab81f86a4d50949b23c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa6a60a1b44ec5ab81f86a4d50949b23c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa6a60a1b44ec5ab81f86a4d50949b23c">blaze::erf</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa6a60a1b44ec5ab81f86a4d50949b23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the error function of the represented element.  <a href="../../de/df1/group__math.html#gaa6a60a1b44ec5ab81f86a4d50949b23c">More...</a><br /></td></tr>
<tr class="separator:gaa6a60a1b44ec5ab81f86a4d50949b23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d01823fadc543da32b2fccb1185d4b7"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga0d01823fadc543da32b2fccb1185d4b7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0d01823fadc543da32b2fccb1185d4b7">blaze::erfc</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga0d01823fadc543da32b2fccb1185d4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the complementary error function of the represented element.  <a href="../../de/df1/group__math.html#ga0d01823fadc543da32b2fccb1185d4b7">More...</a><br /></td></tr>
<tr class="separator:ga0d01823fadc543da32b2fccb1185d4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae5273b2715d3354c16d049d1313f7e72"><td class="memItemLeft" align="right" valign="top"><a id="gae5273b2715d3354c16d049d1313f7e72"></a>
constexpr <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72">blaze::accuracy</a></td></tr>
<tr class="memdesc:gae5273b2715d3354c16d049d1313f7e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance.The <a class="el" href="../../de/df1/group__math.html#gae5273b2715d3354c16d049d1313f7e72" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the computation accuracy of the Blaze library for the according data type. <br /></td></tr>
<tr class="separator:gae5273b2715d3354c16d049d1313f7e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c0db94efdf35b9bf1834ace9c48177"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a> = false</td></tr>
<tr class="memdesc:gaa4c0db94efdf35b9bf1834ace9c48177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment flag for unaligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as unaligned. The following example demonstrates the setup of an unaligned subvector:  <a href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">More...</a><br /></td></tr>
<tr class="separator:gaa4c0db94efdf35b9bf1834ace9c48177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02fbb3ef9a09baf0b5e7b32a55cf6c7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a> = true</td></tr>
<tr class="memdesc:gac02fbb3ef9a09baf0b5e7b32a55cf6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment flag for aligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned subvector:  <a href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">More...</a><br /></td></tr>
<tr class="separator:gac02fbb3ef9a09baf0b5e7b32a55cf6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7691c4cf9181e1f56571cf39d785cf3"><td class="memItemLeft" align="right" valign="top"><a id="gad7691c4cf9181e1f56571cf39d785cf3"></a>
constexpr <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3">blaze::epsilon</a></td></tr>
<tr class="memdesc:gad7691c4cf9181e1f56571cf39d785cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance.The <a class="el" href="../../de/df1/group__math.html#gad7691c4cf9181e1f56571cf39d785cf3" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the smallest possible difference between two values of the according data type. <br /></td></tr>
<tr class="separator:gad7691c4cf9181e1f56571cf39d785cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="memItemLeft" align="right" valign="top"><a id="ga3096c2ff9c7323a2d390af40c1c18a66"></a>
constexpr <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3096c2ff9c7323a2d390af40c1c18a66">blaze::inf</a></td></tr>
<tr class="memdesc:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga3096c2ff9c7323a2d390af40c1c18a66" title="Global Infinity instance.The blaze::inf instance can be used wherever a built-in data type is expecte...">blaze::inf</a> instance can be used wherever a built-in data type is expected. It is implicitly converted to the corresponding built-in data type and represents its largest possible data value. <br /></td></tr>
<tr class="separator:ga3096c2ff9c7323a2d390af40c1c18a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1858f68dbe5aba0ded4e45358324e3a1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a> = false</td></tr>
<tr class="memdesc:ga1858f68dbe5aba0ded4e45358324e3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding flag for unpadded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as unpadded. The following example demonstrates the setup of an unaligned, unpadded custom column vector of size 7:  <a href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">More...</a><br /></td></tr>
<tr class="separator:ga1858f68dbe5aba0ded4e45358324e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2acdda4ff7a369ef66302e647ff0926f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a> = true</td></tr>
<tr class="memdesc:ga2acdda4ff7a369ef66302e647ff0926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding flag for padded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned, padded custom column vector of size 7:  <a href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">More...</a><br /></td></tr>
<tr class="separator:ga2acdda4ff7a369ef66302e647ff0926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeAccuracy operators</h2></td></tr>
<tr class="memitem:ga4c532eb39351f805537decf26b3d5fcd"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga4c532eb39351f805537decf26b3d5fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4c532eb39351f805537decf26b3d5fcd">blaze::operator==</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga4c532eb39351f805537decf26b3d5fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga4c532eb39351f805537decf26b3d5fcd">More...</a><br /></td></tr>
<tr class="separator:ga4c532eb39351f805537decf26b3d5fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga236d08a02441df8ea0dbbb4c64749da4">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga236d08a02441df8ea0dbbb4c64749da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga236d08a02441df8ea0dbbb4c64749da4">More...</a><br /></td></tr>
<tr class="separator:ga236d08a02441df8ea0dbbb4c64749da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac9163704380fe239f92c9aa2a2d21d2d">blaze::operator!=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac9163704380fe239f92c9aa2a2d21d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gac9163704380fe239f92c9aa2a2d21d2d">More...</a><br /></td></tr>
<tr class="separator:gac9163704380fe239f92c9aa2a2d21d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e43d75015d84e3173a1353446944a04"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga4e43d75015d84e3173a1353446944a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4e43d75015d84e3173a1353446944a04">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga4e43d75015d84e3173a1353446944a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga4e43d75015d84e3173a1353446944a04">More...</a><br /></td></tr>
<tr class="separator:ga4e43d75015d84e3173a1353446944a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beb59e8da6cadd29439976ad27ef720"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga9beb59e8da6cadd29439976ad27ef720"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9beb59e8da6cadd29439976ad27ef720">blaze::operator&lt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga9beb59e8da6cadd29439976ad27ef720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga9beb59e8da6cadd29439976ad27ef720">More...</a><br /></td></tr>
<tr class="separator:ga9beb59e8da6cadd29439976ad27ef720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c48a6793a1ffbabed19269784797d09"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga3c48a6793a1ffbabed19269784797d09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3c48a6793a1ffbabed19269784797d09">blaze::operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga3c48a6793a1ffbabed19269784797d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga3c48a6793a1ffbabed19269784797d09">More...</a><br /></td></tr>
<tr class="separator:ga3c48a6793a1ffbabed19269784797d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c770742f7a66f838d35eff174546c6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga29c770742f7a66f838d35eff174546c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga29c770742f7a66f838d35eff174546c6">blaze::operator&gt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga29c770742f7a66f838d35eff174546c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga29c770742f7a66f838d35eff174546c6">More...</a><br /></td></tr>
<tr class="separator:ga29c770742f7a66f838d35eff174546c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c43f45835f32b4189017f2010c9f638"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga0c43f45835f32b4189017f2010c9f638"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c43f45835f32b4189017f2010c9f638">blaze::operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga0c43f45835f32b4189017f2010c9f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga0c43f45835f32b4189017f2010c9f638">More...</a><br /></td></tr>
<tr class="separator:ga0c43f45835f32b4189017f2010c9f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accuracy operators</h2></td></tr>
<tr class="memitem:ga901136b2bc679e7d3292cce75f539d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga901136b2bc679e7d3292cce75f539d63"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga901136b2bc679e7d3292cce75f539d63">blaze::operator==</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga901136b2bc679e7d3292cce75f539d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga901136b2bc679e7d3292cce75f539d63">More...</a><br /></td></tr>
<tr class="separator:ga901136b2bc679e7d3292cce75f539d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4fa7f20ac7fdbf6e0cc1d2a781902a9c">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga4fa7f20ac7fdbf6e0cc1d2a781902a9c">More...</a><br /></td></tr>
<tr class="separator:ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18da095de4af19e5b2dd2652d4e99783"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga18da095de4af19e5b2dd2652d4e99783"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga18da095de4af19e5b2dd2652d4e99783">blaze::operator!=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga18da095de4af19e5b2dd2652d4e99783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga18da095de4af19e5b2dd2652d4e99783">More...</a><br /></td></tr>
<tr class="separator:ga18da095de4af19e5b2dd2652d4e99783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d846866633d891a651d1ca34abcd51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2d846866633d891a651d1ca34abcd51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf2d846866633d891a651d1ca34abcd51">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gaf2d846866633d891a651d1ca34abcd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gaf2d846866633d891a651d1ca34abcd51">More...</a><br /></td></tr>
<tr class="separator:gaf2d846866633d891a651d1ca34abcd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga361e2f13326df36b40c3ac8fbc1ab6e5">blaze::operator&lt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga361e2f13326df36b40c3ac8fbc1ab6e5">More...</a><br /></td></tr>
<tr class="separator:ga361e2f13326df36b40c3ac8fbc1ab6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa803d7476965f7923e5c0c4245d7924a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa803d7476965f7923e5c0c4245d7924a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa803d7476965f7923e5c0c4245d7924a">blaze::operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gaa803d7476965f7923e5c0c4245d7924a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gaa803d7476965f7923e5c0c4245d7924a">More...</a><br /></td></tr>
<tr class="separator:gaa803d7476965f7923e5c0c4245d7924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1539c7210c9d84eec0632d388022e57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1539c7210c9d84eec0632d388022e57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab1539c7210c9d84eec0632d388022e57">blaze::operator&gt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab1539c7210c9d84eec0632d388022e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gab1539c7210c9d84eec0632d388022e57">More...</a><br /></td></tr>
<tr class="separator:gab1539c7210c9d84eec0632d388022e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga892e97c8cb377a8f1f00ae8c451a2681">blaze::operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga892e97c8cb377a8f1f00ae8c451a2681">More...</a><br /></td></tr>
<tr class="separator:ga892e97c8cb377a8f1f00ae8c451a2681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cec7da9b31a13bb88d11dcdc7b66acf">blaze::operator&lt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga3cec7da9b31a13bb88d11dcdc7b66acf">More...</a><br /></td></tr>
<tr class="separator:ga3cec7da9b31a13bb88d11dcdc7b66acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga029ffd5d821432bad2f6145a8a08ab61">blaze::operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga029ffd5d821432bad2f6145a8a08ab61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga029ffd5d821432bad2f6145a8a08ab61">More...</a><br /></td></tr>
<tr class="separator:ga029ffd5d821432bad2f6145a8a08ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga47be5bbb98c25b6050f72022c7a1a353">blaze::operator&gt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga47be5bbb98c25b6050f72022c7a1a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga47be5bbb98c25b6050f72022c7a1a353">More...</a><br /></td></tr>
<tr class="separator:ga47be5bbb98c25b6050f72022c7a1a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga68791a44cbc4c754a1196485fa3a9a37">blaze::operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga68791a44cbc4c754a1196485fa3a9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga68791a44cbc4c754a1196485fa3a9a37">More...</a><br /></td></tr>
<tr class="separator:ga68791a44cbc4c754a1196485fa3a9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeEpsilon operators</h2></td></tr>
<tr class="memitem:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf07f5f4affa2e7b19de28dca9c35db6b">blaze::operator==</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaf07f5f4affa2e7b19de28dca9c35db6b">More...</a><br /></td></tr>
<tr class="separator:gaf07f5f4affa2e7b19de28dca9c35db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a179498d07d4ec942a451ae92ec143"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga51a179498d07d4ec942a451ae92ec143"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51a179498d07d4ec942a451ae92ec143">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga51a179498d07d4ec942a451ae92ec143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga51a179498d07d4ec942a451ae92ec143">More...</a><br /></td></tr>
<tr class="separator:ga51a179498d07d4ec942a451ae92ec143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54487f79ea60723216b11c6fb0320286"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga54487f79ea60723216b11c6fb0320286"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga54487f79ea60723216b11c6fb0320286">blaze::operator!=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga54487f79ea60723216b11c6fb0320286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga54487f79ea60723216b11c6fb0320286">More...</a><br /></td></tr>
<tr class="separator:ga54487f79ea60723216b11c6fb0320286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b91516b2c4be4334a58cb054b1a0680">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga6b91516b2c4be4334a58cb054b1a0680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga6b91516b2c4be4334a58cb054b1a0680">More...</a><br /></td></tr>
<tr class="separator:ga6b91516b2c4be4334a58cb054b1a0680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3a3dd16604cf5215b58366eacb4ffdf5">blaze::operator&lt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga3a3dd16604cf5215b58366eacb4ffdf5">More...</a><br /></td></tr>
<tr class="separator:ga3a3dd16604cf5215b58366eacb4ffdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e085f85d723050dd3472d1542642cab"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3e085f85d723050dd3472d1542642cab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3e085f85d723050dd3472d1542642cab">blaze::operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga3e085f85d723050dd3472d1542642cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga3e085f85d723050dd3472d1542642cab">More...</a><br /></td></tr>
<tr class="separator:ga3e085f85d723050dd3472d1542642cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9819fb4a78b96dc642b032680a4497"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaaf9819fb4a78b96dc642b032680a4497"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaaf9819fb4a78b96dc642b032680a4497">blaze::operator&gt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaaf9819fb4a78b96dc642b032680a4497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaaf9819fb4a78b96dc642b032680a4497">More...</a><br /></td></tr>
<tr class="separator:gaaf9819fb4a78b96dc642b032680a4497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4567aade84dfbb24e1587dcfc8751cf2">blaze::operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga4567aade84dfbb24e1587dcfc8751cf2">More...</a><br /></td></tr>
<tr class="separator:ga4567aade84dfbb24e1587dcfc8751cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Epsilon operators</h2></td></tr>
<tr class="memitem:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf77696e0b4298236b50e604cf58fcaf3">blaze::operator==</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf77696e0b4298236b50e604cf58fcaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaf77696e0b4298236b50e604cf58fcaf3">More...</a><br /></td></tr>
<tr class="separator:gaf77696e0b4298236b50e604cf58fcaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a51f607694128250e09404f52b4b276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a51f607694128250e09404f52b4b276"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0a51f607694128250e09404f52b4b276">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga0a51f607694128250e09404f52b4b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga0a51f607694128250e09404f52b4b276">More...</a><br /></td></tr>
<tr class="separator:ga0a51f607694128250e09404f52b4b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b125c455dda69ab246b146ca505bf09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b125c455dda69ab246b146ca505bf09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1b125c455dda69ab246b146ca505bf09">blaze::operator!=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga1b125c455dda69ab246b146ca505bf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga1b125c455dda69ab246b146ca505bf09">More...</a><br /></td></tr>
<tr class="separator:ga1b125c455dda69ab246b146ca505bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaed7f8cdce1a915934c959eb91f80cf50">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:gaed7f8cdce1a915934c959eb91f80cf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#gaed7f8cdce1a915934c959eb91f80cf50">More...</a><br /></td></tr>
<tr class="separator:gaed7f8cdce1a915934c959eb91f80cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40820137079464541dfb2e509116cea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga40820137079464541dfb2e509116cea9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga40820137079464541dfb2e509116cea9">blaze::operator&lt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga40820137079464541dfb2e509116cea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga40820137079464541dfb2e509116cea9">More...</a><br /></td></tr>
<tr class="separator:ga40820137079464541dfb2e509116cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c8df923cf79e378abe78f578c2fd3a4">blaze::operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga0c8df923cf79e378abe78f578c2fd3a4">More...</a><br /></td></tr>
<tr class="separator:ga0c8df923cf79e378abe78f578c2fd3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga03d0a5fa15d8e3467e9e74403a4af36d">blaze::operator&gt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga03d0a5fa15d8e3467e9e74403a4af36d">More...</a><br /></td></tr>
<tr class="separator:ga03d0a5fa15d8e3467e9e74403a4af36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7d2a20484cd688e10c1f783a62ccdf57">blaze::operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga7d2a20484cd688e10c1f783a62ccdf57">More...</a><br /></td></tr>
<tr class="separator:ga7d2a20484cd688e10c1f783a62ccdf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5e1bdb7c2e83533ec5900290f3db2926">blaze::operator&lt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga5e1bdb7c2e83533ec5900290f3db2926">More...</a><br /></td></tr>
<tr class="separator:ga5e1bdb7c2e83533ec5900290f3db2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75793d83615e27381df0bae5d84f89ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga75793d83615e27381df0bae5d84f89ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga75793d83615e27381df0bae5d84f89ee">blaze::operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga75793d83615e27381df0bae5d84f89ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga75793d83615e27381df0bae5d84f89ee">More...</a><br /></td></tr>
<tr class="separator:ga75793d83615e27381df0bae5d84f89ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga53f3ade227fca2dac380d0451ae70bb1">blaze::operator&gt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga53f3ade227fca2dac380d0451ae70bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga53f3ade227fca2dac380d0451ae70bb1">More...</a><br /></td></tr>
<tr class="separator:ga53f3ade227fca2dac380d0451ae70bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae821d3d1c431b8ec5705eb979dd2238e">blaze::operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:gae821d3d1c431b8ec5705eb979dd2238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#gae821d3d1c431b8ec5705eb979dd2238e">More...</a><br /></td></tr>
<tr class="separator:gae821d3d1c431b8ec5705eb979dd2238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mathematical utility functions</h2></td></tr>
<tr class="memitem:gaffebe2fae5612534433dbd26a999fefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaffebe2fae5612534433dbd26a999fefe"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaffebe2fae5612534433dbd26a999fefe">blaze::sign</a> (T a) noexcept</td></tr>
<tr class="memdesc:gaffebe2fae5612534433dbd26a999fefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="../../de/df1/group__math.html#gaffebe2fae5612534433dbd26a999fefe">More...</a><br /></td></tr>
<tr class="separator:gaffebe2fae5612534433dbd26a999fefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85346c256b6e74c93733704c6683314e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85346c256b6e74c93733704c6683314e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">blaze::digits</a> (T a) noexcept</td></tr>
<tr class="memdesc:ga85346c256b6e74c93733704c6683314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of valid digits of an integral value.  <a href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">More...</a><br /></td></tr>
<tr class="separator:ga85346c256b6e74c93733704c6683314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga744c2cdcc27fba2af1d7f24043353bd9">blaze::nextMultiple</a> (T1 value, T2 factor) noexcept</td></tr>
<tr class="memdesc:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up an integral value to the next multiple of a given factor.  <a href="../../de/df1/group__math.html#ga744c2cdcc27fba2af1d7f24043353bd9">More...</a><br /></td></tr>
<tr class="separator:ga744c2cdcc27fba2af1d7f24043353bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d897a05236023eb2572750966bb1847"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1d897a05236023eb2572750966bb1847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d897a05236023eb2572750966bb1847">blaze::less</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt; &gt;::value)</td></tr>
<tr class="memdesc:ga1d897a05236023eb2572750966bb1847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than comparison.  <a href="../../de/df1/group__math.html#ga1d897a05236023eb2572750966bb1847">More...</a><br /></td></tr>
<tr class="separator:ga1d897a05236023eb2572750966bb1847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860b2a005ccfc06780298500cf874a79"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga860b2a005ccfc06780298500cf874a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga860b2a005ccfc06780298500cf874a79">blaze::greater</a> (const T1 &amp;a, const T2 &amp;b) noexcept(<a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">CommonType_</a>&lt; T1, T2 &gt; &gt;::value)</td></tr>
<tr class="memdesc:ga860b2a005ccfc06780298500cf874a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic greater-than comparison.  <a href="../../de/df1/group__math.html#ga860b2a005ccfc06780298500cf874a79">More...</a><br /></td></tr>
<tr class="separator:ga860b2a005ccfc06780298500cf874a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeInfinity operators</h2></td></tr>
<tr class="memitem:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf72e3519f6f3e1222bb492165c1ff473">blaze::operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;)</td></tr>
<tr class="memdesc:gaf72e3519f6f3e1222bb492165c1ff473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="../../de/df1/group__math.html#gaf72e3519f6f3e1222bb492165c1ff473">More...</a><br /></td></tr>
<tr class="separator:gaf72e3519f6f3e1222bb492165c1ff473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac724ba633053ce342cb0e6a3045c6a09"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gac724ba633053ce342cb0e6a3045c6a09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac724ba633053ce342cb0e6a3045c6a09">blaze::operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac724ba633053ce342cb0e6a3045c6a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gac724ba633053ce342cb0e6a3045c6a09">More...</a><br /></td></tr>
<tr class="separator:gac724ba633053ce342cb0e6a3045c6a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8690c52b43be431f700b2424340eab78"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga8690c52b43be431f700b2424340eab78"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8690c52b43be431f700b2424340eab78">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8690c52b43be431f700b2424340eab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#ga8690c52b43be431f700b2424340eab78">More...</a><br /></td></tr>
<tr class="separator:ga8690c52b43be431f700b2424340eab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9f9352cad83e055316189fc57cb384"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga5e9f9352cad83e055316189fc57cb384"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5e9f9352cad83e055316189fc57cb384">blaze::operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;)</td></tr>
<tr class="memdesc:ga5e9f9352cad83e055316189fc57cb384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="../../de/df1/group__math.html#ga5e9f9352cad83e055316189fc57cb384">More...</a><br /></td></tr>
<tr class="separator:ga5e9f9352cad83e055316189fc57cb384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad4c05a37e71a0c3d7c4cdc3902a9aed0">blaze::operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gad4c05a37e71a0c3d7c4cdc3902a9aed0">More...</a><br /></td></tr>
<tr class="separator:gad4c05a37e71a0c3d7c4cdc3902a9aed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276208f7821e9194172f1485258d385c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga276208f7821e9194172f1485258d385c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga276208f7821e9194172f1485258d385c">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga276208f7821e9194172f1485258d385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#ga276208f7821e9194172f1485258d385c">More...</a><br /></td></tr>
<tr class="separator:ga276208f7821e9194172f1485258d385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Infinity operators</h2></td></tr>
<tr class="memitem:ga1cade862a899080b7219bb9468051f14"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1cade862a899080b7219bb9468051f14">blaze::operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:ga1cade862a899080b7219bb9468051f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="../../de/df1/group__math.html#ga1cade862a899080b7219bb9468051f14">More...</a><br /></td></tr>
<tr class="separator:ga1cade862a899080b7219bb9468051f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae113fce8b3a8df1350075c2c4868983c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae113fce8b3a8df1350075c2c4868983c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae113fce8b3a8df1350075c2c4868983c">blaze::operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;)</td></tr>
<tr class="memdesc:gae113fce8b3a8df1350075c2c4868983c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#gae113fce8b3a8df1350075c2c4868983c">More...</a><br /></td></tr>
<tr class="separator:gae113fce8b3a8df1350075c2c4868983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae914b7ce7e8fcfcf0bf4fa8767fcb15d">blaze::operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gae914b7ce7e8fcfcf0bf4fa8767fcb15d">More...</a><br /></td></tr>
<tr class="separator:gae914b7ce7e8fcfcf0bf4fa8767fcb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf89122a0bb9a848015b65506874909"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabdf89122a0bb9a848015b65506874909"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabdf89122a0bb9a848015b65506874909">blaze::operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gabdf89122a0bb9a848015b65506874909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gabdf89122a0bb9a848015b65506874909">More...</a><br /></td></tr>
<tr class="separator:gabdf89122a0bb9a848015b65506874909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaef34c0250b3f5dbfe8d24ed181650659">blaze::operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaef34c0250b3f5dbfe8d24ed181650659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gaef34c0250b3f5dbfe8d24ed181650659">More...</a><br /></td></tr>
<tr class="separator:gaef34c0250b3f5dbfe8d24ed181650659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga35624fa5c81fa4f70a5d03dc944c5411">blaze::operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="../../de/df1/group__math.html#ga35624fa5c81fa4f70a5d03dc944c5411">More...</a><br /></td></tr>
<tr class="separator:ga35624fa5c81fa4f70a5d03dc944c5411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8505375a66afb5af9edd75b85ba5204"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gae8505375a66afb5af9edd75b85ba5204"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae8505375a66afb5af9edd75b85ba5204">blaze::operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;)</td></tr>
<tr class="memdesc:gae8505375a66afb5af9edd75b85ba5204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#gae8505375a66afb5af9edd75b85ba5204">More...</a><br /></td></tr>
<tr class="separator:gae8505375a66afb5af9edd75b85ba5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf708a331a30e78fda59df5b66de17b63"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gaf708a331a30e78fda59df5b66de17b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf708a331a30e78fda59df5b66de17b63">blaze::operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;)</td></tr>
<tr class="memdesc:gaf708a331a30e78fda59df5b66de17b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gaf708a331a30e78fda59df5b66de17b63">More...</a><br /></td></tr>
<tr class="separator:gaf708a331a30e78fda59df5b66de17b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7856e8e97381138ec49530fdbe0ec412"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7856e8e97381138ec49530fdbe0ec412"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7856e8e97381138ec49530fdbe0ec412">blaze::operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7856e8e97381138ec49530fdbe0ec412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#ga7856e8e97381138ec49530fdbe0ec412">More...</a><br /></td></tr>
<tr class="separator:ga7856e8e97381138ec49530fdbe0ec412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga36d73646abcac7bfd4727f62ae1c7df2">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#ga36d73646abcac7bfd4727f62ae1c7df2">More...</a><br /></td></tr>
<tr class="separator:ga36d73646abcac7bfd4727f62ae1c7df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrixProxy global functions</h2></td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga473e41444b6324cdd14e5a675b829f4a">blaze::begin</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga473e41444b6324cdd14e5a675b829f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga473e41444b6324cdd14e5a675b829f4a">More...</a><br /></td></tr>
<tr class="separator:ga473e41444b6324cdd14e5a675b829f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab5e4b8a71e6e426f52371c0d5b9846fd">blaze::cbegin</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gab5e4b8a71e6e426f52371c0d5b9846fd">More...</a><br /></td></tr>
<tr class="separator:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd12cbf050e7ee64aff69936d37d6b97">blaze::end</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gabd12cbf050e7ee64aff69936d37d6b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gabd12cbf050e7ee64aff69936d37d6b97">More...</a><br /></td></tr>
<tr class="separator:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb1b473d7716b9abe090c3db5c8df431">blaze::cend</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gacb1b473d7716b9abe090c3db5c8df431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gacb1b473d7716b9abe090c3db5c8df431">More...</a><br /></td></tr>
<tr class="separator:gacb1b473d7716b9abe090c3db5c8df431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b7cec0953f0e0be2c5220bd61e6e2e3">blaze::rows</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="../../de/df1/group__math.html#ga9b7cec0953f0e0be2c5220bd61e6e2e3">More...</a><br /></td></tr>
<tr class="separator:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf184ec513c031b63bb72c7161f7f9f5c">blaze::columns</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="../../de/df1/group__math.html#gaf184ec513c031b63bb72c7161f7f9f5c">More...</a><br /></td></tr>
<tr class="separator:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabdce650ad06eb019f79bb6b7e92bf15d">blaze::capacity</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="../../de/df1/group__math.html#gabdce650ad06eb019f79bb6b7e92bf15d">More...</a><br /></td></tr>
<tr class="separator:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad086b7d12b02acd9fadbba5c105350c0">blaze::capacity</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gad086b7d12b02acd9fadbba5c105350c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gad086b7d12b02acd9fadbba5c105350c0">More...</a><br /></td></tr>
<tr class="separator:gad086b7d12b02acd9fadbba5c105350c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf98d55b3997a5e0666e9467aac2f383e">blaze::nonZeros</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf98d55b3997a5e0666e9467aac2f383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="../../de/df1/group__math.html#gaf98d55b3997a5e0666e9467aac2f383e">More...</a><br /></td></tr>
<tr class="separator:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gade25555a94e648076982a8c68fb38b70">blaze::nonZeros</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gade25555a94e648076982a8c68fb38b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gade25555a94e648076982a8c68fb38b70">More...</a><br /></td></tr>
<tr class="separator:gade25555a94e648076982a8c68fb38b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc381719659d4900cba8b887b072351"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga2bc381719659d4900cba8b887b072351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2bc381719659d4900cba8b887b072351">blaze::resize</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga2bc381719659d4900cba8b887b072351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented matrix.  <a href="../../de/df1/group__math.html#ga2bc381719659d4900cba8b887b072351">More...</a><br /></td></tr>
<tr class="separator:ga2bc381719659d4900cba8b887b072351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b361008599fbe7c5ad3262ed1cf8bf9">blaze::reset</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#ga6b361008599fbe7c5ad3262ed1cf8bf9">More...</a><br /></td></tr>
<tr class="separator:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga218b5d7e25e582cf759a0ffb94d8f88b">blaze::reset</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga218b5d7e25e582cf759a0ffb94d8f88b">More...</a><br /></td></tr>
<tr class="separator:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d821c7a793e0c694258e2917bb44edc">blaze::clear</a> (const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1d821c7a793e0c694258e2917bb44edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="../../de/df1/group__math.html#ga1d821c7a793e0c694258e2917bb44edc">More...</a><br /></td></tr>
<tr class="separator:ga1d821c7a793e0c694258e2917bb44edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVectorProxy global functions</h2></td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga33cd8a737acd2b68cf33d84baad75bf8">blaze::begin</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga33cd8a737acd2b68cf33d84baad75bf8">More...</a><br /></td></tr>
<tr class="separator:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1552651c7e7b05385a91c477f198b92c">blaze::cbegin</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1552651c7e7b05385a91c477f198b92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga1552651c7e7b05385a91c477f198b92c">More...</a><br /></td></tr>
<tr class="separator:ga1552651c7e7b05385a91c477f198b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad47f01490e02fe97e3e71003d70006b1">blaze::end</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad47f01490e02fe97e3e71003d70006b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#gad47f01490e02fe97e3e71003d70006b1">More...</a><br /></td></tr>
<tr class="separator:gad47f01490e02fe97e3e71003d70006b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga485df6bb7b74d08f29bcc446517f33bc">blaze::cend</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga485df6bb7b74d08f29bcc446517f33bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga485df6bb7b74d08f29bcc446517f33bc">More...</a><br /></td></tr>
<tr class="separator:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga815b73881a05f1de2c4ed92521758c22">blaze::size</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga815b73881a05f1de2c4ed92521758c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="../../de/df1/group__math.html#ga815b73881a05f1de2c4ed92521758c22">More...</a><br /></td></tr>
<tr class="separator:ga815b73881a05f1de2c4ed92521758c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9ad8f51a4e5551c83c078c2729c2bece">blaze::capacity</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="../../de/df1/group__math.html#ga9ad8f51a4e5551c83c078c2729c2bece">More...</a><br /></td></tr>
<tr class="separator:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb886f8afac581ea219e7fd9dfdf6c74">blaze::nonZeros</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="../../de/df1/group__math.html#gacb886f8afac581ea219e7fd9dfdf6c74">More...</a><br /></td></tr>
<tr class="separator:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413b7144866fb308fe121cf5b3695d0e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga413b7144866fb308fe121cf5b3695d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga413b7144866fb308fe121cf5b3695d0e">blaze::resize</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:ga413b7144866fb308fe121cf5b3695d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented vector.  <a href="../../de/df1/group__math.html#ga413b7144866fb308fe121cf5b3695d0e">More...</a><br /></td></tr>
<tr class="separator:ga413b7144866fb308fe121cf5b3695d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5277ea1f337ba3a87d2dad48b609cec7">blaze::reset</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented vector to the default initial values.  <a href="../../de/df1/group__math.html#ga5277ea1f337ba3a87d2dad48b609cec7">More...</a><br /></td></tr>
<tr class="separator:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae42eef9a424004a86df6fc9c4115c2bc">blaze::clear</a> (const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae42eef9a424004a86df6fc9c4115c2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented vector.  <a href="../../de/df1/group__math.html#gae42eef9a424004a86df6fc9c4115c2bc">More...</a><br /></td></tr>
<tr class="separator:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Proxy operators</h2></td></tr>
<tr class="memitem:ga197bdc8c4217ad5ef8a5f54da3cb4b20"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga197bdc8c4217ad5ef8a5f54da3cb4b20"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga197bdc8c4217ad5ef8a5f54da3cb4b20">blaze::operator+</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga197bdc8c4217ad5ef8a5f54da3cb4b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga197bdc8c4217ad5ef8a5f54da3cb4b20">More...</a><br /></td></tr>
<tr class="separator:ga197bdc8c4217ad5ef8a5f54da3cb4b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d39dd0af7eb18fe9bf555a5065dd36"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga39d39dd0af7eb18fe9bf555a5065dd36"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga39d39dd0af7eb18fe9bf555a5065dd36">blaze::operator+</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga39d39dd0af7eb18fe9bf555a5065dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga39d39dd0af7eb18fe9bf555a5065dd36">More...</a><br /></td></tr>
<tr class="separator:ga39d39dd0af7eb18fe9bf555a5065dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababce4874fa2c7857cf2fee2bf865e3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gababce4874fa2c7857cf2fee2bf865e3a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gababce4874fa2c7857cf2fee2bf865e3a">blaze::operator+</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gababce4874fa2c7857cf2fee2bf865e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gababce4874fa2c7857cf2fee2bf865e3a">More...</a><br /></td></tr>
<tr class="separator:gababce4874fa2c7857cf2fee2bf865e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9b2651135b373f4b7f6189ade4ac9f"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga4b9b2651135b373f4b7f6189ade4ac9f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4b9b2651135b373f4b7f6189ade4ac9f">blaze::operator-</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4b9b2651135b373f4b7f6189ade4ac9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga4b9b2651135b373f4b7f6189ade4ac9f">More...</a><br /></td></tr>
<tr class="separator:ga4b9b2651135b373f4b7f6189ade4ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea64dfa5c1a1c1dba8c4a4bc9da23830"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaea64dfa5c1a1c1dba8c4a4bc9da23830"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaea64dfa5c1a1c1dba8c4a4bc9da23830">blaze::operator-</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaea64dfa5c1a1c1dba8c4a4bc9da23830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gaea64dfa5c1a1c1dba8c4a4bc9da23830">More...</a><br /></td></tr>
<tr class="separator:gaea64dfa5c1a1c1dba8c4a4bc9da23830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c847511c877715c20b1163581c62ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga15c847511c877715c20b1163581c62ad"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga15c847511c877715c20b1163581c62ad">blaze::operator-</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga15c847511c877715c20b1163581c62ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga15c847511c877715c20b1163581c62ad">More...</a><br /></td></tr>
<tr class="separator:ga15c847511c877715c20b1163581c62ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e53cb1174ec7cb23419fcaccbcbcc6"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gaa4e53cb1174ec7cb23419fcaccbcbcc6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa4e53cb1174ec7cb23419fcaccbcbcc6">blaze::operator*</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa4e53cb1174ec7cb23419fcaccbcbcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gaa4e53cb1174ec7cb23419fcaccbcbcc6">More...</a><br /></td></tr>
<tr class="separator:gaa4e53cb1174ec7cb23419fcaccbcbcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d781ec61e6f1f5448e86b1f2720109"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga77d781ec61e6f1f5448e86b1f2720109"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga77d781ec61e6f1f5448e86b1f2720109">blaze::operator*</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga77d781ec61e6f1f5448e86b1f2720109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga77d781ec61e6f1f5448e86b1f2720109">More...</a><br /></td></tr>
<tr class="separator:ga77d781ec61e6f1f5448e86b1f2720109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031d79d9eacb3e9e10be05bcbac470cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga031d79d9eacb3e9e10be05bcbac470cf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga031d79d9eacb3e9e10be05bcbac470cf">blaze::operator*</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga031d79d9eacb3e9e10be05bcbac470cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga031d79d9eacb3e9e10be05bcbac470cf">More...</a><br /></td></tr>
<tr class="separator:ga031d79d9eacb3e9e10be05bcbac470cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aeafd8e7c26ca6d406c7b8f3f5233c"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga49aeafd8e7c26ca6d406c7b8f3f5233c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga49aeafd8e7c26ca6d406c7b8f3f5233c">blaze::operator/</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga49aeafd8e7c26ca6d406c7b8f3f5233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga49aeafd8e7c26ca6d406c7b8f3f5233c">More...</a><br /></td></tr>
<tr class="separator:ga49aeafd8e7c26ca6d406c7b8f3f5233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da703d60bec3ee1185e141e23814c48"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga4da703d60bec3ee1185e141e23814c48"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4da703d60bec3ee1185e141e23814c48">blaze::operator/</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga4da703d60bec3ee1185e141e23814c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga4da703d60bec3ee1185e141e23814c48">More...</a><br /></td></tr>
<tr class="separator:ga4da703d60bec3ee1185e141e23814c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f392cba2dd5fcdf4c0de162fd69188"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gad5f392cba2dd5fcdf4c0de162fd69188"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad5f392cba2dd5fcdf4c0de162fd69188">blaze::operator/</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad5f392cba2dd5fcdf4c0de162fd69188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gad5f392cba2dd5fcdf4c0de162fd69188">More...</a><br /></td></tr>
<tr class="separator:gad5f392cba2dd5fcdf4c0de162fd69188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035d23379f82bda953132324d4aa17f3"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga035d23379f82bda953132324d4aa17f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga035d23379f82bda953132324d4aa17f3">blaze::operator==</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga035d23379f82bda953132324d4aa17f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga035d23379f82bda953132324d4aa17f3">More...</a><br /></td></tr>
<tr class="separator:ga035d23379f82bda953132324d4aa17f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d24a75ffae866d00e584315058f28ce"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga8d24a75ffae866d00e584315058f28ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8d24a75ffae866d00e584315058f28ce">blaze::operator==</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga8d24a75ffae866d00e584315058f28ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga8d24a75ffae866d00e584315058f28ce">More...</a><br /></td></tr>
<tr class="separator:ga8d24a75ffae866d00e584315058f28ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae4abf1755e20af8b6ca00a9dc7f9483d">blaze::operator!=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gae4abf1755e20af8b6ca00a9dc7f9483d">More...</a><br /></td></tr>
<tr class="separator:gae4abf1755e20af8b6ca00a9dc7f9483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ecf2893db8fefd3e0ce3adbc105505"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaa0ecf2893db8fefd3e0ce3adbc105505"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa0ecf2893db8fefd3e0ce3adbc105505">blaze::operator!=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaa0ecf2893db8fefd3e0ce3adbc105505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gaa0ecf2893db8fefd3e0ce3adbc105505">More...</a><br /></td></tr>
<tr class="separator:gaa0ecf2893db8fefd3e0ce3adbc105505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abe3334b771c6cee4333fbf990d6c12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga0abe3334b771c6cee4333fbf990d6c12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0abe3334b771c6cee4333fbf990d6c12">blaze::operator!=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0abe3334b771c6cee4333fbf990d6c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga0abe3334b771c6cee4333fbf990d6c12">More...</a><br /></td></tr>
<tr class="separator:ga0abe3334b771c6cee4333fbf990d6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65821b80ccae33417341537e4227f868"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga65821b80ccae33417341537e4227f868"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga65821b80ccae33417341537e4227f868">blaze::operator&lt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga65821b80ccae33417341537e4227f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga65821b80ccae33417341537e4227f868">More...</a><br /></td></tr>
<tr class="separator:ga65821b80ccae33417341537e4227f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9b1816705651c2119a7cc80978ad76"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gabd9b1816705651c2119a7cc80978ad76"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd9b1816705651c2119a7cc80978ad76">blaze::operator&lt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gabd9b1816705651c2119a7cc80978ad76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gabd9b1816705651c2119a7cc80978ad76">More...</a><br /></td></tr>
<tr class="separator:gabd9b1816705651c2119a7cc80978ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879147357f8a8a6ff8caa437aaf8d012"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga879147357f8a8a6ff8caa437aaf8d012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga879147357f8a8a6ff8caa437aaf8d012">blaze::operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga879147357f8a8a6ff8caa437aaf8d012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga879147357f8a8a6ff8caa437aaf8d012">More...</a><br /></td></tr>
<tr class="separator:ga879147357f8a8a6ff8caa437aaf8d012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f8244f6749d5d4f160add9f963c78d"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga40f8244f6749d5d4f160add9f963c78d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga40f8244f6749d5d4f160add9f963c78d">blaze::operator&gt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga40f8244f6749d5d4f160add9f963c78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga40f8244f6749d5d4f160add9f963c78d">More...</a><br /></td></tr>
<tr class="separator:ga40f8244f6749d5d4f160add9f963c78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b0cd82ed4b295a23206ca524bbb3ff"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaf5b0cd82ed4b295a23206ca524bbb3ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf5b0cd82ed4b295a23206ca524bbb3ff">blaze::operator&gt;</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaf5b0cd82ed4b295a23206ca524bbb3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gaf5b0cd82ed4b295a23206ca524bbb3ff">More...</a><br /></td></tr>
<tr class="separator:gaf5b0cd82ed4b295a23206ca524bbb3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b417ce7ce401e64c5da29f0eec6fc84"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga0b417ce7ce401e64c5da29f0eec6fc84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0b417ce7ce401e64c5da29f0eec6fc84">blaze::operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0b417ce7ce401e64c5da29f0eec6fc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga0b417ce7ce401e64c5da29f0eec6fc84">More...</a><br /></td></tr>
<tr class="separator:ga0b417ce7ce401e64c5da29f0eec6fc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24730d792522ea8882c06888e00ae7e"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gac24730d792522ea8882c06888e00ae7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac24730d792522ea8882c06888e00ae7e">blaze::operator&lt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac24730d792522ea8882c06888e00ae7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gac24730d792522ea8882c06888e00ae7e">More...</a><br /></td></tr>
<tr class="separator:gac24730d792522ea8882c06888e00ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa747aec154c780ba245ee5ab418c14"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga3fa747aec154c780ba245ee5ab418c14"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3fa747aec154c780ba245ee5ab418c14">blaze::operator&lt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga3fa747aec154c780ba245ee5ab418c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga3fa747aec154c780ba245ee5ab418c14">More...</a><br /></td></tr>
<tr class="separator:ga3fa747aec154c780ba245ee5ab418c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c94aa2315bdbaece3d7f073f11b1b15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga6c94aa2315bdbaece3d7f073f11b1b15"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6c94aa2315bdbaece3d7f073f11b1b15">blaze::operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6c94aa2315bdbaece3d7f073f11b1b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga6c94aa2315bdbaece3d7f073f11b1b15">More...</a><br /></td></tr>
<tr class="separator:ga6c94aa2315bdbaece3d7f073f11b1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59183d72b56569f5a047b9db01b780a"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gad59183d72b56569f5a047b9db01b780a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad59183d72b56569f5a047b9db01b780a">blaze::operator&gt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad59183d72b56569f5a047b9db01b780a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gad59183d72b56569f5a047b9db01b780a">More...</a><br /></td></tr>
<tr class="separator:gad59183d72b56569f5a047b9db01b780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707b8c99baea44f733cf706c1a290b89"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga707b8c99baea44f733cf706c1a290b89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga707b8c99baea44f733cf706c1a290b89">blaze::operator&gt;=</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga707b8c99baea44f733cf706c1a290b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga707b8c99baea44f733cf706c1a290b89">More...</a><br /></td></tr>
<tr class="separator:ga707b8c99baea44f733cf706c1a290b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d595be92d155c2b70cf206ec6beea16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga9d595be92d155c2b70cf206ec6beea16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9d595be92d155c2b70cf206ec6beea16">blaze::operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d595be92d155c2b70cf206ec6beea16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#ga9d595be92d155c2b70cf206ec6beea16">More...</a><br /></td></tr>
<tr class="separator:ga9d595be92d155c2b70cf206ec6beea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa14e76b894f5467df70d6d330fb66c0e">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa14e76b894f5467df70d6d330fb66c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class template.  <a href="../../de/df1/group__math.html#gaa14e76b894f5467df70d6d330fb66c0e">More...</a><br /></td></tr>
<tr class="separator:gaa14e76b894f5467df70d6d330fb66c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Proxy global functions</h2></td></tr>
<tr class="memitem:gab5c2a2685a1cfa2612dbc9492ba370a0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gab5c2a2685a1cfa2612dbc9492ba370a0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab5c2a2685a1cfa2612dbc9492ba370a0">blaze::trans</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gab5c2a2685a1cfa2612dbc9492ba370a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the transpose of the represented element.  <a href="../../de/df1/group__math.html#gab5c2a2685a1cfa2612dbc9492ba370a0">More...</a><br /></td></tr>
<tr class="separator:gab5c2a2685a1cfa2612dbc9492ba370a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707644d2c2f3d1436e3fab5e3d1d9030"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga707644d2c2f3d1436e3fab5e3d1d9030"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga707644d2c2f3d1436e3fab5e3d1d9030">blaze::ctrans</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga707644d2c2f3d1436e3fab5e3d1d9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the conjugate transpose of the represented element.  <a href="../../de/df1/group__math.html#ga707644d2c2f3d1436e3fab5e3d1d9030">More...</a><br /></td></tr>
<tr class="separator:ga707644d2c2f3d1436e3fab5e3d1d9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398ff45f7649293d4de247b5fa3cfc60"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga398ff45f7649293d4de247b5fa3cfc60"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga398ff45f7649293d4de247b5fa3cfc60">blaze::abs</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga398ff45f7649293d4de247b5fa3cfc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the absolute value of the represented element.  <a href="../../de/df1/group__math.html#ga398ff45f7649293d4de247b5fa3cfc60">More...</a><br /></td></tr>
<tr class="separator:ga398ff45f7649293d4de247b5fa3cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a682039851e6805e808ca86cccfe7c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga56a682039851e6805e808ca86cccfe7c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga56a682039851e6805e808ca86cccfe7c">blaze::conj</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga56a682039851e6805e808ca86cccfe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the complex conjugate of the represented element.  <a href="../../de/df1/group__math.html#ga56a682039851e6805e808ca86cccfe7c">More...</a><br /></td></tr>
<tr class="separator:ga56a682039851e6805e808ca86cccfe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97be5d1a9904df3e666598a377e840f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaf97be5d1a9904df3e666598a377e840f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf97be5d1a9904df3e666598a377e840f">blaze::real</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf97be5d1a9904df3e666598a377e840f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the real part of the represented element.  <a href="../../de/df1/group__math.html#gaf97be5d1a9904df3e666598a377e840f">More...</a><br /></td></tr>
<tr class="separator:gaf97be5d1a9904df3e666598a377e840f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bc1d8ded38e6629f3c73b7737912f8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga30bc1d8ded38e6629f3c73b7737912f8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga30bc1d8ded38e6629f3c73b7737912f8">blaze::imag</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga30bc1d8ded38e6629f3c73b7737912f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the imaginary part of the represented element.  <a href="../../de/df1/group__math.html#ga30bc1d8ded38e6629f3c73b7737912f8">More...</a><br /></td></tr>
<tr class="separator:ga30bc1d8ded38e6629f3c73b7737912f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f7fc216f376647af34d833fd944016"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gac8f7fc216f376647af34d833fd944016"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac8f7fc216f376647af34d833fd944016">blaze::sqrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac8f7fc216f376647af34d833fd944016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the square root of the represented element.  <a href="../../de/df1/group__math.html#gac8f7fc216f376647af34d833fd944016">More...</a><br /></td></tr>
<tr class="separator:gac8f7fc216f376647af34d833fd944016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b3e1613b57575b202d4f8fff72321b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa8b3e1613b57575b202d4f8fff72321b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa8b3e1613b57575b202d4f8fff72321b">blaze::invsqrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa8b3e1613b57575b202d4f8fff72321b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse square root of the represented element.  <a href="../../de/df1/group__math.html#gaa8b3e1613b57575b202d4f8fff72321b">More...</a><br /></td></tr>
<tr class="separator:gaa8b3e1613b57575b202d4f8fff72321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae66c01ffa953265855b113197750a0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga5ae66c01ffa953265855b113197750a0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5ae66c01ffa953265855b113197750a0">blaze::cbrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5ae66c01ffa953265855b113197750a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the cubic root of the represented element.  <a href="../../de/df1/group__math.html#ga5ae66c01ffa953265855b113197750a0">More...</a><br /></td></tr>
<tr class="separator:ga5ae66c01ffa953265855b113197750a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c50c7a27f701758ee5c16137a30fb4e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3c50c7a27f701758ee5c16137a30fb4e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3c50c7a27f701758ee5c16137a30fb4e">blaze::invcbrt</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3c50c7a27f701758ee5c16137a30fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse cubic root of the represented element.  <a href="../../de/df1/group__math.html#ga3c50c7a27f701758ee5c16137a30fb4e">More...</a><br /></td></tr>
<tr class="separator:ga3c50c7a27f701758ee5c16137a30fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c98f244bd3412fa43039b422a5c1a55"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga4c98f244bd3412fa43039b422a5c1a55"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4c98f244bd3412fa43039b422a5c1a55">blaze::floor</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4c98f244bd3412fa43039b422a5c1a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integral value that is not greater than the represented element.  <a href="../../de/df1/group__math.html#ga4c98f244bd3412fa43039b422a5c1a55">More...</a><br /></td></tr>
<tr class="separator:ga4c98f244bd3412fa43039b422a5c1a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2708e803abdf89f741ad6cec81087127"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga2708e803abdf89f741ad6cec81087127"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2708e803abdf89f741ad6cec81087127">blaze::ceil</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga2708e803abdf89f741ad6cec81087127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integral value that is not less than the represented element.  <a href="../../de/df1/group__math.html#ga2708e803abdf89f741ad6cec81087127">More...</a><br /></td></tr>
<tr class="separator:ga2708e803abdf89f741ad6cec81087127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87db2707c258b67bbb537ab6357cbd1a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename ET &gt; </td></tr>
<tr class="memitem:ga87db2707c258b67bbb537ab6357cbd1a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga87db2707c258b67bbb537ab6357cbd1a">blaze::pow</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy, const ET &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>)</td></tr>
<tr class="memdesc:ga87db2707c258b67bbb537ab6357cbd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the exponential value of the represented element.  <a href="../../de/df1/group__math.html#ga87db2707c258b67bbb537ab6357cbd1a">More...</a><br /></td></tr>
<tr class="separator:ga87db2707c258b67bbb537ab6357cbd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae241307b6b6ab423bae5880475969740"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gae241307b6b6ab423bae5880475969740"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae241307b6b6ab423bae5880475969740">blaze::exp</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae241307b6b6ab423bae5880475969740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the base-e exponential of the represented element.  <a href="../../de/df1/group__math.html#gae241307b6b6ab423bae5880475969740">More...</a><br /></td></tr>
<tr class="separator:gae241307b6b6ab423bae5880475969740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac865bbd940482afab2fc59df9bbd8e77"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gac865bbd940482afab2fc59df9bbd8e77"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac865bbd940482afab2fc59df9bbd8e77">blaze::sin</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac865bbd940482afab2fc59df9bbd8e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the sine of the represented element.  <a href="../../de/df1/group__math.html#gac865bbd940482afab2fc59df9bbd8e77">More...</a><br /></td></tr>
<tr class="separator:gac865bbd940482afab2fc59df9bbd8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac120a95db76930ae4ff5b74fd2fb8ade"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gac120a95db76930ae4ff5b74fd2fb8ade"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac120a95db76930ae4ff5b74fd2fb8ade">blaze::asin</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac120a95db76930ae4ff5b74fd2fb8ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse sine of the represented element.  <a href="../../de/df1/group__math.html#gac120a95db76930ae4ff5b74fd2fb8ade">More...</a><br /></td></tr>
<tr class="separator:gac120a95db76930ae4ff5b74fd2fb8ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf420e36ba03cf36fc84fe48b91f06f87"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaf420e36ba03cf36fc84fe48b91f06f87"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf420e36ba03cf36fc84fe48b91f06f87">blaze::sinh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf420e36ba03cf36fc84fe48b91f06f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic sine of the represented element.  <a href="../../de/df1/group__math.html#gaf420e36ba03cf36fc84fe48b91f06f87">More...</a><br /></td></tr>
<tr class="separator:gaf420e36ba03cf36fc84fe48b91f06f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8fcbbdf35c6dd931faf9cf05aef127"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga6e8fcbbdf35c6dd931faf9cf05aef127"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6e8fcbbdf35c6dd931faf9cf05aef127">blaze::asinh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6e8fcbbdf35c6dd931faf9cf05aef127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic sine of the represented element.  <a href="../../de/df1/group__math.html#ga6e8fcbbdf35c6dd931faf9cf05aef127">More...</a><br /></td></tr>
<tr class="separator:ga6e8fcbbdf35c6dd931faf9cf05aef127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4838341eafaf86ce33efd46996c7a4"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga6a4838341eafaf86ce33efd46996c7a4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6a4838341eafaf86ce33efd46996c7a4">blaze::cos</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6a4838341eafaf86ce33efd46996c7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the cosine of the represented element.  <a href="../../de/df1/group__math.html#ga6a4838341eafaf86ce33efd46996c7a4">More...</a><br /></td></tr>
<tr class="separator:ga6a4838341eafaf86ce33efd46996c7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9225ba03b89bdb120c24d4cc0c038d6b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga9225ba03b89bdb120c24d4cc0c038d6b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9225ba03b89bdb120c24d4cc0c038d6b">blaze::acos</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9225ba03b89bdb120c24d4cc0c038d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse cosine of the represented element.  <a href="../../de/df1/group__math.html#ga9225ba03b89bdb120c24d4cc0c038d6b">More...</a><br /></td></tr>
<tr class="separator:ga9225ba03b89bdb120c24d4cc0c038d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662008d3f3a266ab453b818202b96978"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga662008d3f3a266ab453b818202b96978"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga662008d3f3a266ab453b818202b96978">blaze::cosh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga662008d3f3a266ab453b818202b96978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic cosine of the represented element.  <a href="../../de/df1/group__math.html#ga662008d3f3a266ab453b818202b96978">More...</a><br /></td></tr>
<tr class="separator:ga662008d3f3a266ab453b818202b96978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e2ff7bc4439ef7012e944092bebda9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga44e2ff7bc4439ef7012e944092bebda9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga44e2ff7bc4439ef7012e944092bebda9">blaze::acosh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga44e2ff7bc4439ef7012e944092bebda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic cosine of the represented element.  <a href="../../de/df1/group__math.html#ga44e2ff7bc4439ef7012e944092bebda9">More...</a><br /></td></tr>
<tr class="separator:ga44e2ff7bc4439ef7012e944092bebda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6c1c699dd48552d76fdc6fe1be5f91"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3b6c1c699dd48552d76fdc6fe1be5f91"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3b6c1c699dd48552d76fdc6fe1be5f91">blaze::tan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3b6c1c699dd48552d76fdc6fe1be5f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the tangent of the represented element.  <a href="../../de/df1/group__math.html#ga3b6c1c699dd48552d76fdc6fe1be5f91">More...</a><br /></td></tr>
<tr class="separator:ga3b6c1c699dd48552d76fdc6fe1be5f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4120822d2593a095244e6bf06ef4d1"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga6f4120822d2593a095244e6bf06ef4d1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6f4120822d2593a095244e6bf06ef4d1">blaze::atan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6f4120822d2593a095244e6bf06ef4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse tangent of the represented element.  <a href="../../de/df1/group__math.html#ga6f4120822d2593a095244e6bf06ef4d1">More...</a><br /></td></tr>
<tr class="separator:ga6f4120822d2593a095244e6bf06ef4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a1649365d8adf3f8333a62599464b9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa4a1649365d8adf3f8333a62599464b9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa4a1649365d8adf3f8333a62599464b9">blaze::tanh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa4a1649365d8adf3f8333a62599464b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the hyperbolic tangent of the represented element.  <a href="../../de/df1/group__math.html#gaa4a1649365d8adf3f8333a62599464b9">More...</a><br /></td></tr>
<tr class="separator:gaa4a1649365d8adf3f8333a62599464b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62126af52952804f47d2c4bae571f0f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaa62126af52952804f47d2c4bae571f0f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa62126af52952804f47d2c4bae571f0f">blaze::atanh</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa62126af52952804f47d2c4bae571f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing the inverse hyperbolic tangent of the represented element.  <a href="../../de/df1/group__math.html#gaa62126af52952804f47d2c4bae571f0f">More...</a><br /></td></tr>
<tr class="separator:gaa62126af52952804f47d2c4bae571f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bcdf350f718ca13ae06ce5e27025221"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:ga6bcdf350f718ca13ae06ce5e27025221"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6bcdf350f718ca13ae06ce5e27025221">blaze::min</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6bcdf350f718ca13ae06ce5e27025221"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#ga6bcdf350f718ca13ae06ce5e27025221">More...</a><br /></td></tr>
<tr class="separator:ga6bcdf350f718ca13ae06ce5e27025221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f53f853b5785eeba6c1827a1a971f3b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga6f53f853b5785eeba6c1827a1a971f3b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6f53f853b5785eeba6c1827a1a971f3b">blaze::min</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga6f53f853b5785eeba6c1827a1a971f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#ga6f53f853b5785eeba6c1827a1a971f3b">More...</a><br /></td></tr>
<tr class="separator:ga6f53f853b5785eeba6c1827a1a971f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffd7c7fa673c6bcd3fc4321b27079a3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaeffd7c7fa673c6bcd3fc4321b27079a3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaeffd7c7fa673c6bcd3fc4321b27079a3">blaze::min</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaeffd7c7fa673c6bcd3fc4321b27079a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gaeffd7c7fa673c6bcd3fc4321b27079a3">More...</a><br /></td></tr>
<tr class="separator:gaeffd7c7fa673c6bcd3fc4321b27079a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6c16764418ffa6a233ea3027f5320b"><td class="memTemplParams" colspan="2">template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </td></tr>
<tr class="memitem:gafd6c16764418ffa6a233ea3027f5320b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafd6c16764418ffa6a233ea3027f5320b">blaze::max</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd6c16764418ffa6a233ea3027f5320b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects.  <a href="../../de/df1/group__math.html#gafd6c16764418ffa6a233ea3027f5320b">More...</a><br /></td></tr>
<tr class="separator:gafd6c16764418ffa6a233ea3027f5320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e6eb00b99cb69a0364229c0da02f1b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gab7e6eb00b99cb69a0364229c0da02f1b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab7e6eb00b99cb69a0364229c0da02f1b">blaze::max</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab7e6eb00b99cb69a0364229c0da02f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type.  <a href="../../de/df1/group__math.html#gab7e6eb00b99cb69a0364229c0da02f1b">More...</a><br /></td></tr>
<tr class="separator:gab7e6eb00b99cb69a0364229c0da02f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd91f6bf3df0762ceabdfa6ee0839b7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </td></tr>
<tr class="memitem:gacd91f6bf3df0762ceabdfa6ee0839b7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacd91f6bf3df0762ceabdfa6ee0839b7a">blaze::max</a> (const T &amp;lhs, const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacd91f6bf3df0762ceabdfa6ee0839b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object.  <a href="../../de/df1/group__math.html#gacd91f6bf3df0762ceabdfa6ee0839b7a">More...</a><br /></td></tr>
<tr class="separator:gacd91f6bf3df0762ceabdfa6ee0839b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664fc6202989987071c22966ab8b18d5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga664fc6202989987071c22966ab8b18d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga664fc6202989987071c22966ab8b18d5">blaze::transpose</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga664fc6202989987071c22966ab8b18d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place transpose of the represented matrix element.  <a href="../../de/df1/group__math.html#ga664fc6202989987071c22966ab8b18d5">More...</a><br /></td></tr>
<tr class="separator:ga664fc6202989987071c22966ab8b18d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7b7fcc6534302c97b09c07655902f5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gaff7b7fcc6534302c97b09c07655902f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaff7b7fcc6534302c97b09c07655902f5">blaze::ctranspose</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaff7b7fcc6534302c97b09c07655902f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugate transpose of the represented matrix element.  <a href="../../de/df1/group__math.html#gaff7b7fcc6534302c97b09c07655902f5">More...</a><br /></td></tr>
<tr class="separator:gaff7b7fcc6534302c97b09c07655902f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5b8198c1bb8ffdf1a77c3b3d3f01508d">blaze::invert</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../de/df1/group__math.html#ga5b8198c1bb8ffdf1a77c3b3d3f01508d">More...</a><br /></td></tr>
<tr class="separator:ga5b8198c1bb8ffdf1a77c3b3d3f01508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a33ec01ed8420e939104d4796438ad"><td class="memTemplParams" colspan="2">template&lt;InversionFlag IF, typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gad6a33ec01ed8420e939104d4796438ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad6a33ec01ed8420e939104d4796438ad">blaze::invert</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad6a33ec01ed8420e939104d4796438ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the represented element.  <a href="../../de/df1/group__math.html#gad6a33ec01ed8420e939104d4796438ad">More...</a><br /></td></tr>
<tr class="separator:gad6a33ec01ed8420e939104d4796438ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b758cdd3dfb8d64121d55fd549fdca1"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga4b758cdd3dfb8d64121d55fd549fdca1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4b758cdd3dfb8d64121d55fd549fdca1">blaze::isReal</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4b758cdd3dfb8d64121d55fd549fdca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the element represents a real number.  <a href="../../de/df1/group__math.html#ga4b758cdd3dfb8d64121d55fd549fdca1">More...</a><br /></td></tr>
<tr class="separator:ga4b758cdd3dfb8d64121d55fd549fdca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58140730d57c5b46c101906d60b6d9a"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gac58140730d57c5b46c101906d60b6d9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac58140730d57c5b46c101906d60b6d9a">blaze::isZero</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac58140730d57c5b46c101906d60b6d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../de/df1/group__math.html#gac58140730d57c5b46c101906d60b6d9a">More...</a><br /></td></tr>
<tr class="separator:gac58140730d57c5b46c101906d60b6d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3371a8458f782f92f481585d2da5e387"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename PT , typename RT &gt; </td></tr>
<tr class="memitem:ga3371a8458f782f92f481585d2da5e387"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3371a8458f782f92f481585d2da5e387">blaze::isOne</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3371a8458f782f92f481585d2da5e387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../de/df1/group__math.html#ga3371a8458f782f92f481585d2da5e387">More...</a><br /></td></tr>
<tr class="separator:ga3371a8458f782f92f481585d2da5e387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ff9be338882a06b760b1b0563a6132"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename RT &gt; </td></tr>
<tr class="memitem:gae6ff9be338882a06b760b1b0563a6132"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae6ff9be338882a06b760b1b0563a6132">blaze::isnan</a> (const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae6ff9be338882a06b760b1b0563a6132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../de/df1/group__math.html#gae6ff9be338882a06b760b1b0563a6132">More...</a><br /></td></tr>
<tr class="separator:gae6ff9be338882a06b760b1b0563a6132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrixProxy global functions</h2></td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga34acd458b656ec2167762cc3fb1bdd1f">blaze::begin</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga34acd458b656ec2167762cc3fb1bdd1f">More...</a><br /></td></tr>
<tr class="separator:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">blaze::cbegin</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">More...</a><br /></td></tr>
<tr class="separator:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaff459171ee4708a8fc325de33d9345aa">blaze::end</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gaff459171ee4708a8fc325de33d9345aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#gaff459171ee4708a8fc325de33d9345aa">More...</a><br /></td></tr>
<tr class="separator:gaff459171ee4708a8fc325de33d9345aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga58b9786b8a311ab1bf97f247f566edd9">blaze::cend</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga58b9786b8a311ab1bf97f247f566edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="../../de/df1/group__math.html#ga58b9786b8a311ab1bf97f247f566edd9">More...</a><br /></td></tr>
<tr class="separator:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51e08caafa4583f32333b5d17f1c4ef5">blaze::rows</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="../../de/df1/group__math.html#ga51e08caafa4583f32333b5d17f1c4ef5">More...</a><br /></td></tr>
<tr class="separator:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa69887db471553a593455e9939bd20e8">blaze::columns</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa69887db471553a593455e9939bd20e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="../../de/df1/group__math.html#gaa69887db471553a593455e9939bd20e8">More...</a><br /></td></tr>
<tr class="separator:gaa69887db471553a593455e9939bd20e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf8d7b618c624d4911ae7f3882a05dc14">blaze::capacity</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="../../de/df1/group__math.html#gaf8d7b618c624d4911ae7f3882a05dc14">More...</a><br /></td></tr>
<tr class="separator:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1c3df62b3c237c2a2b04fc28e7a20dcf">blaze::capacity</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga1c3df62b3c237c2a2b04fc28e7a20dcf">More...</a><br /></td></tr>
<tr class="separator:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad8d4a1ad716a90d183a1f310887f678f">blaze::nonZeros</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad8d4a1ad716a90d183a1f310887f678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="../../de/df1/group__math.html#gad8d4a1ad716a90d183a1f310887f678f">More...</a><br /></td></tr>
<tr class="separator:gad8d4a1ad716a90d183a1f310887f678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabe8aa45ed742cea841472f9f575f9c71">blaze::nonZeros</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:gabe8aa45ed742cea841472f9f575f9c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#gabe8aa45ed742cea841472f9f575f9c71">More...</a><br /></td></tr>
<tr class="separator:gabe8aa45ed742cea841472f9f575f9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad355337adec8b62593dc482cc5d01a87"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad355337adec8b62593dc482cc5d01a87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad355337adec8b62593dc482cc5d01a87">blaze::resize</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:gad355337adec8b62593dc482cc5d01a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented matrix.  <a href="../../de/df1/group__math.html#gad355337adec8b62593dc482cc5d01a87">More...</a><br /></td></tr>
<tr class="separator:gad355337adec8b62593dc482cc5d01a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7df60d6b50394cad1e546a4cd8969af6">blaze::reset</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7df60d6b50394cad1e546a4cd8969af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#ga7df60d6b50394cad1e546a4cd8969af6">More...</a><br /></td></tr>
<tr class="separator:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5a8a33a97692e307634bf7db10cd6276">blaze::reset</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ga5a8a33a97692e307634bf7db10cd6276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="../../de/df1/group__math.html#ga5a8a33a97692e307634bf7db10cd6276">More...</a><br /></td></tr>
<tr class="separator:ga5a8a33a97692e307634bf7db10cd6276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga98a52ebee9e73c73f6492af64841cdca">blaze::clear</a> (const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga98a52ebee9e73c73f6492af64841cdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="../../de/df1/group__math.html#ga98a52ebee9e73c73f6492af64841cdca">More...</a><br /></td></tr>
<tr class="separator:ga98a52ebee9e73c73f6492af64841cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVectorProxy global functions</h2></td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">blaze::begin</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">More...</a><br /></td></tr>
<tr class="separator:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa64edd34b7ccc061871ebf7b372a0d1c">blaze::cbegin</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="../../de/df1/group__math.html#gaa64edd34b7ccc061871ebf7b372a0d1c">More...</a><br /></td></tr>
<tr class="separator:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a2eb393d47a7d6681303ec6729fe259">blaze::end</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7a2eb393d47a7d6681303ec6729fe259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga7a2eb393d47a7d6681303ec6729fe259">More...</a><br /></td></tr>
<tr class="separator:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1731ef12d4ac4b1847d616935cd74cc8">blaze::cend</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="../../de/df1/group__math.html#ga1731ef12d4ac4b1847d616935cd74cc8">More...</a><br /></td></tr>
<tr class="separator:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac0d73069d106d356f221e1dca36f86f8">blaze::size</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac0d73069d106d356f221e1dca36f86f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="../../de/df1/group__math.html#gac0d73069d106d356f221e1dca36f86f8">More...</a><br /></td></tr>
<tr class="separator:gac0d73069d106d356f221e1dca36f86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga16914bece2ebf39b5e72e42727593ffd">blaze::capacity</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga16914bece2ebf39b5e72e42727593ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="../../de/df1/group__math.html#ga16914bece2ebf39b5e72e42727593ffd">More...</a><br /></td></tr>
<tr class="separator:ga16914bece2ebf39b5e72e42727593ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae3c458777c59275735f874c6bb6b3dcc">blaze::nonZeros</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae3c458777c59275735f874c6bb6b3dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="../../de/df1/group__math.html#gae3c458777c59275735f874c6bb6b3dcc">More...</a><br /></td></tr>
<tr class="separator:gae3c458777c59275735f874c6bb6b3dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f67582634373482383eec8008558c6"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gaa3f67582634373482383eec8008558c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa3f67582634373482383eec8008558c6">blaze::resize</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve)</td></tr>
<tr class="memdesc:gaa3f67582634373482383eec8008558c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented vector.  <a href="../../de/df1/group__math.html#gaa3f67582634373482383eec8008558c6">More...</a><br /></td></tr>
<tr class="separator:gaa3f67582634373482383eec8008558c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad18d9138d144ff01dcf136f703443a80">blaze::reset</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad18d9138d144ff01dcf136f703443a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../de/df1/group__math.html#gad18d9138d144ff01dcf136f703443a80">More...</a><br /></td></tr>
<tr class="separator:gad18d9138d144ff01dcf136f703443a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga727608d5ba71b44eb89fb8d00e567c5f">blaze::clear</a> (const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../de/df1/group__math.html#ga727608d5ba71b44eb89fb8d00e567c5f">More...</a><br /></td></tr>
<tr class="separator:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga090953147f8df6ac6a13b15403d51dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga090953147f8df6ac6a13b15403d51dcf">&#9670;&nbsp;</a></span>BLAZE_THROW_DIVISION_BY_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_DIVISION_BY_ZERO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga2d588d35b3322949abb3a1e1c5ea3355">BLAZE_THROW_RUNTIME_ERROR</a>( MESSAGE )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of an exception on detection of a division by zero.This macro encapsulates the default way of <b>Blaze</b> to throw an exception on detection of a division by zero. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_DIVISION_BY_ZERO( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW_RUNTIME_ERROR( MESSAGE )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::runtime_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DivisionByZero</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   DivisionByZero();</div><div class="line">   <span class="keyword">explicit</span> DivisionByZero( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_DIVISION_BY_ZERO( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw DivisionByZero( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="gafae8e50beff90b25ee70e807154f350f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae8e50beff90b25ee70e807154f350f">&#9670;&nbsp;</a></span>BLAZE_THROW_LAPACK_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_LAPACK_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga2d588d35b3322949abb3a1e1c5ea3355">BLAZE_THROW_RUNTIME_ERROR</a>( MESSAGE )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of an exception on detection of a LAPACK error.This macro encapsulates the default way of <b>Blaze</b> to throw an exception when encountering a LAPACK error (for instance when trying to invert a singular matrix). Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_LAPACK_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW_RUNTIME_ERROR( MESSAGE )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::runtime_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LapackError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   LapackError();</div><div class="line">   <span class="keyword">explicit</span> LapackError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_LAPACK_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw LapackError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga629e225abfa7be1f41cff40ecd17d5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga629e225abfa7be1f41cff40ecd17d5d5">&#9670;&nbsp;</a></span>InversionFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/df1/group__math.html#ga629e225abfa7be1f41cff40ecd17d5d5">blaze::InversionFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion flag.The InversionFlag type enumeration represents the different types of matrix inversion algorithms that are available within the Blaze library. The following flags are available: </p>
<ul>
<li><code>byLU:</code> The default inversion algorithm for general square matrices. It uses the LU algorithm to decompose a matrix into a lower unitriangular matrix <code>L</code>, an upper triangular matrix <code>U</code>, and a permutation matrix <code>P</code> ( <img class="formulaInl" alt="$ A = P L U $" src="../../form_116.png"/>). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> no permutations are required, <code>P</code> is the identity matrix.</li>
<li><code>byLDLT:</code> The Bunch-Kaufman inversion algorithm for symmetric indefinite matrices. It decomposes the given matrix into either <img class="formulaInl" alt="$ A = U D U^{T} $" src="../../form_117.png"/> or <img class="formulaInl" alt="$ A = L D L^{T} $" src="../../form_118.png"/>, where <code>U</code> (or <code>L</code>) is a product of permutation and unit upper (lower) triangular matrices, and <code>D</code> is symmetric and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
<li><code>byLDLH:</code> The Bunch-Kaufman inversion algorithm for Hermitian indefinite matrices. It decomposes the given matrix into either <img class="formulaInl" alt="$ A = U D U^{H} $" src="../../form_119.png"/> or <img class="formulaInl" alt="$ A = L D L^{H} $" src="../../form_120.png"/>, where <code>U</code> (or <code>L</code>) is a product of permutation and unit upper (lower) triangular matrices, and <code>D</code> is Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</li>
<li><code>byLLH:</code> The Cholesky inversion algorithm for Hermitian positive definite matrices. It decomposes a given matrix into either <img class="formulaInl" alt="$ A = L L^H $" src="../../form_121.png"/>, where <code>L</code> is a lower triangular matrix, or <img class="formulaInl" alt="$ A = U^H U $" src="../../form_122.png"/>, where <code>U</code> is an upper triangular matrix.</li>
</ul>
<p>Alternatively, the type of the matrix can be specified, leaving it to the Blaze library to select the appropriate matrix inversion algorithm. The following flags are available:</p>
<ul>
<li><code>asGeneral:</code> This flag selects the best suited inversion algorithm for general square matrices. In case no further compile time information is available, this will imply the use of the LU decomposition algorithm (see the <code>byLU</code> flag).</li>
<li><code>asSymmetric:</code> This flag selects the most suited inversion algorithm for symmetric matrices. In case no further compile time information is available, the Bunch-Kaufman matrix decomposition algorithm will be used (see the <code>byLDLT</code> flag).</li>
<li><code>asHermitian:</code> This flag selects the most suited inversion algorithm for Hermitian matrices. In case no further compile time information is available, the Bunch-Kaufman matrix decomposition algorithm will be used (see the <code>byLDLH</code> flag).</li>
<li><code>asLower:</code> This flag selects the most suited inversion algorithm for lower triangular matrices. In case no further compile time information is available, the inversion will be performed by a forward substitution. No matrix decomposition will be performed.</li>
<li><code>asUniLower:</code> This flag selects the most suited inversion algorithm for lower unitriangular matrices. In case no further compile time information is available, the inversion will be performed by a forward substitution. No matrix decomposition will be performed.</li>
<li><code>asUpper:</code> This flag selects the most suited inversion algorithm for upper triangular matrices. In case no further compile time information is available, the inversion will be performed by a back substitution. No matrix decomposition will be performed.</li>
<li><code>asUniUpper:</code> This flag selects the most suited inversion algorithm for upper unitriangular matrices. In case no further compile time information is available, the inversion will be performed by a back substitution. No matrix decomposition will be performed.</li>
<li><code>asDiagonal:</code> This flag selects the most suited inversion algorithm for diagonal matrices. In case no further compile time information is available, the inversion will be performed by directly computing the reciprocal of each diagonal element. No matrix decomposition will be performed. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ac3740319e28f275c1b9fd29e1ac4f402"></a>byLU&#160;</td><td class="fielddoc"><p>Flag for the LU-based matrix inversion. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a0a5e1212ca55699fbc1c19afad9afee6"></a>byLDLT&#160;</td><td class="fielddoc"><p>Flag for the Bunch-Kaufman-based inversion for symmetric matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a9566686fdaf93d13a7905489fd7a53eb"></a>byLDLH&#160;</td><td class="fielddoc"><p>Flag for the Bunch-Kaufman-based inversion for Hermitian matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ad05ff6d0175d8cf4a91ea39ddb7c67a2"></a>byLLH&#160;</td><td class="fielddoc"><p>Flag for the Cholesky-based inversion for positive-definite matrices. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5adaef4901b1d62c57b7ecaef9fa0fdbce"></a>asGeneral&#160;</td><td class="fielddoc"><p>Flag for the inversion of a general matrix (same as byLU). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a53f1e0df9a2bb46e6e44b79cb7f37ca1"></a>asSymmetric&#160;</td><td class="fielddoc"><p>Flag for the inversion of a symmetric matrix (same as byLDLT). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a0b79760c443ca06f987410e9db671090"></a>asHermitian&#160;</td><td class="fielddoc"><p>Flag for the inversion of a Hermitian matrix (same as byLDLH). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a2037964c1bde635a44bec66e041f460e"></a>asLower&#160;</td><td class="fielddoc"><p>Flag for the inversion of a lower triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a1a71074238192f97c566b0de0a2ef232"></a>asUniLower&#160;</td><td class="fielddoc"><p>Flag for the inversion of a lower unitriangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a422d84660adc423063d501b5dc8e8f97"></a>asUpper&#160;</td><td class="fielddoc"><p>Flag for the inversion of a upper triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5a59dbf6f76744b544df87274e70c9d826"></a>asUniUpper&#160;</td><td class="fielddoc"><p>Flag for the inversion of a upper unitriangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga629e225abfa7be1f41cff40ecd17d5d5ab9559c7c7f5240b394de2072ef9c3de5"></a>asDiagonal&#160;</td><td class="fielddoc"><p>Flag for the inversion of a diagonal matrix. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga398ff45f7649293d4de247b5fa3cfc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398ff45f7649293d4de247b5fa3cfc60">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the absolute value of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of the represented element.</dd></dl>
<p>This function computes the absolute value of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the absolute values of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga9225ba03b89bdb120c24d4cc0c038d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9225ba03b89bdb120c24d4cc0c038d6b">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse cosine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of the represented element.</dd></dl>
<p>This function computes the inverse cosine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse cosines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga44e2ff7bc4439ef7012e944092bebda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44e2ff7bc4439ef7012e944092bebda9">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse hyperbolic cosine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of the represented element.</dd></dl>
<p>This function computes the inverse hyperbolic cosine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse hyperbolic cosines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gac120a95db76930ae4ff5b74fd2fb8ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac120a95db76930ae4ff5b74fd2fb8ade">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse sine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of the represented element.</dd></dl>
<p>This function computes the inverse sine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse sines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga6e8fcbbdf35c6dd931faf9cf05aef127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8fcbbdf35c6dd931faf9cf05aef127">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse hyperbolic sine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of the represented element.</dd></dl>
<p>This function computes the inverse hyperbolic sine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse hyperbolic sines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga6f4120822d2593a095244e6bf06ef4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f4120822d2593a095244e6bf06ef4d1">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse tangent of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of the represented element.</dd></dl>
<p>This function computes the inverse tangent of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse tangents of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gaa62126af52952804f47d2c4bae571f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62126af52952804f47d2c4bae571f0f">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse hyperbolic tangent of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of the represented element.</dd></dl>
<p>This function computes the inverse hyperbolic tangent of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse hyperbolic tangents of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga33cd8a737acd2b68cf33d84baad75bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33cd8a737acd2b68cf33d84baad75bf8">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="ga473e41444b6324cdd14e5a675b829f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga473e41444b6324cdd14e5a675b829f4a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="ga8d0d84fb462bcda9e4ac1b46da8f4e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="ga34acd458b656ec2167762cc3fb1bdd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34acd458b656ec2167762cc3fb1bdd1f">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="ga9ad8f51a4e5551c83c078c2729c2bece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad8f51a4e5551c83c078c2729c2bece">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a id="gabdce650ad06eb019f79bb6b7e92bf15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdce650ad06eb019f79bb6b7e92bf15d">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a id="gad086b7d12b02acd9fadbba5c105350c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad086b7d12b02acd9fadbba5c105350c0">&#9670;&nbsp;</a></span>capacity() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a id="ga16914bece2ebf39b5e72e42727593ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16914bece2ebf39b5e72e42727593ffd">&#9670;&nbsp;</a></span>capacity() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a id="gaf8d7b618c624d4911ae7f3882a05dc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d7b618c624d4911ae7f3882a05dc14">&#9670;&nbsp;</a></span>capacity() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a id="ga1c3df62b3c237c2a2b04fc28e7a20dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3df62b3c237c2a2b04fc28e7a20dcf">&#9670;&nbsp;</a></span>capacity() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a id="ga1552651c7e7b05385a91c477f198b92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1552651c7e7b05385a91c477f198b92c">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="gab5e4b8a71e6e426f52371c0d5b9846fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e4b8a71e6e426f52371c0d5b9846fd">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="gaa64edd34b7ccc061871ebf7b372a0d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64edd34b7ccc061871ebf7b372a0d1c">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a id="gaa97c7a3f2a26f8a8a918b3ef33ea1adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="ga5ae66c01ffa953265855b113197750a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae66c01ffa953265855b113197750a0">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the cubic root of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of the represented element.</dd></dl>
<p>This function computes the cubic root of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the cubic roots of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga2708e803abdf89f741ad6cec81087127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2708e803abdf89f741ad6cec81087127">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest integral value that is not less than the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest integral value that is not less than the represented element.</dd></dl>
<p>This function computes the smallest integral value that is not less than the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the operation. </p>

</div>
</div>
<a id="ga485df6bb7b74d08f29bcc446517f33bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga485df6bb7b74d08f29bcc446517f33bc">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="gacb1b473d7716b9abe090c3db5c8df431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb1b473d7716b9abe090c3db5c8df431">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides a <a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="ga1731ef12d4ac4b1847d616935cd74cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1731ef12d4ac4b1847d616935cd74cc8">&#9670;&nbsp;</a></span>cend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="ga58b9786b8a311ab1bf97f247f566edd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b9786b8a311ab1bf97f247f566edd9">&#9670;&nbsp;</a></span>cend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a67e310139c2b875a90b3bfe6ba36a441">ConstIterator</a> blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides a <a class="el" href="../../dd/d7a/group__matrix.html#ga096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="gae42eef9a424004a86df6fc9c4115c2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42eef9a424004a86df6fc9c4115c2bc">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default initial state. </p>

</div>
</div>
<a id="ga1d821c7a793e0c694258e2917bb44edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d821c7a793e0c694258e2917bb44edc">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the matrix to its default initial state. </p>

</div>
</div>
<a id="ga727608d5ba71b44eb89fb8d00e567c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga727608d5ba71b44eb89fb8d00e567c5f">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default initial state. </p>

</div>
</div>
<a id="ga98a52ebee9e73c73f6492af64841cdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a52ebee9e73c73f6492af64841cdca">&#9670;&nbsp;</a></span>clear() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the matrix to its default initial state. </p>

</div>
</div>
<a id="gaf184ec513c031b63bb72c7161f7f9f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf184ec513c031b63bb72c7161f7f9f5c">&#9670;&nbsp;</a></span>columns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of columns of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a id="gaa69887db471553a593455e9939bd20e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69887db471553a593455e9939bd20e8">&#9670;&nbsp;</a></span>columns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of columns of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a id="ga56a682039851e6805e808ca86cccfe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a682039851e6805e808ca86cccfe7c">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the complex conjugate of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of the represented element.</dd></dl>
<p>This function computes the complex conjugate of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the complex conjugate of the vector/matrix. </p>

</div>
</div>
<a id="ga6a4838341eafaf86ce33efd46996c7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a4838341eafaf86ce33efd46996c7a4">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the cosine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of the represented element.</dd></dl>
<p>This function computes the cosine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the cosines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga662008d3f3a266ab453b818202b96978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662008d3f3a266ab453b818202b96978">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the hyperbolic cosine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of the represented element.</dd></dl>
<p>This function computes the hyperbolic cosine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the hyperbolic cosines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga707644d2c2f3d1436e3fab5e3d1d9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707644d2c2f3d1436e3fab5e3d1d9030">&#9670;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the conjugate transpose of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of the represented element.</dd></dl>
<p>This function returns an expression representing the conjugate transpose of the element represented by the proxy. </p>

</div>
</div>
<a id="gaff7b7fcc6534302c97b09c07655902f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff7b7fcc6534302c97b09c07655902f5">&#9670;&nbsp;</a></span>ctranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::ctranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place conjugate transpose of the represented matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> cannot be transposed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function transposes the represented matrix in-place. The transpose operation fails if ...</p>
<ul>
<li>... the represented matrix has a fixed size and is non-square;</li>
<li>... the represented matrix is a triangular matrix.</li>
</ul>
<p>In all failure cases a <em>std::logic_error</em> exception is thrown. Additionally, in case the represented matrix cannot be modified, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="gab1425959f644eecd4d8a17f4c3b3220a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1425959f644eecd4d8a17f4c3b3220a">&#9670;&nbsp;</a></span>determineColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::determineColumns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; <a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the maximum number of columns specified by the given initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The given initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of columns. </dd></dl>

</div>
</div>
<a id="ga85346c256b6e74c93733704c6683314e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85346c256b6e74c93733704c6683314e">&#9670;&nbsp;</a></span>digits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::digits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of valid digits of an integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of valid digits.</dd></dl>
<p>This function counts the number of valid digits in the given integral value.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">digits</a>( 100   );  <span class="comment">// Returns 3</span></div><div class="line"><a class="code" href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">digits</a>( 12345 );  <span class="comment">// Returns 5</span></div><div class="line"><a class="code" href="../../de/df1/group__math.html#ga85346c256b6e74c93733704c6683314e">digits</a>( 0     );  <span class="comment">// Returns 0</span></div></div><!-- fragment --><p>The digits function only works for integral built-in data types. The attempt to use any other type will result in a compile time error. </p>

</div>
</div>
<a id="gad47f01490e02fe97e3e71003d70006b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47f01490e02fe97e3e71003d70006b1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="gabd12cbf050e7ee64aff69936d37d6b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd12cbf050e7ee64aff69936d37d6b97">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides an <a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="ga7a2eb393d47a7d6681303ec6729fe259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a2eb393d47a7d6681303ec6729fe259">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a id="gaff459171ee4708a8fc325de33d9345aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff459171ee4708a8fc325de33d9345aa">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d2/de9/namespaceblaze.html#a8edd0302e146f39097a411783a7214f5">Iterator</a> blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides an <a class="el" href="../../dd/d7a/group__matrix.html#ga7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="gaa6a60a1b44ec5ab81f86a4d50949b23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a60a1b44ec5ab81f86a4d50949b23c">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the error function of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of the represented element.</dd></dl>
<p>This function computes the error function of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the error functions of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga0d01823fadc543da32b2fccb1185d4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d01823fadc543da32b2fccb1185d4b7">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the complementary error function of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of the represented element.</dd></dl>
<p>This function computes the complementary error function of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the complementary error functions of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gae241307b6b6ab423bae5880475969740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae241307b6b6ab423bae5880475969740">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the base-e exponential of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base-e exponential of the represented element.</dd></dl>
<p>This function computes the base-e exponential of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the base-e exponentials of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga4c98f244bd3412fa43039b422a5c1a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c98f244bd3412fa43039b422a5c1a55">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integral value that is not greater than the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest integral value that is not greater than the represented element.</dd></dl>
<p>This function computes the largest integral value that is not greater than the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the operation. </p>

</div>
</div>
<a id="ga860b2a005ccfc06780298500cf874a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860b2a005ccfc06780298500cf874a79">&#9670;&nbsp;</a></span>greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool blaze::greater </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic greater-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the first value is greater than the second, <em>false</em> if not.</dd></dl>
<p>Generic greater-than comparison between to numeric values. Depending on the types of the two arguments, a special comparison for floating point values is selected that takes the limited machine accuracy into account. </p>

</div>
</div>
<a id="ga30bc1d8ded38e6629f3c73b7737912f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30bc1d8ded38e6629f3c73b7737912f8">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the imaginary part of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of the represented element.</dd></dl>
<p>This function returns the imaginary part of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the real part of each each element of the vector/matrix. </p>

</div>
</div>
<a id="ga3c50c7a27f701758ee5c16137a30fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c50c7a27f701758ee5c16137a30fb4e">&#9670;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse cubic root of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of the represented element.</dd></dl>
<p>This function computes the inverse cubic root of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse cubic roots of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga5b8198c1bb8ffdf1a77c3b3d3f01508d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8198c1bb8ffdf1a77c3b3d3f01508d">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Inversion of singular matrix failed. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the represented scalar or dense matrix element. The inversion fails if the represented element is a dense matrix, which ...</p>
<ul>
<li>... is not a square matrix;</li>
<li>... is singular and not invertible.</li>
</ul>
<p>In all failure cases either a compilation error is created if the failure can be predicted at compile time or a <em>std::invalid_argument</em> exception is thrown. Additionally, in case the represented scalar or matrix cannot be modified, a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>In case the represented element is a dense matrix, this function does not provide any exception safety guarantee, i.e. in case an exception is thrown the matrix may already have been modified.</dd>
<dd>
In case the represented element is a dense matrix, this function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created. </dd></dl>

</div>
</div>
<a id="gad6a33ec01ed8420e939104d4796438ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a33ec01ed8420e939104d4796438ad">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;InversionFlag IF, typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Inversion of singular matrix failed. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the represented dense matrix element by means of the specified matrix inversion algorithm <code>IF:</code> </p>
<div class="fragment"><div class="line">invert&lt;byLU&gt;( A );    <span class="comment">// Inversion of a general matrix</span></div><div class="line">invert&lt;byLDLT&gt;( A );  <span class="comment">// Inversion of a symmetric indefinite matrix</span></div><div class="line">invert&lt;byLDLH&gt;( A );  <span class="comment">// Inversion of a Hermitian indefinite matrix</span></div><div class="line">invert&lt;byLLH&gt;( A );   <span class="comment">// Inversion of a Hermitian positive definite matrix</span></div></div><!-- fragment --><p>The inversion fails if the represented dense matrix element ...</p>
<ul>
<li>... is not a square matrix;</li>
<li>... is singular and not invertible.</li>
</ul>
<p>In all failure cases either a compilation error is created if the failure can be predicted at compile time or a <em>std::invalid_argument</em> exception is thrown. Additionally, in case the represented scalar or matrix cannot be modified, a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>In case the represented element is a dense matrix, this function does not provide any exception safety guarantee, i.e. in case an exception is thrown the matrix may already have been modified.</dd>
<dd>
In case the represented element is a dense matrix, this function can only be used if the fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created. </dd></dl>

</div>
</div>
<a id="gaa8b3e1613b57575b202d4f8fff72321b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b3e1613b57575b202d4f8fff72321b">&#9670;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the inverse square root of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of the represented element.</dd></dl>
<p>This function computes the inverse square root of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the inverse square roots of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gae6ff9be338882a06b760b1b0563a6132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ff9be338882a06b760b1b0563a6132">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is not a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in not a number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the proxy is not a number (NaN). In case it is not a number, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga3371a8458f782f92f481585d2da5e387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3371a8458f782f92f481585d2da5e387">&#9670;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 1, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the proxy represents the numeric value 1. In case it is 1, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga4b758cdd3dfb8d64121d55fd549fdca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b758cdd3dfb8d64121d55fd549fdca1">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the element represents a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the element represents a real number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the proxy represents the a real number. In case the element is of built-in type, the function returns <em>true</em>. In case the element is of complex type, the function returns <em>true</em> if the imaginary part is equal to 0. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gac58140730d57c5b46c101906d60b6d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58140730d57c5b46c101906d60b6d9a">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 0, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the proxy represents the numeric value 0. In case it is 0, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga1d897a05236023eb2572750966bb1847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d897a05236023eb2572750966bb1847">&#9670;&nbsp;</a></span>less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr bool blaze::less </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic less-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the first value is less than the second, <em>false</em> if not.</dd></dl>
<p>Generic less-than comparison between to numeric values. Depending on the types of the two arguments, a special comparison for floating point values is selected that takes the limited machine accuracy into account. </p>

</div>
</div>
<a id="gafd6c16764418ffa6a233ea3027f5320b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd6c16764418ffa6a233ea3027f5320b">&#9670;&nbsp;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the maximum operation. </dd></dl>

</div>
</div>
<a id="gab7e6eb00b99cb69a0364229c0da02f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e6eb00b99cb69a0364229c0da02f1b">&#9670;&nbsp;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the maximum operation. </dd></dl>

</div>
</div>
<a id="gacd91f6bf3df0762ceabdfa6ee0839b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd91f6bf3df0762ceabdfa6ee0839b7a">&#9670;&nbsp;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../dc/d95/structblaze_1_1Maximum.html" title="Compile time value evaluation.The Maximum alias declaration selects the larger of the two given templ...">Maximum</a> of an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the maximum operation. </dd></dl>

</div>
</div>
<a id="ga6bcdf350f718ca13ae06ce5e27025221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bcdf350f718ca13ae06ce5e27025221">&#9670;&nbsp;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the minimum operation. </dd></dl>

</div>
</div>
<a id="ga6f53f853b5785eeba6c1827a1a971f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f53f853b5785eeba6c1827a1a971f3b">&#9670;&nbsp;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the minimum operation. </dd></dl>

</div>
</div>
<a id="gaeffd7c7fa673c6bcd3fc4321b27079a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeffd7c7fa673c6bcd3fc4321b27079a3">&#9670;&nbsp;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../da/d11/structblaze_1_1Minimum.html" title="Compile time value evaluation.The Minimum alias declaration selects the smaller of the two given temp...">Minimum</a> of an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the minimum operation. </dd></dl>

</div>
</div>
<a id="ga744c2cdcc27fba2af1d7f24043353bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga744c2cdcc27fba2af1d7f24043353bd9">&#9670;&nbsp;</a></span>nextMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> constexpr auto blaze::nextMultiple </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds up an integral value to the next multiple of a given factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The integral value to be rounded up <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
    <tr><td class="paramname">factor</td><td>The factor of the multiple <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multiple of the given factor.</dd></dl>
<p>This function rounds up the given integral value to the next multiple of the given integral factor. In case the integral value is already a multiple of the given factor, the value itself is returned. Note that the attempt to use the function with non-integral types results in a compilation error! </p>

</div>
</div>
<a id="gacb886f8afac581ea219e7fd9dfdf6c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb886f8afac581ea219e7fd9dfdf6c74">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a id="gaf98d55b3997a5e0666e9467aac2f383e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf98d55b3997a5e0666e9467aac2f383e">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a id="gade25555a94e648076982a8c68fb38b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade25555a94e648076982a8c68fb38b70">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a id="gae3c458777c59275735f874c6bb6b3dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c458777c59275735f874c6bb6b3dcc">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a id="gad8d4a1ad716a90d183a1f310887f678f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d4a1ad716a90d183a1f310887f678f">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a id="gabe8aa45ed742cea841472f9f575f9c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8aa45ed742cea841472f9f575f9c71">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a id="gae4abf1755e20af8b6ca00a9dc7f9483d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4abf1755e20af8b6ca00a9dc7f9483d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a id="gaa0ecf2893db8fefd3e0ce3adbc105505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ecf2893db8fefd3e0ce3adbc105505">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a id="ga0abe3334b771c6cee4333fbf990d6c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abe3334b771c6cee4333fbf990d6c12">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a id="ga54487f79ea60723216b11c6fb0320286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54487f79ea60723216b11c6fb0320286">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gac9163704380fe239f92c9aa2a2d21d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9163704380fe239f92c9aa2a2d21d2d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga6b91516b2c4be4334a58cb054b1a0680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b91516b2c4be4334a58cb054b1a0680">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga4e43d75015d84e3173a1353446944a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e43d75015d84e3173a1353446944a04">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga5e9f9352cad83e055316189fc57cb384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e9f9352cad83e055316189fc57cb384">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a id="gad4c05a37e71a0c3d7c4cdc3902a9aed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c05a37e71a0c3d7c4cdc3902a9aed0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga276208f7821e9194172f1485258d385c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276208f7821e9194172f1485258d385c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga1b125c455dda69ab246b146ca505bf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b125c455dda69ab246b146ca505bf09">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga18da095de4af19e5b2dd2652d4e99783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18da095de4af19e5b2dd2652d4e99783">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaed7f8cdce1a915934c959eb91f80cf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7f8cdce1a915934c959eb91f80cf50">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaf2d846866633d891a651d1ca34abcd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d846866633d891a651d1ca34abcd51">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga35624fa5c81fa4f70a5d03dc944c5411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35624fa5c81fa4f70a5d03dc944c5411">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a id="gae8505375a66afb5af9edd75b85ba5204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8505375a66afb5af9edd75b85ba5204">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a id="gaf708a331a30e78fda59df5b66de17b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf708a331a30e78fda59df5b66de17b63">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a id="ga7856e8e97381138ec49530fdbe0ec412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7856e8e97381138ec49530fdbe0ec412">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga36d73646abcac7bfd4727f62ae1c7df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d73646abcac7bfd4727f62ae1c7df2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaa4e53cb1174ec7cb23419fcaccbcbcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e53cb1174ec7cb23419fcaccbcbcc6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication. </dd></dl>

</div>
</div>
<a id="ga77d781ec61e6f1f5448e86b1f2720109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d781ec61e6f1f5448e86b1f2720109">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication. </dd></dl>

</div>
</div>
<a id="ga031d79d9eacb3e9e10be05bcbac470cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031d79d9eacb3e9e10be05bcbac470cf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication. </dd></dl>

</div>
</div>
<a id="ga197bdc8c4217ad5ef8a5f54da3cb4b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197bdc8c4217ad5ef8a5f54da3cb4b20">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition. </dd></dl>

</div>
</div>
<a id="ga39d39dd0af7eb18fe9bf555a5065dd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d39dd0af7eb18fe9bf555a5065dd36">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition. </dd></dl>

</div>
</div>
<a id="gababce4874fa2c7857cf2fee2bf865e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gababce4874fa2c7857cf2fee2bf865e3a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition. </dd></dl>

</div>
</div>
<a id="ga4b9b2651135b373f4b7f6189ade4ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9b2651135b373f4b7f6189ade4ac9f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction. </dd></dl>

</div>
</div>
<a id="gaea64dfa5c1a1c1dba8c4a4bc9da23830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea64dfa5c1a1c1dba8c4a4bc9da23830">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction. </dd></dl>

</div>
</div>
<a id="ga15c847511c877715c20b1163581c62ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c847511c877715c20b1163581c62ad">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction. </dd></dl>

</div>
</div>
<a id="ga49aeafd8e7c26ca6d406c7b8f3f5233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49aeafd8e7c26ca6d406c7b8f3f5233c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the division. </dd></dl>

</div>
</div>
<a id="ga4da703d60bec3ee1185e141e23814c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da703d60bec3ee1185e141e23814c48">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the division. </dd></dl>

</div>
</div>
<a id="gad5f392cba2dd5fcdf4c0de162fd69188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f392cba2dd5fcdf4c0de162fd69188">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the division. </dd></dl>

</div>
</div>
<a id="ga65821b80ccae33417341537e4227f868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65821b80ccae33417341537e4227f868">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gabd9b1816705651c2119a7cc80978ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9b1816705651c2119a7cc80978ad76">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga3a3dd16604cf5215b58366eacb4ffdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3dd16604cf5215b58366eacb4ffdf5">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga9beb59e8da6cadd29439976ad27ef720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9beb59e8da6cadd29439976ad27ef720">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga879147357f8a8a6ff8caa437aaf8d012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879147357f8a8a6ff8caa437aaf8d012">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga3e085f85d723050dd3472d1542642cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e085f85d723050dd3472d1542642cab">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga3c48a6793a1ffbabed19269784797d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c48a6793a1ffbabed19269784797d09">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga40820137079464541dfb2e509116cea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40820137079464541dfb2e509116cea9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga361e2f13326df36b40c3ac8fbc1ab6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361e2f13326df36b40c3ac8fbc1ab6e5">&#9670;&nbsp;</a></span>operator<() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floatin point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga0c8df923cf79e378abe78f578c2fd3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8df923cf79e378abe78f578c2fd3a4">&#9670;&nbsp;</a></span>operator<() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaa803d7476965f7923e5c0c4245d7924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa803d7476965f7923e5c0c4245d7924a">&#9670;&nbsp;</a></span>operator<() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaa14e76b894f5467df70d6d330fb66c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa14e76b894f5467df70d6d330fb66c0e">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">proxy</td><td>Reference to a constant proxy object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a id="gac24730d792522ea8882c06888e00ae7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24730d792522ea8882c06888e00ae7e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga3fa747aec154c780ba245ee5ab418c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa747aec154c780ba245ee5ab418c14">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga6c94aa2315bdbaece3d7f073f11b1b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c94aa2315bdbaece3d7f073f11b1b15">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga5e1bdb7c2e83533ec5900290f3db2926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e1bdb7c2e83533ec5900290f3db2926">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga3cec7da9b31a13bb88d11dcdc7b66acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cec7da9b31a13bb88d11dcdc7b66acf">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga75793d83615e27381df0bae5d84f89ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75793d83615e27381df0bae5d84f89ee">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga029ffd5d821432bad2f6145a8a08ab61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029ffd5d821432bad2f6145a8a08ab61">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga035d23379f82bda953132324d4aa17f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga035d23379f82bda953132324d4aa17f3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a id="ga8d24a75ffae866d00e584315058f28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d24a75ffae866d00e584315058f28ce">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a id="gaf07f5f4affa2e7b19de28dca9c35db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07f5f4affa2e7b19de28dca9c35db6b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga4c532eb39351f805537decf26b3d5fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c532eb39351f805537decf26b3d5fcd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga51a179498d07d4ec942a451ae92ec143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a179498d07d4ec942a451ae92ec143">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga236d08a02441df8ea0dbbb4c64749da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga236d08a02441df8ea0dbbb4c64749da4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaf72e3519f6f3e1222bb492165c1ff473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf72e3519f6f3e1222bb492165c1ff473">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a id="gac724ba633053ce342cb0e6a3045c6a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac724ba633053ce342cb0e6a3045c6a09">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga8690c52b43be431f700b2424340eab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8690c52b43be431f700b2424340eab78">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaa3d47826408e31a3384c39360dee2344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d47826408e31a3384c39360dee2344">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a id="gaf77696e0b4298236b50e604cf58fcaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77696e0b4298236b50e604cf58fcaf3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga901136b2bc679e7d3292cce75f539d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901136b2bc679e7d3292cce75f539d63">&#9670;&nbsp;</a></span>operator==() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga0a51f607694128250e09404f52b4b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a51f607694128250e09404f52b4b276">&#9670;&nbsp;</a></span>operator==() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga4fa7f20ac7fdbf6e0cc1d2a781902a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fa7f20ac7fdbf6e0cc1d2a781902a9c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga1cade862a899080b7219bb9468051f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cade862a899080b7219bb9468051f14">&#9670;&nbsp;</a></span>operator==() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a id="gae113fce8b3a8df1350075c2c4868983c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae113fce8b3a8df1350075c2c4868983c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a id="gae914b7ce7e8fcfcf0bf4fa8767fcb15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae914b7ce7e8fcfcf0bf4fa8767fcb15d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a id="gabdf89122a0bb9a848015b65506874909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf89122a0bb9a848015b65506874909">&#9670;&nbsp;</a></span>operator==() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaef34c0250b3f5dbfe8d24ed181650659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef34c0250b3f5dbfe8d24ed181650659">&#9670;&nbsp;</a></span>operator==() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga40f8244f6749d5d4f160add9f963c78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40f8244f6749d5d4f160add9f963c78d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gaaf9819fb4a78b96dc642b032680a4497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf9819fb4a78b96dc642b032680a4497">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga29c770742f7a66f838d35eff174546c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c770742f7a66f838d35eff174546c6">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gaf5b0cd82ed4b295a23206ca524bbb3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5b0cd82ed4b295a23206ca524bbb3ff">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga4567aade84dfbb24e1587dcfc8751cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4567aade84dfbb24e1587dcfc8751cf2">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga0c43f45835f32b4189017f2010c9f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c43f45835f32b4189017f2010c9f638">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga0b417ce7ce401e64c5da29f0eec6fc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b417ce7ce401e64c5da29f0eec6fc84">&#9670;&nbsp;</a></span>operator>() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga03d0a5fa15d8e3467e9e74403a4af36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d0a5fa15d8e3467e9e74403a4af36d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gab1539c7210c9d84eec0632d388022e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1539c7210c9d84eec0632d388022e57">&#9670;&nbsp;</a></span>operator>() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga7d2a20484cd688e10c1f783a62ccdf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d2a20484cd688e10c1f783a62ccdf57">&#9670;&nbsp;</a></span>operator>() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga892e97c8cb377a8f1f00ae8c451a2681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga892e97c8cb377a8f1f00ae8c451a2681">&#9670;&nbsp;</a></span>operator>() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gad59183d72b56569f5a047b9db01b780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59183d72b56569f5a047b9db01b780a">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT1 , typename RT1 , typename PT2 , typename RT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT1, RT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT2, RT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga707b8c99baea44f733cf706c1a290b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707b8c99baea44f733cf706c1a290b89">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename T , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga9d595be92d155c2b70cf206ec6beea16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d595be92d155c2b70cf206ec6beea16">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PT , typename RT , typename  = DisableIf_&lt; IsProxy&lt;T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga53f3ade227fca2dac380d0451ae70bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f3ade227fca2dac380d0451ae70bb1">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga47be5bbb98c25b6050f72022c7a1a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47be5bbb98c25b6050f72022c7a1a353">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="gae821d3d1c431b8ec5705eb979dd2238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae821d3d1c431b8ec5705eb979dd2238e">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga68791a44cbc4c754a1196485fa3a9a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68791a44cbc4c754a1196485fa3a9a37">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a id="ga87db2707c258b67bbb537ab6357cbd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87db2707c258b67bbb537ab6357cbd1a">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT , typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ET &amp;&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the exponential value of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of the represented element.</dd></dl>
<p>This function computes the exponential value of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the exponential value of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gaf97be5d1a9904df3e666598a377e840f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97be5d1a9904df3e666598a377e840f">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the real part of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of the represented element.</dd></dl>
<p>This function returns the real part of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the real part of each each element of the vector/matrix. </p>

</div>
</div>
<a id="ga5277ea1f337ba3a87d2dad48b609cec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5277ea1f337ba3a87d2dad48b609cec7">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented vector to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the vector to the default initial values. </p>

</div>
</div>
<a id="ga6b361008599fbe7c5ad3262ed1cf8bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b361008599fbe7c5ad3262ed1cf8bf9">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the matrix to the default initial values. </p>

</div>
</div>
<a id="ga218b5d7e25e582cf759a0ffb94d8f88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218b5d7e25e582cf759a0ffb94d8f88b">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements in the specified row/column of the given matrix to their default value. In case the given matrix is a <em>rowMajor</em> matrix the function resets the values in row <em>i</em>, if it is a <em>columnMajor</em> matrix the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a id="gad18d9138d144ff01dcf136f703443a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18d9138d144ff01dcf136f703443a80">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the vector to the default initial values. </p>

</div>
</div>
<a id="ga7df60d6b50394cad1e546a4cd8969af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df60d6b50394cad1e546a4cd8969af6">&#9670;&nbsp;</a></span>reset() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the matrix to the default initial values. </p>

</div>
</div>
<a id="ga5a8a33a97692e307634bf7db10cd6276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a8a33a97692e307634bf7db10cd6276">&#9670;&nbsp;</a></span>reset() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements in the specified row/column of the given matrix to their default value. In case the given matrix is a <em>rowMajor</em> matrix the function resets the values in row <em>i</em>, if it is a <em>columnMajor</em> matrix the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a id="ga413b7144866fb308fe121cf5b3695d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga413b7144866fb308fe121cf5b3695d0e">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing the size of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">n</td><td>The new size of the vector. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the vector should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> cannot be resized.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resizes the represented vector to the specified <em>size</em>. Note that in contrast to the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> member function, which is only available on resizable vector types, this function can be used on both resizable and non-resizable vectors. In case the type <em>VT</em> of the represented vector is resizable (i.e. provides a <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> function), the type-specific <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> member function is called. Depending on the type <em>VT</em>, this may result in the allocation of new dynamic memory and the invalidation of existing views (subvectors, ...). In case <em>VT</em> is non-resizable (i.e. does not provide a <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> function) and if the specified size is not identical to the current size of the vector, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="ga2bc381719659d4900cba8b887b072351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc381719659d4900cba8b887b072351">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing the size of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">m</td><td>The new number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The new number of columns of the matrix. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the matrix should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid resize arguments for square matrix. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> cannot be resized.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resizes the represented matrix to the specified dimensions. In contrast to the <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> member function, which is only available on resizable matrix types, this function can be used on both resizable and non-resizable matrices. In case the given matrix of type <em>MT</em> is resizable (i.e. provides a <code>resize</code> function) the type-specific <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> member function is called. Depending on the type <em>MT</em>, this may result in the allocation of new dynamic memory and the invalidation of existing views (submatrices, rows, columns, ...). Note that in case the matrix is a compile time square matrix (as for instance the <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">blaze::SymmetricMatrix</a> adaptor, ...) the specified number of rows must be identical to the number of columns. Otherwise a <em>std::invalid_argument</em> exception is thrown. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the matrix type <em>MT</em> is non-resizable (i.e. does not provide a <code><a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a></code> function) and if the specified number of rows and columns is not identical to the current number of rows and columns of the matrix, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="gaa3f67582634373482383eec8008558c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f67582634373482383eec8008558c6">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing the size of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">n</td><td>The new size of the vector. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the vector should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resizes the represented vector to the specified <em>size</em>. </p>

</div>
</div>
<a id="gad355337adec8b62593dc482cc5d01a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad355337adec8b62593dc482cc5d01a87">&#9670;&nbsp;</a></span>resize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing the size of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">m</td><td>The new number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The new number of columns of the matrix. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the matrix should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid resize arguments for square matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resizes the represented matrix to the specified dimensions. Note that in case the matrix is a compile time square matrix (as for instance the <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">blaze::SymmetricMatrix</a> adaptor, ...) the specified number of rows must be identical to the number of columns. Otherwise a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="ga9b7cec0953f0e0be2c5220bd61e6e2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b7cec0953f0e0be2c5220bd61e6e2e3">&#9670;&nbsp;</a></span>rows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of rows of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a id="ga51e08caafa4583f32333b5d17f1c4ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e08caafa4583f32333b5d17f1c4ef5">&#9670;&nbsp;</a></span>rows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of rows of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a id="gaffebe2fae5612534433dbd26a999fefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffebe2fae5612534433dbd26a999fefe">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int blaze::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the value is greater than zero, 0 if it is zero, and -1 if it is less than zero.</dd></dl>
<p>The sign function only works for built-in data types. The attempt to use any user-defined class type will result in a compile time error. </p>

</div>
</div>
<a id="gac865bbd940482afab2fc59df9bbd8e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac865bbd940482afab2fc59df9bbd8e77">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the sine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of the represented element.</dd></dl>
<p>This function computes the sine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the sines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gaf420e36ba03cf36fc84fe48b91f06f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf420e36ba03cf36fc84fe48b91f06f87">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the hyperbolic sine of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of the represented element.</dd></dl>
<p>This function computes the hyperbolic sine of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the hyperbolic sines of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga815b73881a05f1de2c4ed92521758c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815b73881a05f1de2c4ed92521758c22">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a id="gac0d73069d106d356f221e1dca36f86f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d73069d106d356f221e1dca36f86f8">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a id="gac8f7fc216f376647af34d833fd944016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8f7fc216f376647af34d833fd944016">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the square root of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of the represented element.</dd></dl>
<p>This function computes the square root of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the square roots of the elements of the vector/matrix. </p>

</div>
</div>
<a id="ga3b6c1c699dd48552d76fdc6fe1be5f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6c1c699dd48552d76fdc6fe1be5f91">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the tangent of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of the represented element.</dd></dl>
<p>This function computes the tangent of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the tangents of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gaa4a1649365d8adf3f8333a62599464b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4a1649365d8adf3f8333a62599464b9">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the hyperbolic tangent of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of the represented element.</dd></dl>
<p>This function computes the hyperbolic tangent of the element represented by the proxy. In case the proxy represents a vector- or matrix-like data structure the function returns an expression representing the hyperbolic tangents of the elements of the vector/matrix. </p>

</div>
</div>
<a id="gab5c2a2685a1cfa2612dbc9492ba370a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c2a2685a1cfa2612dbc9492ba370a0">&#9670;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computing the transpose of the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the represented element.</dd></dl>
<p>This function returns an expression representing the transpose of the element represented by the proxy. </p>

</div>
</div>
<a id="ga664fc6202989987071c22966ab8b18d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664fc6202989987071c22966ab8b18d5">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename RT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/df9/classblaze_1_1Proxy.html">Proxy</a>&lt; PT, RT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place transpose of the represented matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given proxy instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> cannot be transposed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function transposes the represented matrix in-place. The transpose operation fails if ...</p>
<ul>
<li>... the represented matrix has a fixed size and is non-square;</li>
<li>... the represented matrix is a triangular matrix.</li>
</ul>
<p>In all failure cases a <em>std::logic_error</em> exception is thrown. Additionally, in case the represented matrix cannot be modified, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gac02fbb3ef9a09baf0b5e7b32a55cf6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">&#9670;&nbsp;</a></span>aligned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::aligned = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alignment flag for aligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned subvector: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> VectorType = <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,columnVector&gt;</a>;</div><div class="line"></div><div class="line">VectorType v( 100UL );</div><div class="line">Subvector&lt;VectorType,aligned&gt; sv = subvector&lt;aligned&gt;( v, 8UL, 32UL );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2acdda4ff7a369ef66302e647ff0926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2acdda4ff7a369ef66302e647ff0926f">&#9670;&nbsp;</a></span>padded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::padded = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Padding flag for padded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as aligned. The following example demonstrates the setup of an aligned, padded custom column vector of size 7: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d0/d60/structblaze_1_1ArrayDelete.html">blaze::ArrayDelete</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vec( 16UL );</div><div class="line">CustomVector&lt;int,aligned,padded,columnVector&gt; a( &amp;vec[0], 7UL, 16UL );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa4c0db94efdf35b9bf1834ace9c48177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c0db94efdf35b9bf1834ace9c48177">&#9670;&nbsp;</a></span>unaligned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::unaligned = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alignment flag for unaligned vectors and matrices.Via this flag it is possible to specify subvectors, submatrices, custom vectors and matrices as unaligned. The following example demonstrates the setup of an unaligned subvector: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> VectorType = <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,columnVector&gt;</a>;</div><div class="line"></div><div class="line">VectorType v( 100UL );</div><div class="line">Subvector&lt;VectorType,unaligned&gt; sv = subvector&lt;unaligned&gt;( v, 10UL, 20UL );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1858f68dbe5aba0ded4e45358324e3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1858f68dbe5aba0ded4e45358324e3a1">&#9670;&nbsp;</a></span>unpadded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool blaze::unpadded = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Padding flag for unpadded vectors and matrices.Via this flag it is possible to specify custom vectors and matrices as unpadded. The following example demonstrates the setup of an unaligned, unpadded custom column vector of size 7: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vec( 7UL );</div><div class="line">CustomVector&lt;int,unaligned,unpadded,columnVector&gt; a( &amp;vec[0], 7UL );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:24 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
