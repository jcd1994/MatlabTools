<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Compile time constraints</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Compile time constraints<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac90b9f8f5e4c852f2f7f12d954894b87"><td class="memItemLeft" align="right" valign="top"><a id="gac90b9f8f5e4c852f2f7f12d954894b87"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gac90b9f8f5e4c852f2f7f12d954894b87">BLAZE_CONSTRAINT_MUST_BE_ADAPTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">blaze::IsAdaptor</a>&lt;T&gt;::value, &quot;Non-adaptor type detected&quot; )</td></tr>
<tr class="memdesc:gac90b9f8f5e4c852f2f7f12d954894b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an adaptor type (as for instance a LowerMatrix, UpperMatrix, or SymmetricMatrix) a compilation error is created. <br /></td></tr>
<tr class="separator:gac90b9f8f5e4c852f2f7f12d954894b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9916c2e462771a63a192f16567cebedf"><td class="memItemLeft" align="right" valign="top"><a id="ga9916c2e462771a63a192f16567cebedf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9916c2e462771a63a192f16567cebedf">BLAZE_CONSTRAINT_MUST_NOT_BE_ADAPTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">blaze::IsAdaptor</a>&lt;T&gt;::value, &quot;Adaptor type detected&quot; )</td></tr>
<tr class="memdesc:ga9916c2e462771a63a192f16567cebedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an adaptor type (as for instance LowerMatrix, UpperMatrix, or SymmetricMatrix) a compilation error is created. <br /></td></tr>
<tr class="separator:ga9916c2e462771a63a192f16567cebedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3768239030a73e9b009ef3205ad05eb1"><td class="memItemLeft" align="right" valign="top"><a id="ga3768239030a73e9b009ef3205ad05eb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3768239030a73e9b009ef3205ad05eb1">BLAZE_CONSTRAINT_MUST_BE_ADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html">blaze::IsAddExpr</a>&lt;T&gt;::value, &quot;Non-addition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga3768239030a73e9b009ef3205ad05eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an addition expression (i.e. a type derived from the AddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga3768239030a73e9b009ef3205ad05eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c46dc8afe6bb02c1153a7425000531"><td class="memItemLeft" align="right" valign="top"><a id="gaf9c46dc8afe6bb02c1153a7425000531"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf9c46dc8afe6bb02c1153a7425000531">BLAZE_CONSTRAINT_MUST_NOT_BE_ADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html">blaze::IsAddExpr</a>&lt;T&gt;::value, &quot;Addition expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf9c46dc8afe6bb02c1153a7425000531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an addition expression (i.e. a type derived from the AddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf9c46dc8afe6bb02c1153a7425000531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace81754134ffc6b5df2af8e8fd9d3e34"><td class="memItemLeft" align="right" valign="top"><a id="gace81754134ffc6b5df2af8e8fd9d3e34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gace81754134ffc6b5df2af8e8fd9d3e34">BLAZE_CONSTRAINT_MUST_BE_ALIGNED_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../de/d07/structblaze_1_1IsAligned.html">blaze::IsAligned</a>&lt;T&gt;::value, &quot;Non-aligned type detected&quot; )</td></tr>
<tr class="memdesc:gace81754134ffc6b5df2af8e8fd9d3e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not provide aligned data values with respect to the requirements of the available instruction set a compilation error is created. <br /></td></tr>
<tr class="separator:gace81754134ffc6b5df2af8e8fd9d3e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f31c089c759614e99a3560fc04772f"><td class="memItemLeft" align="right" valign="top"><a id="gac6f31c089c759614e99a3560fc04772f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gac6f31c089c759614e99a3560fc04772f">BLAZE_CONSTRAINT_MUST_NOT_BE_ALIGNED_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../de/d07/structblaze_1_1IsAligned.html">blaze::IsAligned</a>&lt;T&gt;::value, &quot;Aligned type detected&quot; )</td></tr>
<tr class="memdesc:gac6f31c089c759614e99a3560fc04772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does provide aligned data values with respect to the requirements of the available instruction set a compilation error is created. <br /></td></tr>
<tr class="separator:gac6f31c089c759614e99a3560fc04772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a587a66d52c40b40c3be430d5fc1c7"><td class="memItemLeft" align="right" valign="top"><a id="ga76a587a66d52c40b40c3be430d5fc1c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga76a587a66d52c40b40c3be430d5fc1c7">BLAZE_CONSTRAINT_MUST_BE_BINARYMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/da4/structblaze_1_1IsBinaryMapExpr.html">blaze::IsBinaryMapExpr</a>&lt;T&gt;::value, &quot;Non-binary map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga76a587a66d52c40b40c3be430d5fc1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a binary map expression (i.e. a type derived from the BinaryMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga76a587a66d52c40b40c3be430d5fc1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335a52564b0ec812b734469ccfdb7dad"><td class="memItemLeft" align="right" valign="top"><a id="ga335a52564b0ec812b734469ccfdb7dad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga335a52564b0ec812b734469ccfdb7dad">BLAZE_CONSTRAINT_MUST_NOT_BE_BINARYMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/da4/structblaze_1_1IsBinaryMapExpr.html">blaze::IsBinaryMapExpr</a>&lt;T&gt;::value, &quot;Binary map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga335a52564b0ec812b734469ccfdb7dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a binary map expression (i.e. a type derived from the BinaryMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga335a52564b0ec812b734469ccfdb7dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c1ebebe4f5e755a7f182a4d06942fee"><td class="memItemLeft" align="right" valign="top"><a id="ga1c1ebebe4f5e755a7f182a4d06942fee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1c1ebebe4f5e755a7f182a4d06942fee">BLAZE_CONSTRAINT_MUST_BE_BLAS_COMPATIBLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html">blaze::IsBLASCompatible</a>&lt;T&gt;::value, &quot;Non-BLAS compatible type detected&quot; )</td></tr>
<tr class="memdesc:ga1c1ebebe4f5e755a7f182a4d06942fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a BLAS compatible data type (i.e. float, double, complex&lt;float&gt;, or complex&lt;double&gt;), a compilation error is created. <br /></td></tr>
<tr class="separator:ga1c1ebebe4f5e755a7f182a4d06942fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadcd00e83d64ea164fb92114d862ae8b"><td class="memItemLeft" align="right" valign="top"><a id="gaadcd00e83d64ea164fb92114d862ae8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaadcd00e83d64ea164fb92114d862ae8b">BLAZE_CONSTRAINT_MUST_NOT_BE_BLAS_COMPATIBLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html">blaze::IsBLASCompatible</a>&lt;T&gt;::value, &quot;BLAS compatible type detected&quot; )</td></tr>
<tr class="memdesc:gaadcd00e83d64ea164fb92114d862ae8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a BLAS compatible type (i.e. float, double, complex&lt;float&gt;, or complex&lt;double&gt;), a compilation error is created. <br /></td></tr>
<tr class="separator:gaadcd00e83d64ea164fb92114d862ae8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93973271218a66fb7bedbfe67c5a127b"><td class="memItemLeft" align="right" valign="top"><a id="ga93973271218a66fb7bedbfe67c5a127b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga93973271218a66fb7bedbfe67c5a127b">BLAZE_CONSTRAINT_MUST_BE_COLUMN_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html">blaze::IsColumn</a>&lt;T&gt;::value, &quot;Non-column type detected&quot; )</td></tr>
<tr class="memdesc:ga93973271218a66fb7bedbfe67c5a127b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a column type (i.e. a dense or sparse column), a compilation error is created. <br /></td></tr>
<tr class="separator:ga93973271218a66fb7bedbfe67c5a127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f31ecd400b3e5e89529bc9483eb9e5"><td class="memItemLeft" align="right" valign="top"><a id="ga56f31ecd400b3e5e89529bc9483eb9e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga56f31ecd400b3e5e89529bc9483eb9e5">BLAZE_CONSTRAINT_MUST_NOT_BE_COLUMN_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html">blaze::IsColumn</a>&lt;T&gt;::value, &quot;Column type detected&quot; )</td></tr>
<tr class="memdesc:ga56f31ecd400b3e5e89529bc9483eb9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a column type (i.e. a dense or sparse column), a compilation error is created. <br /></td></tr>
<tr class="separator:ga56f31ecd400b3e5e89529bc9483eb9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4ea5aeb25cc03bd1254802b62ad333"><td class="memItemLeft" align="right" valign="top"><a id="gaeb4ea5aeb25cc03bd1254802b62ad333"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaeb4ea5aeb25cc03bd1254802b62ad333">BLAZE_CONSTRAINT_MUST_BE_COLUMN_MAJOR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">blaze::IsColumnMajorMatrix</a>&lt;T&gt;::value, &quot;Non-column-major matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaeb4ea5aeb25cc03bd1254802b62ad333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a column-major dense or sparse matrix type (i.e. a matrix type whose storage order is set to <em>true</em>) a compilation error is created. <br /></td></tr>
<tr class="separator:gaeb4ea5aeb25cc03bd1254802b62ad333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd957491661226bb0220cad1744b76a3"><td class="memItemLeft" align="right" valign="top"><a id="gafd957491661226bb0220cad1744b76a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafd957491661226bb0220cad1744b76a3">BLAZE_CONSTRAINT_MUST_NOT_BE_COLUMN_MAJOR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">blaze::IsColumnMajorMatrix</a>&lt;T&gt;::value, &quot;Column-major matrix type detected&quot; )</td></tr>
<tr class="memdesc:gafd957491661226bb0220cad1744b76a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a column-major dense or sparse matrix type (i.e. a matrix type whose storage order is set to <em>true</em>) a compilation error is created. <br /></td></tr>
<tr class="separator:gafd957491661226bb0220cad1744b76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038d2d773aeae200139fd658645d370a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga038d2d773aeae200139fd658645d370a">BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_COLUMNS</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga038d2d773aeae200139fd658645d370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the number of columns of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of columns is not equal, a compilation error is created. Note that in case the number of columns of either of the two matrix types cannot be determined no compilation error is created.  <a href="#ga038d2d773aeae200139fd658645d370a">More...</a><br /></td></tr>
<tr class="separator:ga038d2d773aeae200139fd658645d370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffcdb3e0ce146ff1239b60605b6d277"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3ffcdb3e0ce146ff1239b60605b6d277">BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_COLUMNS</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga3ffcdb3e0ce146ff1239b60605b6d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the number of columns of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of columns is equal, a compilation error is created. Note that in case the number of columns of either of the two matrix types cannot be determined no compilation error is created.  <a href="#ga3ffcdb3e0ce146ff1239b60605b6d277">More...</a><br /></td></tr>
<tr class="separator:ga3ffcdb3e0ce146ff1239b60605b6d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac785ed465a92f2c0d0c0701eaf9558"><td class="memItemLeft" align="right" valign="top"><a id="gadac785ed465a92f2c0d0c0701eaf9558"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gadac785ed465a92f2c0d0c0701eaf9558">BLAZE_CONSTRAINT_MUST_BE_COLUMN_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a>&lt;T&gt;::value, &quot;Non-column vector type detected&quot; )</td></tr>
<tr class="memdesc:gadac785ed465a92f2c0d0c0701eaf9558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a column dense or sparse vector type (i.e. a vector type whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a>) a compilation error is created. <br /></td></tr>
<tr class="separator:gadac785ed465a92f2c0d0c0701eaf9558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf7de0da260d4c0ed3fdcc372909d7"><td class="memItemLeft" align="right" valign="top"><a id="ga9ecf7de0da260d4c0ed3fdcc372909d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9ecf7de0da260d4c0ed3fdcc372909d7">BLAZE_CONSTRAINT_MUST_NOT_BE_COLUMN_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a>&lt;T&gt;::value, &quot;Column vector type detected&quot; )</td></tr>
<tr class="memdesc:ga9ecf7de0da260d4c0ed3fdcc372909d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a column dense or sparse vector type (i.e. a vector type whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a>) a compilation error is created. <br /></td></tr>
<tr class="separator:ga9ecf7de0da260d4c0ed3fdcc372909d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a17744d8ac173aecc87ff155cdc8f4c"><td class="memItemLeft" align="right" valign="top"><a id="ga5a17744d8ac173aecc87ff155cdc8f4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5a17744d8ac173aecc87ff155cdc8f4c">BLAZE_CONSTRAINT_MUST_BE_COMPUTATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">blaze::IsComputation</a>&lt;T&gt;::value, &quot;Non-computation type detected&quot; )</td></tr>
<tr class="memdesc:ga5a17744d8ac173aecc87ff155cdc8f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a computational expression (i.e. a type derived from the Computation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5a17744d8ac173aecc87ff155cdc8f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84dc05f2261f98b7cf2b55f20f0d5021"><td class="memItemLeft" align="right" valign="top"><a id="ga84dc05f2261f98b7cf2b55f20f0d5021"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga84dc05f2261f98b7cf2b55f20f0d5021">BLAZE_CONSTRAINT_MUST_NOT_BE_COMPUTATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">blaze::IsComputation</a>&lt;T&gt;::value, &quot;Computation type detected&quot; )</td></tr>
<tr class="memdesc:ga84dc05f2261f98b7cf2b55f20f0d5021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a computational expression (i.e. a type derived from the Computation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga84dc05f2261f98b7cf2b55f20f0d5021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebac9242815cb1aad76dda5a39bbeb8a"><td class="memItemLeft" align="right" valign="top"><a id="gaebac9242815cb1aad76dda5a39bbeb8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaebac9242815cb1aad76dda5a39bbeb8a">BLAZE_CONSTRAINT_MUST_HAVE_CONST_DATA_ACCESS</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../df/dd2/structblaze_1_1HasConstDataAccess.html">blaze::HasConstDataAccess</a>&lt;T&gt;::value, &quot;Type without const data access detected&quot; )</td></tr>
<tr class="memdesc:gaebac9242815cb1aad76dda5a39bbeb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not provide low-level data access to constant data, i.e. does not have a const 'data' member function, a compilation error is created. <br /></td></tr>
<tr class="separator:gaebac9242815cb1aad76dda5a39bbeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2288584c71b3ad4e7c2fd56128f73d6d"><td class="memItemLeft" align="right" valign="top"><a id="ga2288584c71b3ad4e7c2fd56128f73d6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2288584c71b3ad4e7c2fd56128f73d6d">BLAZE_CONSTRAINT_MUST_NOT_HAVE_CONST_DATA_ACCESS</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../df/dd2/structblaze_1_1HasConstDataAccess.html">blaze::HasConstDataAccess</a>&lt;T&gt;::value, &quot;Type with const data access detected&quot; )</td></tr>
<tr class="memdesc:ga2288584c71b3ad4e7c2fd56128f73d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does provide low-level data access to constant data, i.e. does have a const 'data' member function, a compilation error is created. <br /></td></tr>
<tr class="separator:ga2288584c71b3ad4e7c2fd56128f73d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab560e05f8e5d3ec34a9bf4842294f121"><td class="memItemLeft" align="right" valign="top"><a id="gab560e05f8e5d3ec34a9bf4842294f121"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab560e05f8e5d3ec34a9bf4842294f121">BLAZE_CONSTRAINT_MUST_BE_CROSSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html">blaze::IsCrossExpr</a>&lt;T&gt;::value, &quot;Non-cross product expression type detected&quot; )</td></tr>
<tr class="memdesc:gab560e05f8e5d3ec34a9bf4842294f121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a cross product expression (i.e. a type derived from the CrossExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab560e05f8e5d3ec34a9bf4842294f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b02a90e5c8d86b6e22f7238e442f71"><td class="memItemLeft" align="right" valign="top"><a id="gab1b02a90e5c8d86b6e22f7238e442f71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab1b02a90e5c8d86b6e22f7238e442f71">BLAZE_CONSTRAINT_MUST_NOT_BE_CROSSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html">blaze::IsCrossExpr</a>&lt;T&gt;::value, &quot;Cross product expression type detected&quot; )</td></tr>
<tr class="memdesc:gab1b02a90e5c8d86b6e22f7238e442f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a cross product expression (i.e. a type derived from the CrossExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab1b02a90e5c8d86b6e22f7238e442f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703e089960f77128eb4b5b6e0d0ba037"><td class="memItemLeft" align="right" valign="top"><a id="ga703e089960f77128eb4b5b6e0d0ba037"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga703e089960f77128eb4b5b6e0d0ba037">BLAZE_CONSTRAINT_MUST_BE_CUSTOM_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d1/df1/structblaze_1_1IsCustom.html">blaze::IsCustom</a>&lt;T&gt;::value, &quot;Non-custom type detected&quot; )</td></tr>
<tr class="memdesc:ga703e089960f77128eb4b5b6e0d0ba037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a custom data type, i.e. a custom vector or matrix, a compilation error is created. <br /></td></tr>
<tr class="separator:ga703e089960f77128eb4b5b6e0d0ba037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86817e7a9d4470cebd262f38707b0776"><td class="memItemLeft" align="right" valign="top"><a id="ga86817e7a9d4470cebd262f38707b0776"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga86817e7a9d4470cebd262f38707b0776">BLAZE_CONSTRAINT_MUST_NOT_BE_CUSTOM_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d1/df1/structblaze_1_1IsCustom.html">blaze::IsCustom</a>&lt;T&gt;::value, &quot;Custom type dected&quot; )</td></tr>
<tr class="memdesc:ga86817e7a9d4470cebd262f38707b0776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a custom data type, i.e. a custom vector or matrix, a compilation error is created. <br /></td></tr>
<tr class="separator:ga86817e7a9d4470cebd262f38707b0776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e678a229c3fe78ed3d73b86e69ca8c"><td class="memItemLeft" align="right" valign="top"><a id="ga91e678a229c3fe78ed3d73b86e69ca8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga91e678a229c3fe78ed3d73b86e69ca8c">BLAZE_CONSTRAINT_MUST_BE_DECLARATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/ddc/structblaze_1_1IsDeclaration.html">blaze::IsDeclaration</a>&lt;T&gt;::value, &quot;Non-declaration type detected&quot; )</td></tr>
<tr class="memdesc:ga91e678a229c3fe78ed3d73b86e69ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a declaration expression (i.e. a type derived from the Declaration base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga91e678a229c3fe78ed3d73b86e69ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813c72f4189461584dc5851fd6199e1d"><td class="memItemLeft" align="right" valign="top"><a id="ga813c72f4189461584dc5851fd6199e1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga813c72f4189461584dc5851fd6199e1d">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLARATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/ddc/structblaze_1_1IsDeclaration.html">blaze::IsDeclaration</a>&lt;T&gt;::value, &quot;Declaration type detected&quot; )</td></tr>
<tr class="memdesc:ga813c72f4189461584dc5851fd6199e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a declaration expression (i.e. a type derived from the Declaration base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga813c72f4189461584dc5851fd6199e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13387912508eaa7d86bbebf1440bd43"><td class="memItemLeft" align="right" valign="top"><a id="gaf13387912508eaa7d86bbebf1440bd43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf13387912508eaa7d86bbebf1440bd43">BLAZE_CONSTRAINT_MUST_BE_DECLDIAGEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html">blaze::IsDeclDiagExpr</a>&lt;T&gt;::value, &quot;Non-decldiag expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf13387912508eaa7d86bbebf1440bd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a decldiag expression (i.e. a type derived from the DeclDiagExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf13387912508eaa7d86bbebf1440bd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb08fdbea38054ab4ab922b2b253c78"><td class="memItemLeft" align="right" valign="top"><a id="gafcb08fdbea38054ab4ab922b2b253c78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafcb08fdbea38054ab4ab922b2b253c78">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLDIAGEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html">blaze::IsDeclDiagExpr</a>&lt;T&gt;::value, &quot;Decldiag expression type detected&quot; )</td></tr>
<tr class="memdesc:gafcb08fdbea38054ab4ab922b2b253c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a decldiag expression (i.e. a type derived from the DeclDiagExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gafcb08fdbea38054ab4ab922b2b253c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5790dfee37864f5aea0795e2294fa995"><td class="memItemLeft" align="right" valign="top"><a id="ga5790dfee37864f5aea0795e2294fa995"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5790dfee37864f5aea0795e2294fa995">BLAZE_CONSTRAINT_MUST_BE_DECLEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">blaze::IsDeclExpr</a>&lt;T&gt;::value, &quot;Non-declaration expression type detected&quot; )</td></tr>
<tr class="memdesc:ga5790dfee37864f5aea0795e2294fa995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a declaration expression (i.e. a type derived from the DeclExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5790dfee37864f5aea0795e2294fa995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfb77b71ad7a282ac52ee5e47e6101f"><td class="memItemLeft" align="right" valign="top"><a id="gacbfb77b71ad7a282ac52ee5e47e6101f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gacbfb77b71ad7a282ac52ee5e47e6101f">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">blaze::IsDeclExpr</a>&lt;T&gt;::value, &quot;Declaration expression type detected&quot; )</td></tr>
<tr class="memdesc:gacbfb77b71ad7a282ac52ee5e47e6101f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a declaration expression (i.e. a type derived from the DeclExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gacbfb77b71ad7a282ac52ee5e47e6101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7cb519f2e864c66a4fc29e50bdec91"><td class="memItemLeft" align="right" valign="top"><a id="gacd7cb519f2e864c66a4fc29e50bdec91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gacd7cb519f2e864c66a4fc29e50bdec91">BLAZE_CONSTRAINT_MUST_BE_DECLHERMEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html">blaze::IsDeclHermExpr</a>&lt;T&gt;::value, &quot;Non-declherm expression type detected&quot; )</td></tr>
<tr class="memdesc:gacd7cb519f2e864c66a4fc29e50bdec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a declherm expression (i.e. a type derived from the DeclHermExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gacd7cb519f2e864c66a4fc29e50bdec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d74a90f971bd51310993d99ba050f7c"><td class="memItemLeft" align="right" valign="top"><a id="ga2d74a90f971bd51310993d99ba050f7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2d74a90f971bd51310993d99ba050f7c">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLHERMEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html">blaze::IsDeclHermExpr</a>&lt;T&gt;::value, &quot;Declherm expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2d74a90f971bd51310993d99ba050f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a declherm expression (i.e. a type derived from the DeclHermExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2d74a90f971bd51310993d99ba050f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189e915823ad12d78bf4b97b1bb319ec"><td class="memItemLeft" align="right" valign="top"><a id="ga189e915823ad12d78bf4b97b1bb319ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga189e915823ad12d78bf4b97b1bb319ec">BLAZE_CONSTRAINT_MUST_BE_DECLLOWEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html">blaze::IsDeclLowExpr</a>&lt;T&gt;::value, &quot;Non-decllow expression type detected&quot; )</td></tr>
<tr class="memdesc:ga189e915823ad12d78bf4b97b1bb319ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a decllow expression (i.e. a type derived from the DeclLowExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga189e915823ad12d78bf4b97b1bb319ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacca3119873fe02926a49c487b012f7a1"><td class="memItemLeft" align="right" valign="top"><a id="gacca3119873fe02926a49c487b012f7a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gacca3119873fe02926a49c487b012f7a1">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLLOWEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html">blaze::IsDeclLowExpr</a>&lt;T&gt;::value, &quot;Decllow expression type detected&quot; )</td></tr>
<tr class="memdesc:gacca3119873fe02926a49c487b012f7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a decllow expression (i.e. a type derived from the DeclLowExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gacca3119873fe02926a49c487b012f7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8336b78d32dc49c01f790cf3786f8b8d"><td class="memItemLeft" align="right" valign="top"><a id="ga8336b78d32dc49c01f790cf3786f8b8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8336b78d32dc49c01f790cf3786f8b8d">BLAZE_CONSTRAINT_MUST_BE_DECLSYMEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html">blaze::IsDeclSymExpr</a>&lt;T&gt;::value, &quot;Non-declsym expression type detected&quot; )</td></tr>
<tr class="memdesc:ga8336b78d32dc49c01f790cf3786f8b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a declsym expression (i.e. a type derived from the DeclSymExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga8336b78d32dc49c01f790cf3786f8b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed45bba8ce7db82736b1e5ed402ff8e1"><td class="memItemLeft" align="right" valign="top"><a id="gaed45bba8ce7db82736b1e5ed402ff8e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaed45bba8ce7db82736b1e5ed402ff8e1">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLSYMEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html">blaze::IsDeclSymExpr</a>&lt;T&gt;::value, &quot;Declsym expression type detected&quot; )</td></tr>
<tr class="memdesc:gaed45bba8ce7db82736b1e5ed402ff8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a declsym expression (i.e. a type derived from the DeclSymExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaed45bba8ce7db82736b1e5ed402ff8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c91e6f9c6129407a46020824e2180a"><td class="memItemLeft" align="right" valign="top"><a id="ga43c91e6f9c6129407a46020824e2180a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga43c91e6f9c6129407a46020824e2180a">BLAZE_CONSTRAINT_MUST_BE_DECLUPPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html">blaze::IsDeclUppExpr</a>&lt;T&gt;::value, &quot;Non-declupp expression type detected&quot; )</td></tr>
<tr class="memdesc:ga43c91e6f9c6129407a46020824e2180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a declupp expression (i.e. a type derived from the DeclUppExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga43c91e6f9c6129407a46020824e2180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf237b421f76ccbd1b79f58b4cbdc4328"><td class="memItemLeft" align="right" valign="top"><a id="gaf237b421f76ccbd1b79f58b4cbdc4328"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf237b421f76ccbd1b79f58b4cbdc4328">BLAZE_CONSTRAINT_MUST_NOT_BE_DECLUPPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html">blaze::IsDeclUppExpr</a>&lt;T&gt;::value, &quot;Declupp expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf237b421f76ccbd1b79f58b4cbdc4328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a declupp expression (i.e. a type derived from the DeclUppExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf237b421f76ccbd1b79f58b4cbdc4328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d982374577a2fcf0789b0b13664f8b5"><td class="memItemLeft" align="right" valign="top"><a id="ga7d982374577a2fcf0789b0b13664f8b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga7d982374577a2fcf0789b0b13664f8b5">BLAZE_CONSTRAINT_MUST_BE_DENSE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">blaze::IsDenseMatrix</a>&lt;T&gt;::value, &quot;Non-dense matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga7d982374577a2fcf0789b0b13664f8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a dense, N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga7d982374577a2fcf0789b0b13664f8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291f7f2e59df3bd33ea1a8cf44c63858"><td class="memItemLeft" align="right" valign="top"><a id="ga291f7f2e59df3bd33ea1a8cf44c63858"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga291f7f2e59df3bd33ea1a8cf44c63858">BLAZE_CONSTRAINT_MUST_NOT_BE_DENSE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">blaze::IsDenseMatrix</a>&lt;T&gt;::value, &quot;Dense matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga291f7f2e59df3bd33ea1a8cf44c63858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a dense, N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga291f7f2e59df3bd33ea1a8cf44c63858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba118e7c529d56f012554aeedbac27f9"><td class="memItemLeft" align="right" valign="top"><a id="gaba118e7c529d56f012554aeedbac27f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaba118e7c529d56f012554aeedbac27f9">BLAZE_CONSTRAINT_MUST_BE_DENSE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">blaze::IsDenseVector</a>&lt;T&gt;::value, &quot;Non-dense vector type detected&quot; )</td></tr>
<tr class="memdesc:gaba118e7c529d56f012554aeedbac27f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a dense, N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaba118e7c529d56f012554aeedbac27f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a848f8dee050d7cd5d4273c8d2c63d"><td class="memItemLeft" align="right" valign="top"><a id="ga85a848f8dee050d7cd5d4273c8d2c63d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga85a848f8dee050d7cd5d4273c8d2c63d">BLAZE_CONSTRAINT_MUST_NOT_BE_DENSE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">blaze::IsDenseVector</a>&lt;T&gt;::value, &quot;Dense vector type detected&quot; )</td></tr>
<tr class="memdesc:ga85a848f8dee050d7cd5d4273c8d2c63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a dense, N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga85a848f8dee050d7cd5d4273c8d2c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad104744664416350ee9d63407b172df0"><td class="memItemLeft" align="right" valign="top"><a id="gad104744664416350ee9d63407b172df0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gad104744664416350ee9d63407b172df0">BLAZE_CONSTRAINT_MUST_BE_DIAGONAL_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">blaze::IsDiagonal</a>&lt;T&gt;::value, &quot;Non-diagonal matrix type detected&quot; )</td></tr>
<tr class="memdesc:gad104744664416350ee9d63407b172df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a diagonal matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gad104744664416350ee9d63407b172df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb83dcdf82f611389adeb821119f88b"><td class="memItemLeft" align="right" valign="top"><a id="gabcb83dcdf82f611389adeb821119f88b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabcb83dcdf82f611389adeb821119f88b">BLAZE_CONSTRAINT_MUST_NOT_BE_DIAGONAL_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">blaze::IsDiagonal</a>&lt;T&gt;::value, &quot;Diagonal matrix type detected&quot; )</td></tr>
<tr class="memdesc:gabcb83dcdf82f611389adeb821119f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a diagonal matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gabcb83dcdf82f611389adeb821119f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1740a97b549652b6511d9cd2f8918f2"><td class="memItemLeft" align="right" valign="top"><a id="gaa1740a97b549652b6511d9cd2f8918f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa1740a97b549652b6511d9cd2f8918f2">BLAZE_CONSTRAINT_MUST_BE_DIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html">blaze::IsDivExpr</a>&lt;T&gt;::value, &quot;Non-division expression type detected&quot; )</td></tr>
<tr class="memdesc:gaa1740a97b549652b6511d9cd2f8918f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a division expression (i.e. a type derived from the DivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaa1740a97b549652b6511d9cd2f8918f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af0d15934d7d8ef64c1ae3c04385814"><td class="memItemLeft" align="right" valign="top"><a id="ga2af0d15934d7d8ef64c1ae3c04385814"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2af0d15934d7d8ef64c1ae3c04385814">BLAZE_CONSTRAINT_MUST_NOT_BE_DIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html">blaze::IsDivExpr</a>&lt;T&gt;::value, &quot;Division expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2af0d15934d7d8ef64c1ae3c04385814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a division expression (i.e. a type derived from the DivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2af0d15934d7d8ef64c1ae3c04385814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d63e5ac6cecc5669a5f065f334923e"><td class="memItemLeft" align="right" valign="top"><a id="gab7d63e5ac6cecc5669a5f065f334923e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab7d63e5ac6cecc5669a5f065f334923e">BLAZE_CONSTRAINT_MUST_BE_EVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html">blaze::IsEvalExpr</a>&lt;T&gt;::value, &quot;Non-evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:gab7d63e5ac6cecc5669a5f065f334923e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an evaluation expression (i.e. a type derived from the EvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab7d63e5ac6cecc5669a5f065f334923e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149b0956311f55c8cff48ae3f03f0c1e"><td class="memItemLeft" align="right" valign="top"><a id="ga149b0956311f55c8cff48ae3f03f0c1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga149b0956311f55c8cff48ae3f03f0c1e">BLAZE_CONSTRAINT_MUST_NOT_BE_EVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html">blaze::IsEvalExpr</a>&lt;T&gt;::value, &quot;Evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga149b0956311f55c8cff48ae3f03f0c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an evaluation expression (i.e. a type derived from the EvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga149b0956311f55c8cff48ae3f03f0c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e66279ff47686b25da0e12f9614044b"><td class="memItemLeft" align="right" valign="top"><a id="ga6e66279ff47686b25da0e12f9614044b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6e66279ff47686b25da0e12f9614044b">BLAZE_CONSTRAINT_MUST_BE_EXPRESSION_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">blaze::IsExpression</a>&lt;T&gt;::value, &quot;Non-expression type detected&quot; )</td></tr>
<tr class="memdesc:ga6e66279ff47686b25da0e12f9614044b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an expression (i.e. a type derived from the Expression base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga6e66279ff47686b25da0e12f9614044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga463b3146ba81c0bdf00150accf2b1071"><td class="memItemLeft" align="right" valign="top"><a id="ga463b3146ba81c0bdf00150accf2b1071"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga463b3146ba81c0bdf00150accf2b1071">BLAZE_CONSTRAINT_MUST_NOT_BE_EXPRESSION_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">blaze::IsExpression</a>&lt;T&gt;::value, &quot;Expression type detected&quot; )</td></tr>
<tr class="memdesc:ga463b3146ba81c0bdf00150accf2b1071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an expression (i.e. a type derived from the Expression base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga463b3146ba81c0bdf00150accf2b1071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba79a20d651574ad3b0d8a77ebdf624"><td class="memItemLeft" align="right" valign="top"><a id="ga7ba79a20d651574ad3b0d8a77ebdf624"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga7ba79a20d651574ad3b0d8a77ebdf624">BLAZE_CONSTRAINT_MUST_BE_GENERAL_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d9/d23/structblaze_1_1IsGeneral.html">blaze::IsGeneral</a>&lt;T&gt;::value, &quot;Non-general matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga7ba79a20d651574ad3b0d8a77ebdf624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a general matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga7ba79a20d651574ad3b0d8a77ebdf624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05361f0fb33f645cee596d86f70fa4e9"><td class="memItemLeft" align="right" valign="top"><a id="ga05361f0fb33f645cee596d86f70fa4e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga05361f0fb33f645cee596d86f70fa4e9">BLAZE_CONSTRAINT_MUST_NOT_BE_GENERAL_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d9/d23/structblaze_1_1IsGeneral.html">blaze::IsGeneral</a>&lt;T&gt;::value, &quot;General matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga05361f0fb33f645cee596d86f70fa4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a general matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga05361f0fb33f645cee596d86f70fa4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c06b7f4ccaa927852baf8ec2325faa1"><td class="memItemLeft" align="right" valign="top"><a id="ga0c06b7f4ccaa927852baf8ec2325faa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0c06b7f4ccaa927852baf8ec2325faa1">BLAZE_CONSTRAINT_MUST_BE_HERMITIAN_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">blaze::IsHermitian</a>&lt;T&gt;::value, &quot;Non-Hermitian matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga0c06b7f4ccaa927852baf8ec2325faa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an Hermitian matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga0c06b7f4ccaa927852baf8ec2325faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb67f57b3483dd254c8f4b4a8b0bed2"><td class="memItemLeft" align="right" valign="top"><a id="ga2eb67f57b3483dd254c8f4b4a8b0bed2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2eb67f57b3483dd254c8f4b4a8b0bed2">BLAZE_CONSTRAINT_MUST_NOT_BE_HERMITIAN_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">blaze::IsHermitian</a>&lt;T&gt;::value, &quot;Hermitian matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga2eb67f57b3483dd254c8f4b4a8b0bed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an Hermitian matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga2eb67f57b3483dd254c8f4b4a8b0bed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4336046c863a215b0847a82191639e"><td class="memItemLeft" align="right" valign="top"><a id="gaaf4336046c863a215b0847a82191639e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaaf4336046c863a215b0847a82191639e">BLAZE_CONSTRAINT_MUST_BE_IDENTITY_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d1/db0/structblaze_1_1IsIdentity.html">blaze::IsIdentity</a>&lt;T&gt;::value, &quot;Non-identity matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaaf4336046c863a215b0847a82191639e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an identity matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaaf4336046c863a215b0847a82191639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff12a94812ac0fee4bab646023ffff3"><td class="memItemLeft" align="right" valign="top"><a id="gaaff12a94812ac0fee4bab646023ffff3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaaff12a94812ac0fee4bab646023ffff3">BLAZE_CONSTRAINT_MUST_NOT_BE_IDENTITY_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d1/db0/structblaze_1_1IsIdentity.html">blaze::IsIdentity</a>&lt;T&gt;::value, &quot;Identity matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaaff12a94812ac0fee4bab646023ffff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an identity matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaaff12a94812ac0fee4bab646023ffff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcdd85ac03101780169c833bd445a57"><td class="memItemLeft" align="right" valign="top"><a id="gaedcdd85ac03101780169c833bd445a57"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaedcdd85ac03101780169c833bd445a57">BLAZE_CONSTRAINT_MUST_BE_INVERTIBLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/dd5/structblaze_1_1IsInvertible.html">blaze::IsInvertible</a>&lt;T&gt;::value, &quot;Non-invertible type detected&quot; )</td></tr>
<tr class="memdesc:gaedcdd85ac03101780169c833bd445a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an invertible data type (i.e. a BLAS compatible type, <code>long double</code>, or any matrix with BLAS compatible element type), a compilation error is created. <br /></td></tr>
<tr class="separator:gaedcdd85ac03101780169c833bd445a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b0663c9df1af92f48550cd1721480a"><td class="memItemLeft" align="right" valign="top"><a id="ga24b0663c9df1af92f48550cd1721480a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga24b0663c9df1af92f48550cd1721480a">BLAZE_CONSTRAINT_MUST_NOT_BE_INVERTIBLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( !<a class="el" href="../../d4/dd5/structblaze_1_1IsInvertible.html">blaze::IsInvertible</a>&lt;T&gt;::value, &quot;Invertible type detected&quot; )</td></tr>
<tr class="memdesc:ga24b0663c9df1af92f48550cd1721480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an invertible data type (i.e. a BLAS compatible type, <code>long double</code>, or any matrix with BLAS compatible element type), a compilation error is created. <br /></td></tr>
<tr class="separator:ga24b0663c9df1af92f48550cd1721480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5f62a28e87947c3d36f13ebe4c085e"><td class="memItemLeft" align="right" valign="top"><a id="ga6a5f62a28e87947c3d36f13ebe4c085e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6a5f62a28e87947c3d36f13ebe4c085e">BLAZE_CONSTRAINT_MUST_BE_LOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">blaze::IsLower</a>&lt;T&gt;::value, &quot;Non-lower triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga6a5f62a28e87947c3d36f13ebe4c085e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a lower triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga6a5f62a28e87947c3d36f13ebe4c085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36e29a54d2949a9e86c7c6f54eda7b8"><td class="memItemLeft" align="right" valign="top"><a id="gaa36e29a54d2949a9e86c7c6f54eda7b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa36e29a54d2949a9e86c7c6f54eda7b8">BLAZE_CONSTRAINT_MUST_NOT_BE_LOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">blaze::IsLower</a>&lt;T&gt;::value, &quot;Lower triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaa36e29a54d2949a9e86c7c6f54eda7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a lower triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaa36e29a54d2949a9e86c7c6f54eda7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2ad676b00e33b42ef3b22f569bac83"><td class="memItemLeft" align="right" valign="top"><a id="ga2c2ad676b00e33b42ef3b22f569bac83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2c2ad676b00e33b42ef3b22f569bac83">BLAZE_CONSTRAINT_MUST_BE_MATEVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html">blaze::IsMatEvalExpr</a>&lt;T&gt;::value, &quot;Non-matrix evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2c2ad676b00e33b42ef3b22f569bac83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix evaluation expression (i.e. a type derived from the MatEvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2c2ad676b00e33b42ef3b22f569bac83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9a42c94d8d287d07fd0eed2cc1d946"><td class="memItemLeft" align="right" valign="top"><a id="ga0e9a42c94d8d287d07fd0eed2cc1d946"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0e9a42c94d8d287d07fd0eed2cc1d946">BLAZE_CONSTRAINT_MUST_NOT_BE_MATEVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html">blaze::IsMatEvalExpr</a>&lt;T&gt;::value, &quot;Matrix evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga0e9a42c94d8d287d07fd0eed2cc1d946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix evaluation expression (i.e. a type derived from the MatEvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga0e9a42c94d8d287d07fd0eed2cc1d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21cd88070b77d463a0bb0473b365f144"><td class="memItemLeft" align="right" valign="top"><a id="ga21cd88070b77d463a0bb0473b365f144"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga21cd88070b77d463a0bb0473b365f144">BLAZE_CONSTRAINT_MUST_BE_MATINVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html">blaze::IsMatInvExpr</a>&lt;T&gt;::value, &quot;Non-matrix inversion expression detected&quot; )</td></tr>
<tr class="memdesc:ga21cd88070b77d463a0bb0473b365f144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix inversion expression (i.e. a type derived from the MatInvExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga21cd88070b77d463a0bb0473b365f144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d219ef153e5010e7d8e71b499b73681"><td class="memItemLeft" align="right" valign="top"><a id="ga4d219ef153e5010e7d8e71b499b73681"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4d219ef153e5010e7d8e71b499b73681">BLAZE_CONSTRAINT_MUST_NOT_BE_MATINVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html">blaze::IsMatInvExpr</a>&lt;T&gt;::value, &quot;Matrix inversion expression detected&quot; )</td></tr>
<tr class="memdesc:ga4d219ef153e5010e7d8e71b499b73681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix inversion expression (i.e. a type derived from the MatInvExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga4d219ef153e5010e7d8e71b499b73681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a6fb4488135481d001185b0a0124a4"><td class="memItemLeft" align="right" valign="top"><a id="ga11a6fb4488135481d001185b0a0124a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga11a6fb4488135481d001185b0a0124a4">BLAZE_CONSTRAINT_MUST_BE_MATMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d62/structblaze_1_1IsMatMapExpr.html">blaze::IsMatMapExpr</a>&lt;T&gt;::value, &quot;Non-unary matrix map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga11a6fb4488135481d001185b0a0124a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a unary matrix map expression (i.e. a type derived from the MatMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga11a6fb4488135481d001185b0a0124a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afc7fcd8fb6bc07d8bcf59d35d72169"><td class="memItemLeft" align="right" valign="top"><a id="ga0afc7fcd8fb6bc07d8bcf59d35d72169"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0afc7fcd8fb6bc07d8bcf59d35d72169">BLAZE_CONSTRAINT_MUST_NOT_BE_MATMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d62/structblaze_1_1IsMatMapExpr.html">blaze::IsMatMapExpr</a>&lt;T&gt;::value, &quot;Unary matrix map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga0afc7fcd8fb6bc07d8bcf59d35d72169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a unary matrix map expression (i.e. a type derived from the MatMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga0afc7fcd8fb6bc07d8bcf59d35d72169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1270a64f44280c023ff4a8d56006ea9"><td class="memItemLeft" align="right" valign="top"><a id="gaf1270a64f44280c023ff4a8d56006ea9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf1270a64f44280c023ff4a8d56006ea9">BLAZE_CONSTRAINT_MUST_BE_MATMATADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">blaze::IsMatMatAddExpr</a>&lt;T&gt;::value, &quot;Non-matrix/matrix addition expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf1270a64f44280c023ff4a8d56006ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/matrix addition expression (i.e. a type derived from the MatMatAddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf1270a64f44280c023ff4a8d56006ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f78409481cc19d2329f5405c2ef0d6"><td class="memItemLeft" align="right" valign="top"><a id="ga63f78409481cc19d2329f5405c2ef0d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga63f78409481cc19d2329f5405c2ef0d6">BLAZE_CONSTRAINT_MUST_NOT_BE_MATMATADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">blaze::IsMatMatAddExpr</a>&lt;T&gt;::value, &quot;Matrix/matrix addition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga63f78409481cc19d2329f5405c2ef0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/matrix addition expression (i.e. a type derived from the MatMatAddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga63f78409481cc19d2329f5405c2ef0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab612133c7a5935690f612581f00fbb5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab612133c7a5935690f612581f00fbb5a">BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATADDEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:gab612133c7a5935690f612581f00fbb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix addition, a compilation error is created.  <a href="#gab612133c7a5935690f612581f00fbb5a">More...</a><br /></td></tr>
<tr class="separator:gab612133c7a5935690f612581f00fbb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23db3a660334a08bb7ee51b233f252ef"><td class="memItemLeft" align="right" valign="top"><a id="ga23db3a660334a08bb7ee51b233f252ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga23db3a660334a08bb7ee51b233f252ef">BLAZE_CONSTRAINT_MUST_BE_MATMATMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d3/d5a/structblaze_1_1IsMatMatMapExpr.html">blaze::IsMatMatMapExpr</a>&lt;T&gt;::value, &quot;Non-binary matrix map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga23db3a660334a08bb7ee51b233f252ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a binary matrix map expression (i.e. a type derived from the MatMatMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga23db3a660334a08bb7ee51b233f252ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf21869e6904e2bcc86c1bcb98ef70f7"><td class="memItemLeft" align="right" valign="top"><a id="gadf21869e6904e2bcc86c1bcb98ef70f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gadf21869e6904e2bcc86c1bcb98ef70f7">BLAZE_CONSTRAINT_MUST_NOT_BE_MATMATMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d3/d5a/structblaze_1_1IsMatMatMapExpr.html">blaze::IsMatMatMapExpr</a>&lt;T&gt;::value, &quot;Binary matrix map expression type detected&quot; )</td></tr>
<tr class="memdesc:gadf21869e6904e2bcc86c1bcb98ef70f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a binary matrix map expression (i.e. a type derived from the MatMatMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gadf21869e6904e2bcc86c1bcb98ef70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27eee297f9dd08c98aabbd1fa3b3e3b9"><td class="memItemLeft" align="right" valign="top"><a id="ga27eee297f9dd08c98aabbd1fa3b3e3b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga27eee297f9dd08c98aabbd1fa3b3e3b9">BLAZE_CONSTRAINT_MUST_BE_MATMATMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">blaze::IsMatMatMultExpr</a>&lt;T&gt;::value, &quot;Non-matrix/matrix multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga27eee297f9dd08c98aabbd1fa3b3e3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/matrix multiplication expression (i.e. a type derived from the MatMatMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga27eee297f9dd08c98aabbd1fa3b3e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6b166a7725e11e55304f1368548eaa"><td class="memItemLeft" align="right" valign="top"><a id="ga5b6b166a7725e11e55304f1368548eaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5b6b166a7725e11e55304f1368548eaa">BLAZE_CONSTRAINT_MUST_NOT_BE_MATMATMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">blaze::IsMatMatMultExpr</a>&lt;T&gt;::value, &quot;Matrix/matrix multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga5b6b166a7725e11e55304f1368548eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/matrix multiplication expression (i.e. a type derived from the MatMatMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5b6b166a7725e11e55304f1368548eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b648c6fd2e9f5190410d2c9c10ad86b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3b648c6fd2e9f5190410d2c9c10ad86b">BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATMULTEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga3b648c6fd2e9f5190410d2c9c10ad86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix multiplication, a compilation error is created.  <a href="#ga3b648c6fd2e9f5190410d2c9c10ad86b">More...</a><br /></td></tr>
<tr class="separator:ga3b648c6fd2e9f5190410d2c9c10ad86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8839a2491e3fdaaf69c527f4ca886936"><td class="memItemLeft" align="right" valign="top"><a id="ga8839a2491e3fdaaf69c527f4ca886936"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8839a2491e3fdaaf69c527f4ca886936">BLAZE_CONSTRAINT_MUST_BE_MATMATSUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">blaze::IsMatMatSubExpr</a>&lt;T&gt;::value, &quot;Non-matrix/matrix subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:ga8839a2491e3fdaaf69c527f4ca886936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/matrix subtraction expression (i.e. a type derived from the MatMatSubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga8839a2491e3fdaaf69c527f4ca886936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30bfb72e05cf8f6331d7ea264cda9d3"><td class="memItemLeft" align="right" valign="top"><a id="gaf30bfb72e05cf8f6331d7ea264cda9d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf30bfb72e05cf8f6331d7ea264cda9d3">BLAZE_CONSTRAINT_MUST_NOT_BE_MATMATSUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">blaze::IsMatMatSubExpr</a>&lt;T&gt;::value, &quot;Matrix/matrix subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf30bfb72e05cf8f6331d7ea264cda9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/matrix subtraction expression (i.e. a type derived from the MatMatSubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf30bfb72e05cf8f6331d7ea264cda9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f86f7f7591b991fccc9cc2aba65f0ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1f86f7f7591b991fccc9cc2aba65f0ef">BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATSUBEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga1f86f7f7591b991fccc9cc2aba65f0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix subtraction, a compilation error is created.  <a href="#ga1f86f7f7591b991fccc9cc2aba65f0ef">More...</a><br /></td></tr>
<tr class="separator:ga1f86f7f7591b991fccc9cc2aba65f0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a80b555b5f88b6ed919ff2909c813f3"><td class="memItemLeft" align="right" valign="top"><a id="ga0a80b555b5f88b6ed919ff2909c813f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0a80b555b5f88b6ed919ff2909c813f3">BLAZE_CONSTRAINT_MUST_BE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a>&lt;T&gt;::value, &quot;Non-matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga0a80b555b5f88b6ed919ff2909c813f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga0a80b555b5f88b6ed919ff2909c813f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e5d89b894bf035c91a3311aa741ab2"><td class="memItemLeft" align="right" valign="top"><a id="ga67e5d89b894bf035c91a3311aa741ab2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga67e5d89b894bf035c91a3311aa741ab2">BLAZE_CONSTRAINT_MUST_NOT_BE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a>&lt;T&gt;::value, &quot;Matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga67e5d89b894bf035c91a3311aa741ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga67e5d89b894bf035c91a3311aa741ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776c6bd9b3186fe565ef362660804afb"><td class="memItemLeft" align="right" valign="top"><a id="ga776c6bd9b3186fe565ef362660804afb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga776c6bd9b3186fe565ef362660804afb">BLAZE_CONSTRAINT_MUST_BE_MATSCALARDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html">blaze::IsMatScalarDivExpr</a>&lt;T&gt;::value, &quot;Non-matrix/scalar division expression type detected&quot; )</td></tr>
<tr class="memdesc:ga776c6bd9b3186fe565ef362660804afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/scalar division expression (i.e. a type derived from the MatScalarDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga776c6bd9b3186fe565ef362660804afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33e47a61a86fe25eeb519f9ca5f3b6f"><td class="memItemLeft" align="right" valign="top"><a id="gab33e47a61a86fe25eeb519f9ca5f3b6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab33e47a61a86fe25eeb519f9ca5f3b6f">BLAZE_CONSTRAINT_MUST_NOT_BE_MATSCALARDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html">blaze::IsMatScalarDivExpr</a>&lt;T&gt;::value, &quot;Matrix/scalar division expression type detected&quot; )</td></tr>
<tr class="memdesc:gab33e47a61a86fe25eeb519f9ca5f3b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/scalar division expression (i.e. a type derived from the MatScalarDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab33e47a61a86fe25eeb519f9ca5f3b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38433898c84e0b4319801c426f7c917"><td class="memItemLeft" align="right" valign="top"><a id="gad38433898c84e0b4319801c426f7c917"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gad38433898c84e0b4319801c426f7c917">BLAZE_CONSTRAINT_MUST_BE_MATSCALARMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html">blaze::IsMatScalarMultExpr</a>&lt;T&gt;::value, &quot;Non-matrix/scalar multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:gad38433898c84e0b4319801c426f7c917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/scalar multiplication expression (i.e. a type derived from the MatScalarMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gad38433898c84e0b4319801c426f7c917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11b8cb7d0735380555dfdb108a3293b1"><td class="memItemLeft" align="right" valign="top"><a id="ga11b8cb7d0735380555dfdb108a3293b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga11b8cb7d0735380555dfdb108a3293b1">BLAZE_CONSTRAINT_MUST_NOT_BE_MATSCALARMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html">blaze::IsMatScalarMultExpr</a>&lt;T&gt;::value, &quot;Matrix/scalar multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga11b8cb7d0735380555dfdb108a3293b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/scalar multiplication expression (i.e. a type derived from the MatScalarMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga11b8cb7d0735380555dfdb108a3293b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c23254513f6b3ddbec644726b78664c"><td class="memItemLeft" align="right" valign="top"><a id="ga4c23254513f6b3ddbec644726b78664c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4c23254513f6b3ddbec644726b78664c">BLAZE_CONSTRAINT_MUST_BE_MATSERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html">blaze::IsMatSerialExpr</a>&lt;T&gt;::value, &quot;Non-matrix serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga4c23254513f6b3ddbec644726b78664c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix serial evaluation expression (i.e. a type derived from the MatSerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga4c23254513f6b3ddbec644726b78664c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695b07d2352866129335e09ed9a80e81"><td class="memItemLeft" align="right" valign="top"><a id="ga695b07d2352866129335e09ed9a80e81"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga695b07d2352866129335e09ed9a80e81">BLAZE_CONSTRAINT_MUST_NOT_BE_MATSERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html">blaze::IsMatSerialExpr</a>&lt;T&gt;::value, &quot;Matrix serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga695b07d2352866129335e09ed9a80e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix serial evaluation expression (i.e. a type derived from the MatSerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga695b07d2352866129335e09ed9a80e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37719df2c2a69671912243c5177367d6"><td class="memItemLeft" align="right" valign="top"><a id="ga37719df2c2a69671912243c5177367d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga37719df2c2a69671912243c5177367d6">BLAZE_CONSTRAINT_MUST_BE_MATTRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html">blaze::IsMatTransExpr</a>&lt;T&gt;::value, &quot;Non-matrix transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga37719df2c2a69671912243c5177367d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix transposition expression (i.e. a type derived from the MatTransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga37719df2c2a69671912243c5177367d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab786935a1624d7a9540c13aeb45a1b51"><td class="memItemLeft" align="right" valign="top"><a id="gab786935a1624d7a9540c13aeb45a1b51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab786935a1624d7a9540c13aeb45a1b51">BLAZE_CONSTRAINT_MUST_NOT_BE_MATTRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html">blaze::IsMatTransExpr</a>&lt;T&gt;::value, &quot;Matrix transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:gab786935a1624d7a9540c13aeb45a1b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix transposition expression (i.e. a type derived from the MatTransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab786935a1624d7a9540c13aeb45a1b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2d3c3798e592bbfe90463b0515abc6"><td class="memItemLeft" align="right" valign="top"><a id="ga8c2d3c3798e592bbfe90463b0515abc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8c2d3c3798e592bbfe90463b0515abc6">BLAZE_CONSTRAINT_MUST_BE_MATVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">blaze::IsMatVecMultExpr</a>&lt;T&gt;::value, &quot;Non-matrix/vector multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga8c2d3c3798e592bbfe90463b0515abc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a matrix/vector multiplication expression (i.e. a type derived from the MatVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga8c2d3c3798e592bbfe90463b0515abc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eda7813f47511ee5e366a26d4797be2"><td class="memItemLeft" align="right" valign="top"><a id="ga4eda7813f47511ee5e366a26d4797be2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4eda7813f47511ee5e366a26d4797be2">BLAZE_CONSTRAINT_MUST_NOT_BE_MATVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">blaze::IsMatVecMultExpr</a>&lt;T&gt;::value, &quot;Matrix/vector multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga4eda7813f47511ee5e366a26d4797be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a matrix/vector multiplication expression (i.e. a type derived from the MatVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga4eda7813f47511ee5e366a26d4797be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7e027ea65317a59d6b270c117ed827"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8a7e027ea65317a59d6b270c117ed827">BLAZE_CONSTRAINT_MUST_FORM_VALID_MATVECMULTEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga8a7e027ea65317a59d6b270c117ed827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/vector multiplication, a compilation error is created.  <a href="#ga8a7e027ea65317a59d6b270c117ed827">More...</a><br /></td></tr>
<tr class="separator:ga8a7e027ea65317a59d6b270c117ed827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e8007aae83219805dbb4c49fc38fdb"><td class="memItemLeft" align="right" valign="top"><a id="gaf9e8007aae83219805dbb4c49fc38fdb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf9e8007aae83219805dbb4c49fc38fdb">BLAZE_CONSTRAINT_MUST_BE_MULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html">blaze::IsMultExpr</a>&lt;T&gt;::value, &quot;Non-multiplication expression detected&quot; )</td></tr>
<tr class="memdesc:gaf9e8007aae83219805dbb4c49fc38fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a multiplication expression (i.e. a type derived from the MultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf9e8007aae83219805dbb4c49fc38fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9271bc6c3db385542108062755c8ca6f"><td class="memItemLeft" align="right" valign="top"><a id="ga9271bc6c3db385542108062755c8ca6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9271bc6c3db385542108062755c8ca6f">BLAZE_CONSTRAINT_MUST_NOT_BE_MULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html">blaze::IsMultExpr</a>&lt;T&gt;::value, &quot;Multiplication expression detected&quot; )</td></tr>
<tr class="memdesc:ga9271bc6c3db385542108062755c8ca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a multiplication expression (i.e. a type derived from the MultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga9271bc6c3db385542108062755c8ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e04c54141a9ecf053c6defa8a86b1ef"><td class="memItemLeft" align="right" valign="top"><a id="ga9e04c54141a9ecf053c6defa8a86b1ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9e04c54141a9ecf053c6defa8a86b1ef">BLAZE_CONSTRAINT_MUST_HAVE_MUTABLE_DATA_ACCESS</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html">blaze::HasMutableDataAccess</a>&lt;T&gt;::value, &quot;Type without mutable data access detected&quot; )</td></tr>
<tr class="memdesc:ga9e04c54141a9ecf053c6defa8a86b1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not provide low-level data access to mutable data, i.e. does not have a non-const 'data' member function, a compilation error is created. <br /></td></tr>
<tr class="separator:ga9e04c54141a9ecf053c6defa8a86b1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c1267c2680f35654e83ea04cfb6d4f"><td class="memItemLeft" align="right" valign="top"><a id="ga18c1267c2680f35654e83ea04cfb6d4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga18c1267c2680f35654e83ea04cfb6d4f">BLAZE_CONSTRAINT_MUST_NOT_HAVE_MUTABLE_DATA_ACCESS</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html">blaze::HasMutableDataAccess</a>&lt;T&gt;::value, &quot;Type with mutable data access detected&quot; )</td></tr>
<tr class="memdesc:ga18c1267c2680f35654e83ea04cfb6d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does provide low-level data access to mutable data, i.e. does have a non-const 'data' member function, a compilation error is created. <br /></td></tr>
<tr class="separator:ga18c1267c2680f35654e83ea04cfb6d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga640733252a6bb5c6bd9fc6ac9aee6116"><td class="memItemLeft" align="right" valign="top"><a id="ga640733252a6bb5c6bd9fc6ac9aee6116"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga640733252a6bb5c6bd9fc6ac9aee6116">BLAZE_CONSTRAINT_MUST_BE_NUMERIC_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/d83/structblaze_1_1IsNumericMatrix.html">blaze::IsNumericMatrix</a>&lt;T&gt;::value, &quot;Non-numeric matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga640733252a6bb5c6bd9fc6ac9aee6116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a numeric matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga640733252a6bb5c6bd9fc6ac9aee6116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73380803a47415cd2a58a29bf66340b2"><td class="memItemLeft" align="right" valign="top"><a id="ga73380803a47415cd2a58a29bf66340b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga73380803a47415cd2a58a29bf66340b2">BLAZE_CONSTRAINT_MUST_NOT_BE_NUMERIC_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::blaze::IsNumericMatrix_&lt;T&gt;, &quot;Numeric matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga73380803a47415cd2a58a29bf66340b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a numeric matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga73380803a47415cd2a58a29bf66340b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961149e78d02e20180988b3e0383dcd3"><td class="memItemLeft" align="right" valign="top"><a id="ga961149e78d02e20180988b3e0383dcd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga961149e78d02e20180988b3e0383dcd3">BLAZE_CONSTRAINT_MUST_BE_NUMERIC_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/d1f/structblaze_1_1IsNumericVector.html">blaze::IsNumericVector</a>&lt;T&gt;::value, &quot;Non-numeric vector type detected&quot; )</td></tr>
<tr class="memdesc:ga961149e78d02e20180988b3e0383dcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a numeric vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga961149e78d02e20180988b3e0383dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1434e17eb9bebd26bead8d5ac96e0563"><td class="memItemLeft" align="right" valign="top"><a id="ga1434e17eb9bebd26bead8d5ac96e0563"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1434e17eb9bebd26bead8d5ac96e0563">BLAZE_CONSTRAINT_MUST_NOT_BE_NUMERIC_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/d1f/structblaze_1_1IsNumericVector.html">blaze::IsNumericVector</a>&lt;T&gt;::value, &quot;Numeric vector type detected&quot; )</td></tr>
<tr class="memdesc:ga1434e17eb9bebd26bead8d5ac96e0563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a numeric vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga1434e17eb9bebd26bead8d5ac96e0563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b84457d5d8aaa479da027d9d66bb8b"><td class="memItemLeft" align="right" valign="top"><a id="gad7b84457d5d8aaa479da027d9d66bb8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gad7b84457d5d8aaa479da027d9d66bb8b">BLAZE_CONSTRAINT_MUST_BE_OPERATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/db0/structblaze_1_1IsOperation.html">blaze::IsOperation</a>&lt;T&gt;::value, &quot;Non-operation type detected&quot; )</td></tr>
<tr class="memdesc:gad7b84457d5d8aaa479da027d9d66bb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an operational expression (i.e. a type derived from the Operation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gad7b84457d5d8aaa479da027d9d66bb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5047464f4be30e9b656e7682feeb3a78"><td class="memItemLeft" align="right" valign="top"><a id="ga5047464f4be30e9b656e7682feeb3a78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5047464f4be30e9b656e7682feeb3a78">BLAZE_CONSTRAINT_MUST_NOT_BE_OPERATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/db0/structblaze_1_1IsOperation.html">blaze::IsOperation</a>&lt;T&gt;::value, &quot;Operation type detected&quot; )</td></tr>
<tr class="memdesc:ga5047464f4be30e9b656e7682feeb3a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an operational expression (i.e. a type derived from the Operation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5047464f4be30e9b656e7682feeb3a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c5e923ae9f08b2dab63ad262bc7173"><td class="memItemLeft" align="right" valign="top"><a id="ga31c5e923ae9f08b2dab63ad262bc7173"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga31c5e923ae9f08b2dab63ad262bc7173">BLAZE_CONSTRAINT_MUST_BE_OPPOSED_VIEW</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/ddb/structblaze_1_1IsOpposedView.html">blaze::IsOpposedView</a>&lt;T&gt;::value, &quot;Non-opposed view detected&quot; )</td></tr>
<tr class="memdesc:ga31c5e923ae9f08b2dab63ad262bc7173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an opposed view, i.e. is not a view that is opposed to the natural storage order of its underlying type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga31c5e923ae9f08b2dab63ad262bc7173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83cd6c982a2627a1ff13a623c174ff8"><td class="memItemLeft" align="right" valign="top"><a id="gaf83cd6c982a2627a1ff13a623c174ff8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf83cd6c982a2627a1ff13a623c174ff8">BLAZE_CONSTRAINT_MUST_NOT_BE_OPPOSED_VIEW</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/ddb/structblaze_1_1IsOpposedView.html">blaze::IsOpposedView</a>&lt;T&gt;::value, &quot;Opposed view detected&quot; )</td></tr>
<tr class="memdesc:gaf83cd6c982a2627a1ff13a623c174ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an opposed view, i.e. is a view that is opposed to the natural storage order of its underlying type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaf83cd6c982a2627a1ff13a623c174ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c5de6426e2ecadae2b8b8d82bae46d"><td class="memItemLeft" align="right" valign="top"><a id="gaa6c5de6426e2ecadae2b8b8d82bae46d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa6c5de6426e2ecadae2b8b8d82bae46d">BLAZE_CONSTRAINT_MUST_BE_PADDED_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/d57/structblaze_1_1IsPadded.html">blaze::IsPadded</a>&lt;T&gt;::value, &quot;Non-padded type detected&quot; )</td></tr>
<tr class="memdesc:gaa6c5de6426e2ecadae2b8b8d82bae46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not employ or simulate padding (i.e. a special treatment of remainder elements is necessary) a compilation error is created. <br /></td></tr>
<tr class="separator:gaa6c5de6426e2ecadae2b8b8d82bae46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2b6507dba0f04c6632473a73d3a571"><td class="memItemLeft" align="right" valign="top"><a id="gabe2b6507dba0f04c6632473a73d3a571"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabe2b6507dba0f04c6632473a73d3a571">BLAZE_CONSTRAINT_MUST_NOT_BE_PADDED_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/d57/structblaze_1_1IsPadded.html">blaze::IsPadded</a>&lt;T&gt;::value, &quot;Padded type detected&quot; )</td></tr>
<tr class="memdesc:gabe2b6507dba0f04c6632473a73d3a571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does employ or simulate padding (i.e. no special treatment of remainder elements is necessary) a compilation error is created. <br /></td></tr>
<tr class="separator:gabe2b6507dba0f04c6632473a73d3a571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dd522d4bdd7a9e520df64cdedc1179"><td class="memItemLeft" align="right" valign="top"><a id="ga40dd522d4bdd7a9e520df64cdedc1179"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga40dd522d4bdd7a9e520df64cdedc1179">BLAZE_CONSTRAINT_MUST_BE_PROXY_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">blaze::IsProxy</a>&lt;T&gt;::value, &quot;Non-proxy type detected&quot; )</td></tr>
<tr class="memdesc:ga40dd522d4bdd7a9e520df64cdedc1179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a proxy type (i.e. a type derived from the Proxy class template), a compilation error is created. <br /></td></tr>
<tr class="separator:ga40dd522d4bdd7a9e520df64cdedc1179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb55651b852d9771d42bfce8e6fd9404"><td class="memItemLeft" align="right" valign="top"><a id="gadb55651b852d9771d42bfce8e6fd9404"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gadb55651b852d9771d42bfce8e6fd9404">BLAZE_CONSTRAINT_MUST_NOT_BE_PROXY_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">blaze::IsProxy</a>&lt;T&gt;::value, &quot;Proxy type detected&quot; )</td></tr>
<tr class="memdesc:gadb55651b852d9771d42bfce8e6fd9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a proxy type (i.e. a type derived from the Proxy class template), a compilation error is created. <br /></td></tr>
<tr class="separator:gadb55651b852d9771d42bfce8e6fd9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffe49ef4d291586fd01558a7527738f"><td class="memItemLeft" align="right" valign="top"><a id="gaeffe49ef4d291586fd01558a7527738f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaeffe49ef4d291586fd01558a7527738f">BLAZE_CONSTRAINT_MUST_REQUIRE_EVALUATION</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">blaze::RequiresEvaluation</a>&lt;T&gt;::value, &quot;Type without evaluation requirement detected&quot; )</td></tr>
<tr class="memdesc:gaeffe49ef4d291586fd01558a7527738f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not require an intermediate evaluation within composite expressions, a compilation error is created. <br /></td></tr>
<tr class="separator:gaeffe49ef4d291586fd01558a7527738f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23edec9c91752268a761ae438f02bdaa"><td class="memItemLeft" align="right" valign="top"><a id="ga23edec9c91752268a761ae438f02bdaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga23edec9c91752268a761ae438f02bdaa">BLAZE_CONSTRAINT_MUST_NOT_REQUIRE_EVALUATION</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">blaze::RequiresEvaluation</a>&lt;T&gt;::value, &quot;Type with evaluation requirement detected&quot; )</td></tr>
<tr class="memdesc:ga23edec9c91752268a761ae438f02bdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> requires an intermediate evaluation within composite expressions, a compilation error is created. <br /></td></tr>
<tr class="separator:ga23edec9c91752268a761ae438f02bdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7bdbae27ccb5a97172a7db3a7580e7"><td class="memItemLeft" align="right" valign="top"><a id="gabe7bdbae27ccb5a97172a7db3a7580e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabe7bdbae27ccb5a97172a7db3a7580e7">BLAZE_CONSTRAINT_MUST_BE_RESIZABLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">blaze::IsResizable</a>&lt;T&gt;::value, &quot;Non-resizable type detected&quot; )</td></tr>
<tr class="memdesc:gabe7bdbae27ccb5a97172a7db3a7580e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not resizable, i.e. does not have a 'resize' member function that could be used to change the size, a compilation error is created. <br /></td></tr>
<tr class="separator:gabe7bdbae27ccb5a97172a7db3a7580e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91457cb5e1543dfa6e501d87bc692892"><td class="memItemLeft" align="right" valign="top"><a id="ga91457cb5e1543dfa6e501d87bc692892"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga91457cb5e1543dfa6e501d87bc692892">BLAZE_CONSTRAINT_MUST_NOT_BE_RESIZABLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">blaze::IsResizable</a>&lt;T&gt;::value, &quot;Resizable type detected&quot; )</td></tr>
<tr class="memdesc:ga91457cb5e1543dfa6e501d87bc692892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is resizable, i.e. has a 'resize' member function that can be used to change the size, a compilation error is created. <br /></td></tr>
<tr class="separator:ga91457cb5e1543dfa6e501d87bc692892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c30f986ce50db86fcff6413b06cdb39"><td class="memItemLeft" align="right" valign="top"><a id="ga5c30f986ce50db86fcff6413b06cdb39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5c30f986ce50db86fcff6413b06cdb39">BLAZE_CONSTRAINT_MUST_BE_RESTRICTED</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">blaze::IsRestricted</a>&lt;T&gt;::value, &quot;Unrestricted type detected&quot; )</td></tr>
<tr class="memdesc:ga5c30f986ce50db86fcff6413b06cdb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does not have a restricted data access, i.e. does not restrict specific operations on its data, a compilation error is created. <br /></td></tr>
<tr class="separator:ga5c30f986ce50db86fcff6413b06cdb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d78cd079a016fd3377f956f542f611"><td class="memItemLeft" align="right" valign="top"><a id="gae2d78cd079a016fd3377f956f542f611"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae2d78cd079a016fd3377f956f542f611">BLAZE_CONSTRAINT_MUST_NOT_BE_RESTRICTED</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">blaze::IsRestricted</a>&lt;T&gt;::value, &quot;Restricted type detected&quot; )</td></tr>
<tr class="memdesc:gae2d78cd079a016fd3377f956f542f611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> does have a restricted data access, i.e. does not restrict any operation on its data, a compilation error is created. <br /></td></tr>
<tr class="separator:gae2d78cd079a016fd3377f956f542f611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d129510104d38d01a6b68a990570ac"><td class="memItemLeft" align="right" valign="top"><a id="ga88d129510104d38d01a6b68a990570ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga88d129510104d38d01a6b68a990570ac">BLAZE_CONSTRAINT_MUST_BE_ROW_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/da2/structblaze_1_1IsRow.html">blaze::IsRow</a>&lt;T&gt;::value, &quot;Non-row type detected&quot; )</td></tr>
<tr class="memdesc:ga88d129510104d38d01a6b68a990570ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a row type (i.e. a dense or sparse row), a compilation error is created. <br /></td></tr>
<tr class="separator:ga88d129510104d38d01a6b68a990570ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4e48462fa6aee95a781db6bf56ec2e"><td class="memItemLeft" align="right" valign="top"><a id="ga6b4e48462fa6aee95a781db6bf56ec2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6b4e48462fa6aee95a781db6bf56ec2e">BLAZE_CONSTRAINT_MUST_NOT_BE_ROW_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/da2/structblaze_1_1IsRow.html">blaze::IsRow</a>&lt;T&gt;::value, &quot;Row type detected&quot; )</td></tr>
<tr class="memdesc:ga6b4e48462fa6aee95a781db6bf56ec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a row type (i.e. a dense or sparse row), a compilation error is created. <br /></td></tr>
<tr class="separator:ga6b4e48462fa6aee95a781db6bf56ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa3130bc493a789e82157a617f2e212"><td class="memItemLeft" align="right" valign="top"><a id="ga0fa3130bc493a789e82157a617f2e212"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0fa3130bc493a789e82157a617f2e212">BLAZE_CONSTRAINT_MUST_BE_ROW_MAJOR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">blaze::IsRowMajorMatrix</a>&lt;T&gt;::value, &quot;Non-row-major matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga0fa3130bc493a789e82157a617f2e212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a row-major dense or sparse matrix type (i.e. a matrix type whose storage order is set to <em>false</em>) a compilation error is created. <br /></td></tr>
<tr class="separator:ga0fa3130bc493a789e82157a617f2e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca0fc88474cb0ef4b258742ad3fe657"><td class="memItemLeft" align="right" valign="top"><a id="gafca0fc88474cb0ef4b258742ad3fe657"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafca0fc88474cb0ef4b258742ad3fe657">BLAZE_CONSTRAINT_MUST_NOT_BE_ROW_MAJOR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">blaze::IsRowMajorMatrix</a>&lt;T&gt;::value, &quot;Row-major matrix type detected&quot; )</td></tr>
<tr class="memdesc:gafca0fc88474cb0ef4b258742ad3fe657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a row-major dense or sparse matrix type (i.e. a matrix type whose storage order is set to <em>false</em>) a compilation error is created. <br /></td></tr>
<tr class="separator:gafca0fc88474cb0ef4b258742ad3fe657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592820e99022ac6fe740951b8f34aa9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga592820e99022ac6fe740951b8f34aa9c">BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_ROWS</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga592820e99022ac6fe740951b8f34aa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the number of rows of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of rows is not equal, a compilation error is created. Note that in case the number of rows of either of the two matrix types cannot be determined no compilation error is created.  <a href="#ga592820e99022ac6fe740951b8f34aa9c">More...</a><br /></td></tr>
<tr class="separator:ga592820e99022ac6fe740951b8f34aa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2ccaa63577a8686de70a08681f8ac5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafc2ccaa63577a8686de70a08681f8ac5">BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_ROWS</a>(T1,  T2)</td></tr>
<tr class="memdesc:gafc2ccaa63577a8686de70a08681f8ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the number of rows of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of rows is equal, a compilation error is created. Note that in case the number of rows of either of the two matrix types cannot be determined no compilation error is created.  <a href="#gafc2ccaa63577a8686de70a08681f8ac5">More...</a><br /></td></tr>
<tr class="separator:gafc2ccaa63577a8686de70a08681f8ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae125abc0e20958656aa7539424d24166"><td class="memItemLeft" align="right" valign="top"><a id="gae125abc0e20958656aa7539424d24166"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae125abc0e20958656aa7539424d24166">BLAZE_CONSTRAINT_MUST_BE_ROW_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a>&lt;T&gt;::value, &quot;Non-row vector type detected&quot; )</td></tr>
<tr class="memdesc:gae125abc0e20958656aa7539424d24166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a row dense or sparse vector type (i.e. a vector type whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a>) a compilation error is created. <br /></td></tr>
<tr class="separator:gae125abc0e20958656aa7539424d24166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb06c1ce21b6da73b148be158f5a642"><td class="memItemLeft" align="right" valign="top"><a id="gaafb06c1ce21b6da73b148be158f5a642"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaafb06c1ce21b6da73b148be158f5a642">BLAZE_CONSTRAINT_MUST_NOT_BE_ROW_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a>&lt;T&gt;::value, &quot;Row vector type detected&quot; )</td></tr>
<tr class="memdesc:gaafb06c1ce21b6da73b148be158f5a642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a row dense or sparse vector type (i.e. a vector type whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a>) a compilation error is created. <br /></td></tr>
<tr class="separator:gaafb06c1ce21b6da73b148be158f5a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfbbe144912ca06ee1d59bcdebb4d1af"><td class="memItemLeft" align="right" valign="top"><a id="gabfbbe144912ca06ee1d59bcdebb4d1af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabfbbe144912ca06ee1d59bcdebb4d1af">BLAZE_CONSTRAINT_MUST_BE_SCHUREXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/d7c/structblaze_1_1IsSchurExpr.html">blaze::IsSchurExpr</a>&lt;T&gt;::value, &quot;Non-Schur product expression type detected&quot; )</td></tr>
<tr class="memdesc:gabfbbe144912ca06ee1d59bcdebb4d1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a Schur product expression (i.e. a type derived from the SchurExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gabfbbe144912ca06ee1d59bcdebb4d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2e91f3d66e018b0867878025a72515"><td class="memItemLeft" align="right" valign="top"><a id="gaeb2e91f3d66e018b0867878025a72515"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaeb2e91f3d66e018b0867878025a72515">BLAZE_CONSTRAINT_MUST_NOT_BE_SCHUREXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/d7c/structblaze_1_1IsSchurExpr.html">blaze::IsSchurExpr</a>&lt;T&gt;::value, &quot;Schur product expression type detected&quot; )</td></tr>
<tr class="memdesc:gaeb2e91f3d66e018b0867878025a72515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a Schur product expression (i.e. a type derived from the SchurExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaeb2e91f3d66e018b0867878025a72515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3679b40131e9ab8af300dc825073bd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gac3679b40131e9ab8af300dc825073bd9">BLAZE_CONSTRAINT_MUST_FORM_VALID_SCHUREXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:gac3679b40131e9ab8af300dc825073bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix addition, a compilation error is created.  <a href="#gac3679b40131e9ab8af300dc825073bd9">More...</a><br /></td></tr>
<tr class="separator:gac3679b40131e9ab8af300dc825073bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37bbda26fa854eb0897b1a77a14d8b4f"><td class="memItemLeft" align="right" valign="top"><a id="ga37bbda26fa854eb0897b1a77a14d8b4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga37bbda26fa854eb0897b1a77a14d8b4f">BLAZE_CONSTRAINT_MUST_BE_SERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html">blaze::IsSerialExpr</a>&lt;T&gt;::value, &quot;Non-serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga37bbda26fa854eb0897b1a77a14d8b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a serial evaluation expression (i.e. a type derived from the SerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga37bbda26fa854eb0897b1a77a14d8b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57d13e27441a9a762aec0ece4e481e7"><td class="memItemLeft" align="right" valign="top"><a id="gae57d13e27441a9a762aec0ece4e481e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae57d13e27441a9a762aec0ece4e481e7">BLAZE_CONSTRAINT_MUST_NOT_BE_SERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html">blaze::IsSerialExpr</a>&lt;T&gt;::value, &quot;Serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:gae57d13e27441a9a762aec0ece4e481e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a serial evaluation expression (i.e. a type derived from the SerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gae57d13e27441a9a762aec0ece4e481e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22da42544b5906a940b6388f4d790514"><td class="memItemLeft" align="right" valign="top"><a id="ga22da42544b5906a940b6388f4d790514"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga22da42544b5906a940b6388f4d790514">BLAZE_CONSTRAINT_MUST_BE_SHRINKABLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/d56/structblaze_1_1IsShrinkable.html">blaze::IsShrinkable</a>&lt;T&gt;::value, &quot;Non-shrinkable type detected&quot; )</td></tr>
<tr class="memdesc:ga22da42544b5906a940b6388f4d790514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not shrinkable, i.e. does not have a 'shrinkToFit' member function that could be used to reduce the capacity, a compilation error is created. <br /></td></tr>
<tr class="separator:ga22da42544b5906a940b6388f4d790514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2c2b69f75a7a828c06e8f9d1ed2862"><td class="memItemLeft" align="right" valign="top"><a id="gada2c2b69f75a7a828c06e8f9d1ed2862"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gada2c2b69f75a7a828c06e8f9d1ed2862">BLAZE_CONSTRAINT_MUST_NOT_BE_SHRINKABLE_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/d56/structblaze_1_1IsShrinkable.html">blaze::IsShrinkable</a>&lt;T&gt;::value, &quot;Shrinkable type detected&quot; )</td></tr>
<tr class="memdesc:gada2c2b69f75a7a828c06e8f9d1ed2862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is shrinkable, i.e. has a 'shrinkToFit' member function that can be used to reduce the capacity, a compilation error is created. <br /></td></tr>
<tr class="separator:gada2c2b69f75a7a828c06e8f9d1ed2862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11ff2b2e0902f9a4df7d81e1e773c05"><td class="memItemLeft" align="right" valign="top"><a id="gaf11ff2b2e0902f9a4df7d81e1e773c05"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf11ff2b2e0902f9a4df7d81e1e773c05">BLAZE_CONSTRAINT_MUST_BE_SIMD_COMBINABLE_TYPES</a>(T1,  T2)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../df/d53/structblaze_1_1IsSIMDCombinable.html">blaze::IsSIMDCombinable</a>&lt;T1,T2&gt;::value, &quot;Non-SIMD combinable types detected&quot; )</td></tr>
<tr class="memdesc:gaf11ff2b2e0902f9a4df7d81e1e773c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> are not SIMD combinable (i.e. do not have a common SIMD interface), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf11ff2b2e0902f9a4df7d81e1e773c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60f52ae5cf436d33d022da571f6d22e"><td class="memItemLeft" align="right" valign="top"><a id="gaf60f52ae5cf436d33d022da571f6d22e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf60f52ae5cf436d33d022da571f6d22e">BLAZE_CONSTRAINT_MUST_NOT_BE_SIMD_COMBINABLE_TYPES</a>(T1,  T2)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../df/d53/structblaze_1_1IsSIMDCombinable.html">blaze::IsSIMDCombinable</a>&lt;T1,T2&gt;::value, &quot;SIMD combinable types detected&quot; )</td></tr>
<tr class="memdesc:gaf60f52ae5cf436d33d022da571f6d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> are SIMD combinable (i.e. do not have a common SIMD interface), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf60f52ae5cf436d33d022da571f6d22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f7f67ee7e3e7bde7b4cd98c56697b7"><td class="memItemLeft" align="right" valign="top"><a id="gae6f7f67ee7e3e7bde7b4cd98c56697b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae6f7f67ee7e3e7bde7b4cd98c56697b7">BLAZE_CONSTRAINT_MUST_BE_SIMD_ENABLED</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html">blaze::IsSIMDEnabled</a>&lt;T&gt;::value, &quot;Non-SIMD enabled type detected&quot; )</td></tr>
<tr class="memdesc:gae6f7f67ee7e3e7bde7b4cd98c56697b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not SIMD-enabled (i.e. does not provide the according SIMD member functions), a compilation error is created. <br /></td></tr>
<tr class="separator:gae6f7f67ee7e3e7bde7b4cd98c56697b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518a5d3c1e1d013575a9d2c59c4a74e8"><td class="memItemLeft" align="right" valign="top"><a id="ga518a5d3c1e1d013575a9d2c59c4a74e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga518a5d3c1e1d013575a9d2c59c4a74e8">BLAZE_CONSTRAINT_MUST_NOT_BE_SIMD_ENABLED</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html">blaze::IsSIMDEnabled</a>&lt;T&gt;::value, &quot;SIMD enabled type detected&quot; )</td></tr>
<tr class="memdesc:ga518a5d3c1e1d013575a9d2c59c4a74e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is SIMD-enabled (i.e. does provide the according SIMD member functions), a compilation error is created. <br /></td></tr>
<tr class="separator:ga518a5d3c1e1d013575a9d2c59c4a74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa421408ab45f75089b1e6833f97230c6"><td class="memItemLeft" align="right" valign="top"><a id="gaa421408ab45f75089b1e6833f97230c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa421408ab45f75089b1e6833f97230c6">BLAZE_CONSTRAINT_MUST_BE_SIMD_PACK</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/d68/structblaze_1_1IsSIMDPack.html">blaze::IsSIMDPack</a>&lt;T&gt;::value, &quot;Non-SIMD pack detected&quot; )</td></tr>
<tr class="memdesc:gaa421408ab45f75089b1e6833f97230c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a SIMD pack, a compilation error is created. <br /></td></tr>
<tr class="separator:gaa421408ab45f75089b1e6833f97230c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ca1d7421f87f6db4740fa45ff1cff9"><td class="memItemLeft" align="right" valign="top"><a id="gab0ca1d7421f87f6db4740fa45ff1cff9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab0ca1d7421f87f6db4740fa45ff1cff9">BLAZE_CONSTRAINT_MUST_NOT_BE_SIMD_PACK</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/d68/structblaze_1_1IsSIMDPack.html">blaze::IsSIMDPack</a>&lt;T&gt;::value, &quot;SIMD pack detected&quot; )</td></tr>
<tr class="memdesc:gab0ca1d7421f87f6db4740fa45ff1cff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a SIMD pack, a compilation error is created. <br /></td></tr>
<tr class="separator:gab0ca1d7421f87f6db4740fa45ff1cff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba242807c418330b99067208af8d0128"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaba242807c418330b99067208af8d0128">BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_SIZE</a>(T1,  T2)</td></tr>
<tr class="memdesc:gaba242807c418330b99067208af8d0128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the size of the two given vector types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case these sizes are not equal, a compilation error is created. Note that in case the size of either of the two vector types cannot be determined no compilation error is created.  <a href="#gaba242807c418330b99067208af8d0128">More...</a><br /></td></tr>
<tr class="separator:gaba242807c418330b99067208af8d0128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94ece977784856de651ff740f4e4266"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf94ece977784856de651ff740f4e4266">BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_SIZE</a>(T1,  T2)</td></tr>
<tr class="memdesc:gaf94ece977784856de651ff740f4e4266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the size of the two given vector types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case these sizes are equal, a compilation error is created. Note that in case the size of either of the two vector types cannot be determined no compilation error is created.  <a href="#gaf94ece977784856de651ff740f4e4266">More...</a><br /></td></tr>
<tr class="separator:gaf94ece977784856de651ff740f4e4266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd8e6a3170abb55cd072fbbd767b948"><td class="memItemLeft" align="right" valign="top"><a id="ga0bd8e6a3170abb55cd072fbbd767b948"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga0bd8e6a3170abb55cd072fbbd767b948">BLAZE_CONSTRAINT_MUST_BE_SMP_ASSIGNABLE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/de3/structblaze_1_1IsSMPAssignable.html">blaze::IsSMPAssignable</a>&lt;T&gt;::value, &quot;Non-SMP assignable type detected&quot; )</td></tr>
<tr class="memdesc:ga0bd8e6a3170abb55cd072fbbd767b948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not SMP-assignable (i.e. cannot be assigned by multiple threads), a compilation error is created. <br /></td></tr>
<tr class="separator:ga0bd8e6a3170abb55cd072fbbd767b948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c56d81845f46834fdd4859d9a84e04"><td class="memItemLeft" align="right" valign="top"><a id="gab6c56d81845f46834fdd4859d9a84e04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab6c56d81845f46834fdd4859d9a84e04">BLAZE_CONSTRAINT_MUST_NOT_BE_SMP_ASSIGNABLE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/de3/structblaze_1_1IsSMPAssignable.html">blaze::IsSMPAssignable</a>&lt;T&gt;::value, &quot;SMP assignable type detected&quot; )</td></tr>
<tr class="memdesc:gab6c56d81845f46834fdd4859d9a84e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is SMP-assignable (can be assigned by multiple threads), a compilation error is created. <br /></td></tr>
<tr class="separator:gab6c56d81845f46834fdd4859d9a84e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae4345d2160834bfc535fb0070bf6d4"><td class="memItemLeft" align="right" valign="top"><a id="ga9ae4345d2160834bfc535fb0070bf6d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9ae4345d2160834bfc535fb0070bf6d4">BLAZE_CONSTRAINT_MUST_BE_SPARSE_ELEMENT_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html">blaze::IsSparseElement</a>&lt;T&gt;::value, &quot;Non-sparse element type detected&quot; )</td></tr>
<tr class="memdesc:ga9ae4345d2160834bfc535fb0070bf6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a sparse element type (i.e. a type derived from the SparseElement base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga9ae4345d2160834bfc535fb0070bf6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cb72621037e6557cdd0b1766220ebb"><td class="memItemLeft" align="right" valign="top"><a id="ga87cb72621037e6557cdd0b1766220ebb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga87cb72621037e6557cdd0b1766220ebb">BLAZE_CONSTRAINT_MUST_NOT_BE_SPARSE_ELEMENT_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html">blaze::IsSparseElement</a>&lt;T&gt;::value, &quot;Sparse element type detected&quot; )</td></tr>
<tr class="memdesc:ga87cb72621037e6557cdd0b1766220ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a sparse element type (i.e. a type derived from the SparseElement base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga87cb72621037e6557cdd0b1766220ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c454a1517edc3cfc46b2e1c47313bf"><td class="memItemLeft" align="right" valign="top"><a id="gaa0c454a1517edc3cfc46b2e1c47313bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa0c454a1517edc3cfc46b2e1c47313bf">BLAZE_CONSTRAINT_MUST_BE_SPARSE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">blaze::IsSparseMatrix</a>&lt;T&gt;::value, &quot;Non-sparse matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaa0c454a1517edc3cfc46b2e1c47313bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a sparse, N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaa0c454a1517edc3cfc46b2e1c47313bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae3fee688c118884f61ef9fcf295cea"><td class="memItemLeft" align="right" valign="top"><a id="ga3ae3fee688c118884f61ef9fcf295cea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3ae3fee688c118884f61ef9fcf295cea">BLAZE_CONSTRAINT_MUST_NOT_BE_SPARSE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">blaze::IsSparseMatrix</a>&lt;T&gt;::value, &quot;Sparse matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga3ae3fee688c118884f61ef9fcf295cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a sparse, N-dimensional matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga3ae3fee688c118884f61ef9fcf295cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3f6f892e64d84c82d0f892a249fb5e"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3f6f892e64d84c82d0f892a249fb5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8e3f6f892e64d84c82d0f892a249fb5e">BLAZE_CONSTRAINT_MUST_BE_SPARSE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">blaze::IsSparseVector</a>&lt;T&gt;::value, &quot;Non-sparse vector type detected&quot; )</td></tr>
<tr class="memdesc:ga8e3f6f892e64d84c82d0f892a249fb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a sparse, N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga8e3f6f892e64d84c82d0f892a249fb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e854dd2d0c83661187cb4fcf48e5161"><td class="memItemLeft" align="right" valign="top"><a id="ga8e854dd2d0c83661187cb4fcf48e5161"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga8e854dd2d0c83661187cb4fcf48e5161">BLAZE_CONSTRAINT_MUST_NOT_BE_SPARSE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">blaze::IsSparseVector</a>&lt;T&gt;::value, &quot;Sparse vector type detected&quot; )</td></tr>
<tr class="memdesc:ga8e854dd2d0c83661187cb4fcf48e5161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a sparse, N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga8e854dd2d0c83661187cb4fcf48e5161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3919afc8aa656a2c09fb9a305a901b49"><td class="memItemLeft" align="right" valign="top"><a id="ga3919afc8aa656a2c09fb9a305a901b49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3919afc8aa656a2c09fb9a305a901b49">BLAZE_CONSTRAINT_MUST_BE_SQUARE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d3b/structblaze_1_1IsSquare.html">blaze::IsSquare</a>&lt;T&gt;::value, &quot;Non-square matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga3919afc8aa656a2c09fb9a305a901b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a square matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga3919afc8aa656a2c09fb9a305a901b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49d71567136b97383f1acc8f1d05acd"><td class="memItemLeft" align="right" valign="top"><a id="gae49d71567136b97383f1acc8f1d05acd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae49d71567136b97383f1acc8f1d05acd">BLAZE_CONSTRAINT_MUST_NOT_BE_SQUARE_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d3b/structblaze_1_1IsSquare.html">blaze::IsSquare</a>&lt;T&gt;::value, &quot;Square matrix type detected&quot; )</td></tr>
<tr class="memdesc:gae49d71567136b97383f1acc8f1d05acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a square matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae49d71567136b97383f1acc8f1d05acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ba9b980ca7fc7a468d77a7a5830c01"><td class="memItemLeft" align="right" valign="top"><a id="ga91ba9b980ca7fc7a468d77a7a5830c01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga91ba9b980ca7fc7a468d77a7a5830c01">BLAZE_CONSTRAINT_MUST_BE_STATIC_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/da3/structblaze_1_1IsStatic.html">blaze::IsStatic</a>&lt;T&gt;::value, &quot;Non-static type detected&quot; )</td></tr>
<tr class="memdesc:ga91ba9b980ca7fc7a468d77a7a5830c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a static data type, i.e. a vector or matrix with dimensions fixed at compile time, a compilation error is created. <br /></td></tr>
<tr class="separator:ga91ba9b980ca7fc7a468d77a7a5830c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf87fa569e04b33a0068ca85e854c47f"><td class="memItemLeft" align="right" valign="top"><a id="gabf87fa569e04b33a0068ca85e854c47f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabf87fa569e04b33a0068ca85e854c47f">BLAZE_CONSTRAINT_MUST_NOT_BE_STATIC_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/da3/structblaze_1_1IsStatic.html">blaze::IsStatic</a>&lt;T&gt;::value, &quot;Static type dected&quot; )</td></tr>
<tr class="memdesc:gabf87fa569e04b33a0068ca85e854c47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a static data type, i.e. a vector or matrix with dimensions fixed at compile time, a compilation error is created. <br /></td></tr>
<tr class="separator:gabf87fa569e04b33a0068ca85e854c47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0dee9bc8ad903ee82af4a604be4aee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafb0dee9bc8ad903ee82af4a604be4aee">BLAZE_CONSTRAINT_MUST_BE_MATRIX_WITH_STORAGE_ORDER</a>(T,  SO)</td></tr>
<tr class="memdesc:gafb0dee9bc8ad903ee82af4a604be4aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a dense or sparse matrix type and in case the storage order of the given dense or sparse vector type <em>T</em> is not set to <em>SO</em>, a compilation error is created.  <a href="#gafb0dee9bc8ad903ee82af4a604be4aee">More...</a><br /></td></tr>
<tr class="separator:gafb0dee9bc8ad903ee82af4a604be4aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f07effa42bba2ab4fc9f5b41289ba1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga12f07effa42bba2ab4fc9f5b41289ba1">BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_SAME_STORAGE_ORDER</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga12f07effa42bba2ab4fc9f5b41289ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a matrix type and in case the storage order of both matrix types doesn't match, a compilation error is created.  <a href="#ga12f07effa42bba2ab4fc9f5b41289ba1">More...</a><br /></td></tr>
<tr class="separator:ga12f07effa42bba2ab4fc9f5b41289ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b00d6a4f7ffe501d852ab7846f60c83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4b00d6a4f7ffe501d852ab7846f60c83">BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_DIFFERENT_STORAGE_ORDER</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga4b00d6a4f7ffe501d852ab7846f60c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a matrix type and in case the storage order of both matrix types does match, a compilation error is created.  <a href="#ga4b00d6a4f7ffe501d852ab7846f60c83">More...</a><br /></td></tr>
<tr class="separator:ga4b00d6a4f7ffe501d852ab7846f60c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed5ec3999050fc7a28428ec499bdf0a"><td class="memItemLeft" align="right" valign="top"><a id="ga1ed5ec3999050fc7a28428ec499bdf0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1ed5ec3999050fc7a28428ec499bdf0a">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_LOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d3/d49/structblaze_1_1IsStrictlyLower.html">blaze::IsStrictlyLower</a>&lt;T&gt;::value, &quot;Non-strictly lower triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga1ed5ec3999050fc7a28428ec499bdf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a strictly lower triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga1ed5ec3999050fc7a28428ec499bdf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19259090b73b74c9def2e2b3d983a33"><td class="memItemLeft" align="right" valign="top"><a id="gae19259090b73b74c9def2e2b3d983a33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae19259090b73b74c9def2e2b3d983a33">BLAZE_CONSTRAINT_MUST_NOT_BE_STRICTLY_LOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d3/d49/structblaze_1_1IsStrictlyLower.html">blaze::IsStrictlyLower</a>&lt;T&gt;::value, &quot;Strictly lower triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gae19259090b73b74c9def2e2b3d983a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a strictly lower triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae19259090b73b74c9def2e2b3d983a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0ebc614849c442be6d4b7a0ce02e4e"><td class="memItemLeft" align="right" valign="top"><a id="gabf0ebc614849c442be6d4b7a0ce02e4e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gabf0ebc614849c442be6d4b7a0ce02e4e">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_TRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html">blaze::IsStrictlyTriangular</a>&lt;T&gt;::value, &quot;Non-strictly triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gabf0ebc614849c442be6d4b7a0ce02e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a strictly lower or upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gabf0ebc614849c442be6d4b7a0ce02e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5986da381a576ad0354c722f6aa7db72"><td class="memItemLeft" align="right" valign="top"><a id="ga5986da381a576ad0354c722f6aa7db72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5986da381a576ad0354c722f6aa7db72">BLAZE_CONSTRAINT_MUST_NOT_BE_STRICTLY_TRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html">blaze::IsStrictlyTriangular</a>&lt;T&gt;::value, &quot;Strictly triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga5986da381a576ad0354c722f6aa7db72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a strictly lower or upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga5986da381a576ad0354c722f6aa7db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf974985a2fe7e468cf8b94d9538faf9"><td class="memItemLeft" align="right" valign="top"><a id="gaaf974985a2fe7e468cf8b94d9538faf9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaaf974985a2fe7e468cf8b94d9538faf9">BLAZE_CONSTRAINT_MUST_BE_STRICTLY_UPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/db5/structblaze_1_1IsStrictlyUpper.html">blaze::IsStrictlyUpper</a>&lt;T&gt;::value, &quot;Non-strictly upper triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaaf974985a2fe7e468cf8b94d9538faf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a strictly upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaaf974985a2fe7e468cf8b94d9538faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2394a0cabecb700ab7ce16bd05d4f56"><td class="memItemLeft" align="right" valign="top"><a id="gae2394a0cabecb700ab7ce16bd05d4f56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae2394a0cabecb700ab7ce16bd05d4f56">BLAZE_CONSTRAINT_MUST_NOT_BE_STRICTLY_UPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/db5/structblaze_1_1IsStrictlyUpper.html">blaze::IsStrictlyUpper</a>&lt;T&gt;::value, &quot;Strictly upper triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gae2394a0cabecb700ab7ce16bd05d4f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a strictly upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae2394a0cabecb700ab7ce16bd05d4f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831b9e403d7d1e3993fd5c1b1b84cc46"><td class="memItemLeft" align="right" valign="top"><a id="ga831b9e403d7d1e3993fd5c1b1b84cc46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga831b9e403d7d1e3993fd5c1b1b84cc46">BLAZE_CONSTRAINT_MUST_BE_SUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html">blaze::IsSubExpr</a>&lt;T&gt;::value, &quot;Non-subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:ga831b9e403d7d1e3993fd5c1b1b84cc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a subtraction expression (i.e. a type derived from the SubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga831b9e403d7d1e3993fd5c1b1b84cc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5c00ab9a4e1ffa9a25e19f9557c9a5"><td class="memItemLeft" align="right" valign="top"><a id="ga7a5c00ab9a4e1ffa9a25e19f9557c9a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga7a5c00ab9a4e1ffa9a25e19f9557c9a5">BLAZE_CONSTRAINT_MUST_NOT_BE_SUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html">blaze::IsSubExpr</a>&lt;T&gt;::value, &quot;Subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:ga7a5c00ab9a4e1ffa9a25e19f9557c9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a subtraction expression (i.e. a type derived from the SubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga7a5c00ab9a4e1ffa9a25e19f9557c9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e924b8e08989dd6ebd4842c8c3986a5"><td class="memItemLeft" align="right" valign="top"><a id="ga4e924b8e08989dd6ebd4842c8c3986a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4e924b8e08989dd6ebd4842c8c3986a5">BLAZE_CONSTRAINT_MUST_BE_SUBMATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html">blaze::IsSubmatrix</a>&lt;T&gt;::value, &quot;Non-submatrix type detected&quot; )</td></tr>
<tr class="memdesc:ga4e924b8e08989dd6ebd4842c8c3986a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a submatrix type (i.e. a dense or sparse submatrix), a compilation error is created. <br /></td></tr>
<tr class="separator:ga4e924b8e08989dd6ebd4842c8c3986a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733bd2dd3da104211e6780eeff3ada48"><td class="memItemLeft" align="right" valign="top"><a id="ga733bd2dd3da104211e6780eeff3ada48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga733bd2dd3da104211e6780eeff3ada48">BLAZE_CONSTRAINT_MUST_NOT_BE_SUBMATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html">blaze::IsSubmatrix</a>&lt;T&gt;::value, &quot;Submatrix type detected&quot; )</td></tr>
<tr class="memdesc:ga733bd2dd3da104211e6780eeff3ada48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a submatrix type (i.e. a dense or sparse submatrix), a compilation error is created. <br /></td></tr>
<tr class="separator:ga733bd2dd3da104211e6780eeff3ada48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1706cd96041429691d493ab692c144"><td class="memItemLeft" align="right" valign="top"><a id="gafe1706cd96041429691d493ab692c144"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gafe1706cd96041429691d493ab692c144">BLAZE_CONSTRAINT_MUST_BE_SUBVECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html">blaze::IsSubvector</a>&lt;T&gt;::value, &quot;Non-subvector type detected&quot; )</td></tr>
<tr class="memdesc:gafe1706cd96041429691d493ab692c144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a subvector type (i.e. a dense or sparse subvector), a compilation error is created. <br /></td></tr>
<tr class="separator:gafe1706cd96041429691d493ab692c144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1bc94a5ae710db56b7f143a0343cb4"><td class="memItemLeft" align="right" valign="top"><a id="gacb1bc94a5ae710db56b7f143a0343cb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gacb1bc94a5ae710db56b7f143a0343cb4">BLAZE_CONSTRAINT_MUST_NOT_BE_SUBVECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html">blaze::IsSubvector</a>&lt;T&gt;::value, &quot;Subvector type detected&quot; )</td></tr>
<tr class="memdesc:gacb1bc94a5ae710db56b7f143a0343cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a subvector type (i.e. a dense or sparse subvector), a compilation error is created. <br /></td></tr>
<tr class="separator:gacb1bc94a5ae710db56b7f143a0343cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a037ea1950eabfb3bf7d13a6547782"><td class="memItemLeft" align="right" valign="top"><a id="ga73a037ea1950eabfb3bf7d13a6547782"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga73a037ea1950eabfb3bf7d13a6547782">BLAZE_CONSTRAINT_MUST_BE_SYMMETRIC_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">blaze::IsSymmetric</a>&lt;T&gt;::value, &quot;Non-symmetric matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga73a037ea1950eabfb3bf7d13a6547782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a symmetric matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga73a037ea1950eabfb3bf7d13a6547782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014af84f9b8957807b7e3df118b3350e"><td class="memItemLeft" align="right" valign="top"><a id="ga014af84f9b8957807b7e3df118b3350e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga014af84f9b8957807b7e3df118b3350e">BLAZE_CONSTRAINT_MUST_NOT_BE_SYMMETRIC_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">blaze::IsSymmetric</a>&lt;T&gt;::value, &quot;Symmetric matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga014af84f9b8957807b7e3df118b3350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a symmetric matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga014af84f9b8957807b7e3df118b3350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd617fb916cefefa179a939b667f8613"><td class="memItemLeft" align="right" valign="top"><a id="gadd617fb916cefefa179a939b667f8613"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gadd617fb916cefefa179a939b667f8613">BLAZE_CONSTRAINT_MUST_BE_TRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">blaze::IsTransExpr</a>&lt;T&gt;::value, &quot;Non-transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:gadd617fb916cefefa179a939b667f8613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a transposition expression (i.e. a type derived from the TransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gadd617fb916cefefa179a939b667f8613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5855e53feeaf969c5ecbd83fe549c69b"><td class="memItemLeft" align="right" valign="top"><a id="ga5855e53feeaf969c5ecbd83fe549c69b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5855e53feeaf969c5ecbd83fe549c69b">BLAZE_CONSTRAINT_MUST_NOT_BE_TRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">blaze::IsTransExpr</a>&lt;T&gt;::value, &quot;Transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga5855e53feeaf969c5ecbd83fe549c69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a transposition expression (i.e. a type derived from the TransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5855e53feeaf969c5ecbd83fe549c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a4e6515e44137fc119a0b719fcc3ec"><td class="memItemLeft" align="right" valign="top"><a id="gad5a4e6515e44137fc119a0b719fcc3ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gad5a4e6515e44137fc119a0b719fcc3ec">BLAZE_CONSTRAINT_MUST_BE_TRANSFORMATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/d9b/structblaze_1_1IsTransformation.html">blaze::IsTransformation</a>&lt;T&gt;::value, &quot;Non-transformation type detected&quot; )</td></tr>
<tr class="memdesc:gad5a4e6515e44137fc119a0b719fcc3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a transformation expression (i.e. a type derived from the Transformation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gad5a4e6515e44137fc119a0b719fcc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5472de9cbcbab22c815ad605ecacaa1"><td class="memItemLeft" align="right" valign="top"><a id="gae5472de9cbcbab22c815ad605ecacaa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae5472de9cbcbab22c815ad605ecacaa1">BLAZE_CONSTRAINT_MUST_NOT_BE_TRANSFORMATION_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/d9b/structblaze_1_1IsTransformation.html">blaze::IsTransformation</a>&lt;T&gt;::value, &quot;Transformation type detected&quot; )</td></tr>
<tr class="memdesc:gae5472de9cbcbab22c815ad605ecacaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a transformation expression (i.e. a type derived from the Transformation base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gae5472de9cbcbab22c815ad605ecacaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a90251fe065c55a187bff4f9502f89f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5a90251fe065c55a187bff4f9502f89f">BLAZE_CONSTRAINT_MUST_BE_VECTOR_WITH_TRANSPOSE_FLAG</a>(T,  TF)</td></tr>
<tr class="memdesc:ga5a90251fe065c55a187bff4f9502f89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a dense or sparse vector type and in case the transpose flag of the given dense or sparse vector type <em>T</em> is not set to <em>TF</em>, a compilation error is created.  <a href="#ga5a90251fe065c55a187bff4f9502f89f">More...</a><br /></td></tr>
<tr class="separator:ga5a90251fe065c55a187bff4f9502f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a3773e29675fc6a65cc4c3fdce1f52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa7a3773e29675fc6a65cc4c3fdce1f52">BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_SAME_TRANSPOSE_FLAG</a>(T1,  T2)</td></tr>
<tr class="memdesc:gaa7a3773e29675fc6a65cc4c3fdce1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a vector type and in case the transpose flags of both vector types don't match, a compilation error is created.  <a href="#gaa7a3773e29675fc6a65cc4c3fdce1f52">More...</a><br /></td></tr>
<tr class="separator:gaa7a3773e29675fc6a65cc4c3fdce1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eac2eb9defdc89c03f7e70d32b20322"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6eac2eb9defdc89c03f7e70d32b20322">BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_DIFFERENT_TRANSPOSE_FLAG</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga6eac2eb9defdc89c03f7e70d32b20322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a vector type and in case the transpose flags of both vector types does match, a compilation error is created.  <a href="#ga6eac2eb9defdc89c03f7e70d32b20322">More...</a><br /></td></tr>
<tr class="separator:ga6eac2eb9defdc89c03f7e70d32b20322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a1da62b4bf2565dc734032fc570560"><td class="memItemLeft" align="right" valign="top"><a id="gae3a1da62b4bf2565dc734032fc570560"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae3a1da62b4bf2565dc734032fc570560">BLAZE_CONSTRAINT_MUST_BE_TRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d1/d73/structblaze_1_1IsTriangular.html">blaze::IsTriangular</a>&lt;T&gt;::value, &quot;Non-triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gae3a1da62b4bf2565dc734032fc570560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a lower or upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae3a1da62b4bf2565dc734032fc570560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ecf7f58d2a2bdb95dc421d4af729aa"><td class="memItemLeft" align="right" valign="top"><a id="gab6ecf7f58d2a2bdb95dc421d4af729aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab6ecf7f58d2a2bdb95dc421d4af729aa">BLAZE_CONSTRAINT_MUST_NOT_BE_TRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d1/d73/structblaze_1_1IsTriangular.html">blaze::IsTriangular</a>&lt;T&gt;::value, &quot;Triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gab6ecf7f58d2a2bdb95dc421d4af729aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a lower or upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gab6ecf7f58d2a2bdb95dc421d4af729aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d5ccafdbf769f8e6b6a1852fe05845"><td class="memItemLeft" align="right" valign="top"><a id="ga09d5ccafdbf769f8e6b6a1852fe05845"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga09d5ccafdbf769f8e6b6a1852fe05845">BLAZE_CONSTRAINT_MUST_BE_TVECMATMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">blaze::IsTVecMatMultExpr</a>&lt;T&gt;::value, &quot;Non-vector/matrix multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga09d5ccafdbf769f8e6b6a1852fe05845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/matrix multiplication expression (i.e. a type derived from the TVecMatMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga09d5ccafdbf769f8e6b6a1852fe05845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2239c9a3a7864841b66738c45c484fdf"><td class="memItemLeft" align="right" valign="top"><a id="ga2239c9a3a7864841b66738c45c484fdf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2239c9a3a7864841b66738c45c484fdf">BLAZE_CONSTRAINT_MUST_NOT_BE_TVECMATMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">blaze::IsTVecMatMultExpr</a>&lt;T&gt;::value, &quot;Vector/matrix multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2239c9a3a7864841b66738c45c484fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/matrix multiplication expression (i.e. a type derived from the TVecMatMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2239c9a3a7864841b66738c45c484fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ce5c83f88bdb146dd7e98f830d4ec0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga24ce5c83f88bdb146dd7e98f830d4ec0">BLAZE_CONSTRAINT_MUST_FORM_VALID_TVECMATMULTEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga24ce5c83f88bdb146dd7e98f830d4ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/matrix multiplication, a compilation error is created.  <a href="#ga24ce5c83f88bdb146dd7e98f830d4ec0">More...</a><br /></td></tr>
<tr class="separator:ga24ce5c83f88bdb146dd7e98f830d4ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cf433aa4a45ed4e61b3de8fa4a360b"><td class="memItemLeft" align="right" valign="top"><a id="ga56cf433aa4a45ed4e61b3de8fa4a360b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga56cf433aa4a45ed4e61b3de8fa4a360b">BLAZE_CONSTRAINT_MUST_BE_UNARYMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/d71/structblaze_1_1IsUnaryMapExpr.html">blaze::IsUnaryMapExpr</a>&lt;T&gt;::value, &quot;Non-unary map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga56cf433aa4a45ed4e61b3de8fa4a360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a unary map expression (i.e. a type derived from the UnaryMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga56cf433aa4a45ed4e61b3de8fa4a360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73472bf07b78a622f80d79094ed8623c"><td class="memItemLeft" align="right" valign="top"><a id="ga73472bf07b78a622f80d79094ed8623c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga73472bf07b78a622f80d79094ed8623c">BLAZE_CONSTRAINT_MUST_NOT_BE_UNARYMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/d71/structblaze_1_1IsUnaryMapExpr.html">blaze::IsUnaryMapExpr</a>&lt;T&gt;::value, &quot;Unary map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga73472bf07b78a622f80d79094ed8623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a unary map expression (i.e. a type derived from the UnaryMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga73472bf07b78a622f80d79094ed8623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f5f5a172c4d287cc80b74dcad3853e"><td class="memItemLeft" align="right" valign="top"><a id="gae6f5f5a172c4d287cc80b74dcad3853e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae6f5f5a172c4d287cc80b74dcad3853e">BLAZE_CONSTRAINT_MUST_BE_UNIFORM_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/dfc/structblaze_1_1IsUniform.html">blaze::IsUniform</a>&lt;T&gt;::value, &quot;Non-uniform type detected&quot; )</td></tr>
<tr class="memdesc:gae6f5f5a172c4d287cc80b74dcad3853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a uniform vector or matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae6f5f5a172c4d287cc80b74dcad3853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951b12683afdfe924a69d4bc9f60e945"><td class="memItemLeft" align="right" valign="top"><a id="ga951b12683afdfe924a69d4bc9f60e945"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga951b12683afdfe924a69d4bc9f60e945">BLAZE_CONSTRAINT_MUST_NOT_BE_UNIFORM_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/dfc/structblaze_1_1IsUniform.html">blaze::IsUniform</a>&lt;T&gt;::value, &quot;Uniform type detected&quot; )</td></tr>
<tr class="memdesc:ga951b12683afdfe924a69d4bc9f60e945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a uniform vector or matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga951b12683afdfe924a69d4bc9f60e945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7864d72eeb1e08d48df68c738c529a6"><td class="memItemLeft" align="right" valign="top"><a id="gaa7864d72eeb1e08d48df68c738c529a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa7864d72eeb1e08d48df68c738c529a6">BLAZE_CONSTRAINT_MUST_BE_UNILOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d8/d77/structblaze_1_1IsUniLower.html">blaze::IsUniLower</a>&lt;T&gt;::value, &quot;Non-lower unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gaa7864d72eeb1e08d48df68c738c529a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a lower unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaa7864d72eeb1e08d48df68c738c529a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3462547cb8be83ef34931c577162013"><td class="memItemLeft" align="right" valign="top"><a id="gac3462547cb8be83ef34931c577162013"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gac3462547cb8be83ef34931c577162013">BLAZE_CONSTRAINT_MUST_NOT_BE_UNILOWER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d8/d77/structblaze_1_1IsUniLower.html">blaze::IsUniLower</a>&lt;T&gt;::value, &quot;Lower unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gac3462547cb8be83ef34931c577162013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a lower unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gac3462547cb8be83ef34931c577162013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b98b38717bb0c493c1f34017dad20f"><td class="memItemLeft" align="right" valign="top"><a id="ga68b98b38717bb0c493c1f34017dad20f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga68b98b38717bb0c493c1f34017dad20f">BLAZE_CONSTRAINT_MUST_BE_UNITRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d4/d70/structblaze_1_1IsUniTriangular.html">blaze::IsUniTriangular</a>&lt;T&gt;::value, &quot;Non-unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga68b98b38717bb0c493c1f34017dad20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a lower or upper unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga68b98b38717bb0c493c1f34017dad20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c523665cf969b8d7a23715914b8f70"><td class="memItemLeft" align="right" valign="top"><a id="gae7c523665cf969b8d7a23715914b8f70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gae7c523665cf969b8d7a23715914b8f70">BLAZE_CONSTRAINT_MUST_NOT_BE_UNITRIANGULAR_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d4/d70/structblaze_1_1IsUniTriangular.html">blaze::IsUniTriangular</a>&lt;T&gt;::value, &quot;Unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gae7c523665cf969b8d7a23715914b8f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a lower or upper unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gae7c523665cf969b8d7a23715914b8f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22d73f6b5b5d9fca25d005a39cc00de"><td class="memItemLeft" align="right" valign="top"><a id="gad22d73f6b5b5d9fca25d005a39cc00de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gad22d73f6b5b5d9fca25d005a39cc00de">BLAZE_CONSTRAINT_MUST_BE_UNIUPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../de/ddc/structblaze_1_1IsUniUpper.html">blaze::IsUniUpper</a>&lt;T&gt;::value, &quot;Non-upper unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:gad22d73f6b5b5d9fca25d005a39cc00de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a upper unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:gad22d73f6b5b5d9fca25d005a39cc00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9325edb8c9f4026030e4c26cb0e6a419"><td class="memItemLeft" align="right" valign="top"><a id="ga9325edb8c9f4026030e4c26cb0e6a419"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga9325edb8c9f4026030e4c26cb0e6a419">BLAZE_CONSTRAINT_MUST_NOT_BE_UNIUPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../de/ddc/structblaze_1_1IsUniUpper.html">blaze::IsUniUpper</a>&lt;T&gt;::value, &quot;Upper unitriangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga9325edb8c9f4026030e4c26cb0e6a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a upper unitriangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga9325edb8c9f4026030e4c26cb0e6a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503417261deaae290884cc6b81b79506"><td class="memItemLeft" align="right" valign="top"><a id="ga503417261deaae290884cc6b81b79506"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga503417261deaae290884cc6b81b79506">BLAZE_CONSTRAINT_MUST_BE_UPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">blaze::IsUpper</a>&lt;T&gt;::value, &quot;Non-upper triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga503417261deaae290884cc6b81b79506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga503417261deaae290884cc6b81b79506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0423640219f9306ebeb94ed2aad4d6"><td class="memItemLeft" align="right" valign="top"><a id="ga3f0423640219f9306ebeb94ed2aad4d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3f0423640219f9306ebeb94ed2aad4d6">BLAZE_CONSTRAINT_MUST_NOT_BE_UPPER_MATRIX_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">blaze::IsUpper</a>&lt;T&gt;::value, &quot;Upper triangular matrix type detected&quot; )</td></tr>
<tr class="memdesc:ga3f0423640219f9306ebeb94ed2aad4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a upper triangular matrix type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga3f0423640219f9306ebeb94ed2aad4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e32bbac009a291de55d6d211a3f823"><td class="memItemLeft" align="right" valign="top"><a id="ga56e32bbac009a291de55d6d211a3f823"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga56e32bbac009a291de55d6d211a3f823">BLAZE_CONSTRAINT_MUST_BE_VECEVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html">blaze::IsVecEvalExpr</a>&lt;T&gt;::value, &quot;Non-vector evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga56e32bbac009a291de55d6d211a3f823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector evaluation expression (i.e. a type derived from the VecEvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga56e32bbac009a291de55d6d211a3f823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34db021a339cff823637c4422a4784cc"><td class="memItemLeft" align="right" valign="top"><a id="ga34db021a339cff823637c4422a4784cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga34db021a339cff823637c4422a4784cc">BLAZE_CONSTRAINT_MUST_NOT_BE_VECEVALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html">blaze::IsVecEvalExpr</a>&lt;T&gt;::value, &quot;Vector evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga34db021a339cff823637c4422a4784cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector evaluation expression (i.e. a type derived from the VecEvalExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga34db021a339cff823637c4422a4784cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439f36b247738e7eca6936413ee9d50e"><td class="memItemLeft" align="right" valign="top"><a id="ga439f36b247738e7eca6936413ee9d50e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga439f36b247738e7eca6936413ee9d50e">BLAZE_CONSTRAINT_MUST_BE_VECMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../de/dcd/structblaze_1_1IsVecMapExpr.html">blaze::IsVecMapExpr</a>&lt;T&gt;::value, &quot;Non-unary vector map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga439f36b247738e7eca6936413ee9d50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a unary vector map expression (i.e. a type derived from the VecMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga439f36b247738e7eca6936413ee9d50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fba9edb68c4708dbe8b4cd764b9454"><td class="memItemLeft" align="right" valign="top"><a id="gaa0fba9edb68c4708dbe8b4cd764b9454"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa0fba9edb68c4708dbe8b4cd764b9454">BLAZE_CONSTRAINT_MUST_NOT_BE_VECMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../de/dcd/structblaze_1_1IsVecMapExpr.html">blaze::IsVecMapExpr</a>&lt;T&gt;::value, &quot;Unary vector map expression type detected&quot; )</td></tr>
<tr class="memdesc:gaa0fba9edb68c4708dbe8b4cd764b9454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a unary vector map expression (i.e. a type derived from the VecMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaa0fba9edb68c4708dbe8b4cd764b9454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d777f78de251e5dd16bcf53c7d6f77"><td class="memItemLeft" align="right" valign="top"><a id="ga24d777f78de251e5dd16bcf53c7d6f77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga24d777f78de251e5dd16bcf53c7d6f77">BLAZE_CONSTRAINT_MUST_BE_VECSCALARDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html">blaze::IsVecScalarDivExpr</a>&lt;T&gt;::value, &quot;Non-vector/scalar division expression type detected&quot; )</td></tr>
<tr class="memdesc:ga24d777f78de251e5dd16bcf53c7d6f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/scalar division expression (i.e. a type derived from the VecScalarDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga24d777f78de251e5dd16bcf53c7d6f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80b074900ae5ba72baf43fc6d42fa62"><td class="memItemLeft" align="right" valign="top"><a id="gaf80b074900ae5ba72baf43fc6d42fa62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf80b074900ae5ba72baf43fc6d42fa62">BLAZE_CONSTRAINT_MUST_NOT_BE_VECSCALARDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html">blaze::IsVecScalarDivExpr</a>&lt;T&gt;::value, &quot;Vector/scalar division expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf80b074900ae5ba72baf43fc6d42fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/scalar division expression (i.e. a type derived from the VecScalarDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf80b074900ae5ba72baf43fc6d42fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edc2c7dc3d160ed586a7d81d3e410b1"><td class="memItemLeft" align="right" valign="top"><a id="ga2edc2c7dc3d160ed586a7d81d3e410b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2edc2c7dc3d160ed586a7d81d3e410b1">BLAZE_CONSTRAINT_MUST_BE_VECSCALARMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html">blaze::IsVecScalarMultExpr</a>&lt;T&gt;::value, &quot;Non-vector/scalar multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2edc2c7dc3d160ed586a7d81d3e410b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/scalar multiplication expression (i.e. a type derived from the VecScalarMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2edc2c7dc3d160ed586a7d81d3e410b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bf8ad7debecccd302290677c1ce589"><td class="memItemLeft" align="right" valign="top"><a id="ga83bf8ad7debecccd302290677c1ce589"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga83bf8ad7debecccd302290677c1ce589">BLAZE_CONSTRAINT_MUST_NOT_BE_VECSCALARMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html">blaze::IsVecScalarMultExpr</a>&lt;T&gt;::value, &quot;Vector/scalar multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga83bf8ad7debecccd302290677c1ce589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/scalar multiplication expression (i.e. a type derived from the VecScalarMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga83bf8ad7debecccd302290677c1ce589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9d4ed2bca00e8364c20398b4ae0c1b"><td class="memItemLeft" align="right" valign="top"><a id="ga2e9d4ed2bca00e8364c20398b4ae0c1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga2e9d4ed2bca00e8364c20398b4ae0c1b">BLAZE_CONSTRAINT_MUST_BE_VECSERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html">blaze::IsVecSerialExpr</a>&lt;T&gt;::value, &quot;Non-vector serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga2e9d4ed2bca00e8364c20398b4ae0c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector serial evaluation expression (i.e. a type derived from the VecSerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga2e9d4ed2bca00e8364c20398b4ae0c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6a0262d3dcf31781e9d1436733eb09"><td class="memItemLeft" align="right" valign="top"><a id="ga3d6a0262d3dcf31781e9d1436733eb09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3d6a0262d3dcf31781e9d1436733eb09">BLAZE_CONSTRAINT_MUST_NOT_BE_VECSERIALEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html">blaze::IsVecSerialExpr</a>&lt;T&gt;::value, &quot;Vector serial evaluation expression type detected&quot; )</td></tr>
<tr class="memdesc:ga3d6a0262d3dcf31781e9d1436733eb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector serial evaluation expression (i.e. a type derived from the VecSerialExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga3d6a0262d3dcf31781e9d1436733eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa10ac18afb95b2670a5dd55f4a45d3"><td class="memItemLeft" align="right" valign="top"><a id="gaaaa10ac18afb95b2670a5dd55f4a45d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaaaa10ac18afb95b2670a5dd55f4a45d3">BLAZE_CONSTRAINT_MUST_BE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector</a>&lt;T&gt;::value, &quot;Non-vector type detected&quot; )</td></tr>
<tr class="memdesc:gaaaa10ac18afb95b2670a5dd55f4a45d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:gaaaa10ac18afb95b2670a5dd55f4a45d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee3b7f8ab62cce558e0fe87ae2cecc1"><td class="memItemLeft" align="right" valign="top"><a id="ga4ee3b7f8ab62cce558e0fe87ae2cecc1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga4ee3b7f8ab62cce558e0fe87ae2cecc1">BLAZE_CONSTRAINT_MUST_NOT_BE_VECTOR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector</a>&lt;T&gt;::value, &quot;Vector type detected&quot; )</td></tr>
<tr class="memdesc:ga4ee3b7f8ab62cce558e0fe87ae2cecc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a N-dimensional vector type, a compilation error is created. <br /></td></tr>
<tr class="separator:ga4ee3b7f8ab62cce558e0fe87ae2cecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28081141a1b4272c26cd47eccabae460"><td class="memItemLeft" align="right" valign="top"><a id="ga28081141a1b4272c26cd47eccabae460"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga28081141a1b4272c26cd47eccabae460">BLAZE_CONSTRAINT_MUST_BE_VECTRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html">blaze::IsVecTransExpr</a>&lt;T&gt;::value, &quot;Non-vector transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga28081141a1b4272c26cd47eccabae460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector transposition expression (i.e. a type derived from the VecTransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga28081141a1b4272c26cd47eccabae460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ea7876251c199f2002e50e52a89da1"><td class="memItemLeft" align="right" valign="top"><a id="gaf6ea7876251c199f2002e50e52a89da1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaf6ea7876251c199f2002e50e52a89da1">BLAZE_CONSTRAINT_MUST_NOT_BE_VECTRANSEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html">blaze::IsVecTransExpr</a>&lt;T&gt;::value, &quot;Vector transposition expression type detected&quot; )</td></tr>
<tr class="memdesc:gaf6ea7876251c199f2002e50e52a89da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector transposition expression (i.e. a type derived from the VecTransExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaf6ea7876251c199f2002e50e52a89da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa421b03e2e4351ef846445a239948a0d"><td class="memItemLeft" align="right" valign="top"><a id="gaa421b03e2e4351ef846445a239948a0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa421b03e2e4351ef846445a239948a0d">BLAZE_CONSTRAINT_MUST_BE_VECTVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html">blaze::IsVecTVecMultExpr</a>&lt;T&gt;::value, &quot;Non-outer product expression type detected&quot; )</td></tr>
<tr class="memdesc:gaa421b03e2e4351ef846445a239948a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not an outer product expression (i.e. a type derived from the VecTVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaa421b03e2e4351ef846445a239948a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a47c8326b68d0d1bcd512a5a00abc7"><td class="memItemLeft" align="right" valign="top"><a id="ga42a47c8326b68d0d1bcd512a5a00abc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga42a47c8326b68d0d1bcd512a5a00abc7">BLAZE_CONSTRAINT_MUST_NOT_BE_VECTVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html">blaze::IsVecTVecMultExpr</a>&lt;T&gt;::value, &quot;Outer product expression type detected&quot; )</td></tr>
<tr class="memdesc:ga42a47c8326b68d0d1bcd512a5a00abc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is an outer product expression (i.e. a type derived from the VecTVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga42a47c8326b68d0d1bcd512a5a00abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc1bcdddb5ad17f7adff0d831b9e99d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3dc1bcdddb5ad17f7adff0d831b9e99d">BLAZE_CONSTRAINT_MUST_FORM_VALID_VECTVECMULTEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga3dc1bcdddb5ad17f7adff0d831b9e99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector multiplication, a compilation error is created.  <a href="#ga3dc1bcdddb5ad17f7adff0d831b9e99d">More...</a><br /></td></tr>
<tr class="separator:ga3dc1bcdddb5ad17f7adff0d831b9e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f81d9debe7d99fa4ff77d3bd197e34a"><td class="memItemLeft" align="right" valign="top"><a id="ga5f81d9debe7d99fa4ff77d3bd197e34a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5f81d9debe7d99fa4ff77d3bd197e34a">BLAZE_CONSTRAINT_MUST_BE_VECVECADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">blaze::IsVecVecAddExpr</a>&lt;T&gt;::value, &quot;Non-vector/vector addition expression type detected&quot; )</td></tr>
<tr class="memdesc:ga5f81d9debe7d99fa4ff77d3bd197e34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/vector addition expression (i.e. a type derived from the VecVecAddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga5f81d9debe7d99fa4ff77d3bd197e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a79cf1dd91ecb554fee3422fd3dcb8"><td class="memItemLeft" align="right" valign="top"><a id="gab7a79cf1dd91ecb554fee3422fd3dcb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gab7a79cf1dd91ecb554fee3422fd3dcb8">BLAZE_CONSTRAINT_MUST_NOT_BE_VECVECADDEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">blaze::IsVecVecAddExpr</a>&lt;T&gt;::value, &quot;Vector/vector addition expression type detected&quot; )</td></tr>
<tr class="memdesc:gab7a79cf1dd91ecb554fee3422fd3dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/vector addition expression (i.e. a type derived from the VecVecAddExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gab7a79cf1dd91ecb554fee3422fd3dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9bb7d2a5932ba81ca23e8a0c5683c2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaa9bb7d2a5932ba81ca23e8a0c5683c2c">BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECADDEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:gaa9bb7d2a5932ba81ca23e8a0c5683c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector addition, a compilation error is created.  <a href="#gaa9bb7d2a5932ba81ca23e8a0c5683c2c">More...</a><br /></td></tr>
<tr class="separator:gaa9bb7d2a5932ba81ca23e8a0c5683c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6013ae25189030d12f0a487cc40e61f0"><td class="memItemLeft" align="right" valign="top"><a id="ga6013ae25189030d12f0a487cc40e61f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6013ae25189030d12f0a487cc40e61f0">BLAZE_CONSTRAINT_MUST_BE_VECVECDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html">blaze::IsVecVecDivExpr</a>&lt;T&gt;::value, &quot;Non-vector/vector division expression type detected&quot; )</td></tr>
<tr class="memdesc:ga6013ae25189030d12f0a487cc40e61f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/vector division expression (i.e. a type derived from the VecVecDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga6013ae25189030d12f0a487cc40e61f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1d5bd8ad2c5c96f24648859987e0c6"><td class="memItemLeft" align="right" valign="top"><a id="ga3c1d5bd8ad2c5c96f24648859987e0c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3c1d5bd8ad2c5c96f24648859987e0c6">BLAZE_CONSTRAINT_MUST_NOT_BE_VECVECDIVEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html">blaze::IsVecVecDivExpr</a>&lt;T&gt;::value, &quot;Vector/vector division expression type detected&quot; )</td></tr>
<tr class="memdesc:ga3c1d5bd8ad2c5c96f24648859987e0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/vector division expression (i.e. a type derived from the VecVecDivExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga3c1d5bd8ad2c5c96f24648859987e0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6522f9ac107055695bab22139c9e967e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga6522f9ac107055695bab22139c9e967e">BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECDIVEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga6522f9ac107055695bab22139c9e967e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector division, a compilation error is created.  <a href="#ga6522f9ac107055695bab22139c9e967e">More...</a><br /></td></tr>
<tr class="separator:ga6522f9ac107055695bab22139c9e967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac3f1b9bee006412a7edbd45936195e"><td class="memItemLeft" align="right" valign="top"><a id="ga1ac3f1b9bee006412a7edbd45936195e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1ac3f1b9bee006412a7edbd45936195e">BLAZE_CONSTRAINT_MUST_BE_VECVECMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d7/d29/structblaze_1_1IsVecVecMapExpr.html">blaze::IsVecVecMapExpr</a>&lt;T&gt;::value, &quot;Non-binary vector map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga1ac3f1b9bee006412a7edbd45936195e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a binary vector map expression (i.e. a type derived from the VecVecMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga1ac3f1b9bee006412a7edbd45936195e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77301f026e574aefbc350be4fc3d698e"><td class="memItemLeft" align="right" valign="top"><a id="ga77301f026e574aefbc350be4fc3d698e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga77301f026e574aefbc350be4fc3d698e">BLAZE_CONSTRAINT_MUST_NOT_BE_VECVECMAPEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d7/d29/structblaze_1_1IsVecVecMapExpr.html">blaze::IsVecVecMapExpr</a>&lt;T&gt;::value, &quot;Binary vector map expression type detected&quot; )</td></tr>
<tr class="memdesc:ga77301f026e574aefbc350be4fc3d698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a binary vector map expression (i.e. a type derived from the VecVecMapExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga77301f026e574aefbc350be4fc3d698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010b67bc499ac7e7ae902d4953e62fee"><td class="memItemLeft" align="right" valign="top"><a id="ga010b67bc499ac7e7ae902d4953e62fee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga010b67bc499ac7e7ae902d4953e62fee">BLAZE_CONSTRAINT_MUST_BE_VECVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">blaze::IsVecVecMultExpr</a>&lt;T&gt;::value, &quot;Non-vector/vector multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga010b67bc499ac7e7ae902d4953e62fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/vector multiplication expression (i.e. a type derived from the VecVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga010b67bc499ac7e7ae902d4953e62fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b2f17438680f7d4d920828bdeae250"><td class="memItemLeft" align="right" valign="top"><a id="ga03b2f17438680f7d4d920828bdeae250"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga03b2f17438680f7d4d920828bdeae250">BLAZE_CONSTRAINT_MUST_NOT_BE_VECVECMULTEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">blaze::IsVecVecMultExpr</a>&lt;T&gt;::value, &quot;Vector/vector multiplication expression type detected&quot; )</td></tr>
<tr class="memdesc:ga03b2f17438680f7d4d920828bdeae250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/vector multiplication expression (i.e. a type derived from the VecVecMultExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga03b2f17438680f7d4d920828bdeae250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7abd7244e236347b0add72c6e75f7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga5f7abd7244e236347b0add72c6e75f7a">BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECMULTEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga5f7abd7244e236347b0add72c6e75f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector multiplication, a compilation error is created.  <a href="#ga5f7abd7244e236347b0add72c6e75f7a">More...</a><br /></td></tr>
<tr class="separator:ga5f7abd7244e236347b0add72c6e75f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb0304a70f737021463913b5247489a"><td class="memItemLeft" align="right" valign="top"><a id="gaaeb0304a70f737021463913b5247489a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#gaaeb0304a70f737021463913b5247489a">BLAZE_CONSTRAINT_MUST_BE_VECVECSUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">blaze::IsVecVecSubExpr</a>&lt;T&gt;::value, &quot;Non-vector/vector subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:gaaeb0304a70f737021463913b5247489a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a vector/vector subtraction expression (i.e. a type derived from the VecVecSubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:gaaeb0304a70f737021463913b5247489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea14340437be0eb3213a85bde5add3a"><td class="memItemLeft" align="right" valign="top"><a id="ga3ea14340437be0eb3213a85bde5add3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga3ea14340437be0eb3213a85bde5add3a">BLAZE_CONSTRAINT_MUST_NOT_BE_VECVECSUBEXPR_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">blaze::IsVecVecSubExpr</a>&lt;T&gt;::value, &quot;Vector/vector subtraction expression type detected&quot; )</td></tr>
<tr class="memdesc:ga3ea14340437be0eb3213a85bde5add3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a vector/vector subtraction expression (i.e. a type derived from the VecVecSubExpr base class), a compilation error is created. <br /></td></tr>
<tr class="separator:ga3ea14340437be0eb3213a85bde5add3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c46a596751157702edf4fa4385bb8a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga7c46a596751157702edf4fa4385bb8a2">BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECSUBEXPR</a>(T1,  T2)</td></tr>
<tr class="memdesc:ga7c46a596751157702edf4fa4385bb8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector subtraction, a compilation error is created.  <a href="#ga7c46a596751157702edf4fa4385bb8a2">More...</a><br /></td></tr>
<tr class="separator:ga7c46a596751157702edf4fa4385bb8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20031b3fe18315d6e6224ee3fdac9825"><td class="memItemLeft" align="right" valign="top"><a id="ga20031b3fe18315d6e6224ee3fdac9825"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga20031b3fe18315d6e6224ee3fdac9825">BLAZE_CONSTRAINT_MUST_BE_VIEW_TYPE</a>(T)&#160;&#160;&#160;static_assert( ::<a class="el" href="../../da/dbb/structblaze_1_1IsView.html">blaze::IsView</a>&lt;T&gt;::value, &quot;Non-view type detected&quot; )</td></tr>
<tr class="memdesc:ga20031b3fe18315d6e6224ee3fdac9825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is not a view type (i.e. a subvector, submatrix, row, column, ...), a compilation error is created. <br /></td></tr>
<tr class="separator:ga20031b3fe18315d6e6224ee3fdac9825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe9fee800d634f30ab4504be08ee2db"><td class="memItemLeft" align="right" valign="top"><a id="ga1fe9fee800d634f30ab4504be08ee2db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html#ga1fe9fee800d634f30ab4504be08ee2db">BLAZE_CONSTRAINT_MUST_NOT_BE_VIEW_TYPE</a>(T)&#160;&#160;&#160;static_assert( !::<a class="el" href="../../da/dbb/structblaze_1_1IsView.html">blaze::IsView</a>&lt;T&gt;::value, &quot;View type detected&quot; )</td></tr>
<tr class="memdesc:ga1fe9fee800d634f30ab4504be08ee2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint on the data type.In case the given data type <em>T</em> is a view type (i.e. a subvector, submatrix, row, column, ...), a compilation error is created. <br /></td></tr>
<tr class="separator:ga1fe9fee800d634f30ab4504be08ee2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4b00d6a4f7ffe501d852ab7846f60c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b00d6a4f7ffe501d852ab7846f60c83">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_DIFFERENT_STORAGE_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_DIFFERENT_STORAGE_ORDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt;T1&gt;::value</a> != ::<a class="code" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt;T2&gt;::value</a>, <span class="stringliteral">&quot;Invalid storage order detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1StorageOrder_html"><div class="ttname"><a href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder</a></div><div class="ttdoc">Evaluation of the storage order of a given matrix type.Via this type trait it is possible to evaluate...</div><div class="ttdef"><b>Definition:</b> StorageOrder.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a matrix type and in case the storage order of both matrix types does match, a compilation error is created. </p>

</div>
</div>
<a id="ga12f07effa42bba2ab4fc9f5b41289ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f07effa42bba2ab4fc9f5b41289ba1">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_SAME_STORAGE_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MATRICES_MUST_HAVE_SAME_STORAGE_ORDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt;T1&gt;::value</a> == ::<a class="code" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt;T2&gt;::value</a>, <span class="stringliteral">&quot;Invalid storage order failed&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1StorageOrder_html"><div class="ttname"><a href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder</a></div><div class="ttdoc">Evaluation of the storage order of a given matrix type.Via this type trait it is possible to evaluate...</div><div class="ttdef"><b>Definition:</b> StorageOrder.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a matrix type and in case the storage order of both matrix types doesn't match, a compilation error is created. </p>

</div>
</div>
<a id="gafb0dee9bc8ad903ee82af4a604be4aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0dee9bc8ad903ee82af4a604be4aee">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_BE_MATRIX_WITH_STORAGE_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_BE_MATRIX_WITH_STORAGE_ORDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SO&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt;T&gt;::value</a> == SO, <span class="stringliteral">&quot;Invalid storage order detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1StorageOrder_html"><div class="ttname"><a href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder</a></div><div class="ttdoc">Evaluation of the storage order of a given matrix type.Via this type trait it is possible to evaluate...</div><div class="ttdef"><b>Definition:</b> StorageOrder.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data type <em>T</em> is not a dense or sparse matrix type and in case the storage order of the given dense or sparse vector type <em>T</em> is not set to <em>SO</em>, a compilation error is created. </p>

</div>
</div>
<a id="ga5a90251fe065c55a187bff4f9502f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a90251fe065c55a187bff4f9502f89f">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_BE_VECTOR_WITH_TRANSPOSE_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_BE_VECTOR_WITH_TRANSPOSE_FLAG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TF&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt;T&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt;T&gt;::value</a> == TF, <span class="stringliteral">&quot;Invalid transpose flag detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsVector_html"><div class="ttname"><a href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector</a></div><div class="ttdoc">Compile time check for vector types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsVector.h:104</div></div>
<div class="ttc" id="structblaze_1_1TransposeFlag_html"><div class="ttname"><a href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag</a></div><div class="ttdoc">Evaluation of the transpose flag of a given matrix type.Via this type trait it is possible to evaluat...</div><div class="ttdef"><b>Definition:</b> TransposeFlag.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data type <em>T</em> is not a dense or sparse vector type and in case the transpose flag of the given dense or sparse vector type <em>T</em> is not set to <em>TF</em>, a compilation error is created. </p>

</div>
</div>
<a id="gab612133c7a5935690f612581f00fbb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab612133c7a5935690f612581f00fbb5a">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATADDEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATADDEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid matrix/matrix addition expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix addition, a compilation error is created. </p>

</div>
</div>
<a id="ga3b648c6fd2e9f5190410d2c9c10ad86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b648c6fd2e9f5190410d2c9c10ad86b">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATMULTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATMULTEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid matrix/matrix multiplication expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix multiplication, a compilation error is created. </p>

</div>
</div>
<a id="ga1f86f7f7591b991fccc9cc2aba65f0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f86f7f7591b991fccc9cc2aba65f0ef">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATSUBEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_MATMATSUBEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid matrix/matrix subtraction expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix subtraction, a compilation error is created. </p>

</div>
</div>
<a id="ga8a7e027ea65317a59d6b270c117ed827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a7e027ea65317a59d6b270c117ed827">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_MATVECMULTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_MATVECMULTEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid matrix/vector multiplication expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/vector multiplication, a compilation error is created. </p>

</div>
</div>
<a id="gac3679b40131e9ab8af300dc825073bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3679b40131e9ab8af300dc825073bd9">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_SCHUREXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_SCHUREXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid matrix/matrix addition expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid matrix/matrix addition, a compilation error is created. </p>

</div>
</div>
<a id="ga24ce5c83f88bdb146dd7e98f830d4ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ce5c83f88bdb146dd7e98f830d4ec0">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_TVECMATMULTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_TVECMATMULTEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt;T2&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/matrix multiplication expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsMatrix_html"><div class="ttname"><a href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix</a></div><div class="ttdoc">Compile time check for matrix types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsMatrix.h:103</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/matrix multiplication, a compilation error is created. </p>

</div>
</div>
<a id="ga3dc1bcdddb5ad17f7adff0d831b9e99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc1bcdddb5ad17f7adff0d831b9e99d">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_VECTVECMULTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_VECTVECMULTEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T1&gt;</a> \</div><div class="line">                              , ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T2&gt;</a> \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/vector multiplication expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector multiplication, a compilation error is created. </p>

</div>
</div>
<a id="gaa9bb7d2a5932ba81ca23e8a0c5683c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9bb7d2a5932ba81ca23e8a0c5683c2c">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECADDEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECADDEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T2&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/vector addition expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector addition, a compilation error is created. </p>

</div>
</div>
<a id="ga6522f9ac107055695bab22139c9e967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6522f9ac107055695bab22139c9e967e">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECDIVEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECDIVEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T2&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/vector division expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector division, a compilation error is created. </p>

</div>
</div>
<a id="ga5f7abd7244e236347b0add72c6e75f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7abd7244e236347b0add72c6e75f7a">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECMULTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECMULTEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T2&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/vector multiplication expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector multiplication, a compilation error is created. </p>

</div>
</div>
<a id="ga7c46a596751157702edf4fa4385bb8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c46a596751157702edf4fa4385bb8a2">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECSUBEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_FORM_VALID_VECVECSUBEXPR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt;T2&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/d97/structblaze_1_1And.html">blaze::And</a>&lt; ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T1&gt;</a> \</div><div class="line">                                                         , ::<a class="code" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              , ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                                           , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                              &gt;::value, <span class="stringliteral">&quot;Invalid vector/vector subtraction expression detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsRowVector_html"><div class="ttname"><a href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector</a></div><div class="ttdoc">Compile time check for row vector types.This type trait tests whether or not the given template argum...</div><div class="ttdef"><b>Definition:</b> IsRowVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1IsColumnVector_html"><div class="ttname"><a href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector</a></div><div class="ttdoc">Compile time check for column vector types.This type trait tests whether or not the given template ar...</div><div class="ttdef"><b>Definition:</b> IsColumnVector.h:107</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
<div class="ttc" id="structblaze_1_1And_html"><div class="ttname"><a href="../../d7/d97/structblaze_1_1And.html">blaze::And</a></div><div class="ttdoc">Compile time logical and evaluation.The And alias declaration performs at compile time a logical and ...</div><div class="ttdef"><b>Definition:</b> And.h:76</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the given data types <em>T1</em> and <em>T2</em> do not form a valid vector/vector subtraction, a compilation error is created. </p>

</div>
</div>
<a id="ga038d2d773aeae200139fd658645d370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038d2d773aeae200139fd658645d370a">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_COLUMNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_COLUMNS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a> &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid number of columns detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the number of columns of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of columns is not equal, a compilation error is created. Note that in case the number of columns of either of the two matrix types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="ga592820e99022ac6fe740951b8f34aa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592820e99022ac6fe740951b8f34aa9c">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_NUMBER_OF_ROWS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid number of rows detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the number of rows of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of rows is not equal, a compilation error is created. Note that in case the number of rows of either of the two matrix types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="gaba242807c418330b99067208af8d0128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba242807c418330b99067208af8d0128">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_HAVE_EQUAL_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid size detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the size of the two given vector types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case these sizes are not equal, a compilation error is created. Note that in case the size of either of the two vector types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="ga3ffcdb3e0ce146ff1239b60605b6d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ffcdb3e0ce146ff1239b60605b6d277">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_COLUMNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_COLUMNS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T1&gt;</a>, ::<a class="code" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid number of columns detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Not_html"><div class="ttname"><a href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a></div><div class="ttdoc">Compile time type negation.The Not alias declaration negates the given compile time condition...</div><div class="ttdef"><b>Definition:</b> Not.h:70</div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Columns_html"><div class="ttname"><a href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns</a></div><div class="ttdoc">Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...</div><div class="ttdef"><b>Definition:</b> Columns.h:75</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the number of columns of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of columns is equal, a compilation error is created. Note that in case the number of columns of either of the two matrix types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="gafc2ccaa63577a8686de70a08681f8ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2ccaa63577a8686de70a08681f8ac5">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_NUMBER_OF_ROWS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T1&gt;</a>, ::<a class="code" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid number of rows detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Not_html"><div class="ttname"><a href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a></div><div class="ttdoc">Compile time type negation.The Not alias declaration negates the given compile time condition...</div><div class="ttdef"><b>Definition:</b> Not.h:70</div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Rows_html"><div class="ttname"><a href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows</a></div><div class="ttdoc">Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...</div><div class="ttdef"><b>Definition:</b> Rows.h:75</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the number of rows of the two given matrix types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case the number of rows is equal, a compilation error is created. Note that in case the number of rows of either of the two matrix types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="gaf94ece977784856de651ff740f4e4266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94ece977784856de651ff740f4e4266">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_MUST_NOT_HAVE_EQUAL_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a>, ::<a class="code" href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L&gt;</a> &gt; \</div><div class="line">                             , ::<a class="code" href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a>&lt; ::<a class="code" href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a>&lt; ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T1&gt;</a>, ::<a class="code" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt;T2&gt;</a> &gt; &gt; \</div><div class="line">                             &gt;::value, <span class="stringliteral">&quot;Invalid size detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1Equal_html"><div class="ttname"><a href="../../d7/dc4/structblaze_1_1Equal.html">blaze::Equal</a></div><div class="ttdoc">Compile time type comparison.The Equal alias declaration compares the two given types using the equal...</div><div class="ttdef"><b>Definition:</b> Equal.h:73</div></div>
<div class="ttc" id="structblaze_1_1PtrdiffT_html"><div class="ttname"><a href="../../d0/dc2/structblaze_1_1PtrdiffT.html">blaze::PtrdiffT&lt;-1L &gt;</a></div></div>
<div class="ttc" id="structblaze_1_1Not_html"><div class="ttname"><a href="../../dd/d46/structblaze_1_1Not.html">blaze::Not</a></div><div class="ttdoc">Compile time type negation.The Not alias declaration negates the given compile time condition...</div><div class="ttdef"><b>Definition:</b> Not.h:70</div></div>
<div class="ttc" id="structblaze_1_1Or_html"><div class="ttname"><a href="../../d3/d81/structblaze_1_1Or.html">blaze::Or</a></div><div class="ttdoc">Compile time logical or evaluation.The Or alias declaration performs at compile time a logical or (&amp;#39;&amp;&amp;&amp;#3...</div><div class="ttdef"><b>Definition:</b> Or.h:76</div></div>
<div class="ttc" id="structblaze_1_1Size_html"><div class="ttname"><a href="../../df/d5d/structblaze_1_1Size.html">blaze::Size</a></div><div class="ttdoc">Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...</div><div class="ttdef"><b>Definition:</b> Size.h:74</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case the size of the two given vector types <em>T1</em> and <em>T2</em> can be evaluated at compile time and in case these sizes are equal, a compilation error is created. Note that in case the size of either of the two vector types cannot be determined no compilation error is created. </p>

</div>
</div>
<a id="ga6eac2eb9defdc89c03f7e70d32b20322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eac2eb9defdc89c03f7e70d32b20322">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_DIFFERENT_TRANSPOSE_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_DIFFERENT_TRANSPOSE_FLAG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt;T1&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt;T2&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt;T1&gt;::value</a> != ::<a class="code" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt;T2&gt;::value</a>, <span class="stringliteral">&quot;Invalid transpose flag detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsVector_html"><div class="ttname"><a href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector</a></div><div class="ttdoc">Compile time check for vector types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsVector.h:104</div></div>
<div class="ttc" id="structblaze_1_1TransposeFlag_html"><div class="ttname"><a href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag</a></div><div class="ttdoc">Evaluation of the transpose flag of a given matrix type.Via this type trait it is possible to evaluat...</div><div class="ttdef"><b>Definition:</b> TransposeFlag.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a vector type and in case the transpose flags of both vector types does match, a compilation error is created. </p>

</div>
</div>
<a id="gaa7a3773e29675fc6a65cc4c3fdce1f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a3773e29675fc6a65cc4c3fdce1f52">&#9670;&nbsp;</a></span>BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_SAME_TRANSPOSE_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CONSTRAINT_VECTORS_MUST_HAVE_SAME_TRANSPOSE_FLAG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert( ::<a class="code" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt;T1&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt;T2&gt;::value</a> &amp;&amp; \</div><div class="line">                  ::<a class="code" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt;T1&gt;::value</a> == ::<a class="code" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt;T2&gt;::value</a>, <span class="stringliteral">&quot;Invalid transpose flag detected&quot;</span> )</div><div class="ttc" id="structblaze_1_1IsVector_html"><div class="ttname"><a href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector</a></div><div class="ttdoc">Compile time check for vector types.This type trait tests whether or not the given template parameter...</div><div class="ttdef"><b>Definition:</b> IsVector.h:104</div></div>
<div class="ttc" id="structblaze_1_1TransposeFlag_html"><div class="ttname"><a href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag</a></div><div class="ttdoc">Evaluation of the transpose flag of a given matrix type.Via this type trait it is possible to evaluat...</div><div class="ttdef"><b>Definition:</b> TransposeFlag.h:99</div></div>
</div><!-- fragment -->
<p>Constraint on the data type.In case either of the two given data types <em>T1</em> or <em>T2</em> is not a vector type and in case the transpose flags of both vector types don't match, a compilation error is created. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
