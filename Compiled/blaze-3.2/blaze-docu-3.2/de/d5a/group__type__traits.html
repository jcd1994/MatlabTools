<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">blaze::AddConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' qualifier.The <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait adds a top level 'const' qualifier to the given type <em>T</em>.  <a href="../../d7/da6/structblaze_1_1AddConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d58/structblaze_1_1AddCV.html">blaze::AddCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' and 'volatile' qualifier.The <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait adds both a top level 'const' and 'volatile' qualifier to the given type <em>T</em>.  <a href="../../df/d58/structblaze_1_1AddCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">blaze::AddPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level pointer.The <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait adds a top level pointer to the given type <em>T</em>. It has the same effect as <code>blaze::RemovePointer&lt;T&gt;::Type*</code>.  <a href="../../d4/da6/structblaze_1_1AddPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">blaze::AddReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level reference.In case the given type <em>T</em> is not a reference type, the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait adds a top level reference to the given type <em>T</em>. Else the resulting type <em>Type</em> is <em>T</em>.  <a href="../../dd/d30/structblaze_1_1AddReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">blaze::AddVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'volatile' qualifier.The <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait adds a top level 'volatile' qualifier to the given type <em>T</em>.  <a href="../../d2/df0/structblaze_1_1AddVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">blaze::AlignmentOf&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../d5/dc6/structblaze_1_1AlignmentOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1All.html">blaze::All&lt; TypeTrait, T1, T2, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for all given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the expression.  <a href="../../d9/de6/structblaze_1_1All.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfd/structblaze_1_1Any.html">blaze::Any&lt; TypeTrait, T1, T2, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait determines whether the given type trait <em>TypeTrait</em> evaluates to <em>true</em> for at least one of the given types <em>Ts</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the expression.  <a href="../../d9/dfd/structblaze_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">blaze::CommonType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction of a type common to several types.The <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait deduces the result type of a mixed-mode arithmetic expression between all types T..., that is the type all T... can be implicitly converted to. Note that cv and reference qualifiers are generally ignored.  <a href="../../dd/d1c/structblaze_1_1CommonType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/structblaze_1_1Decay.html">blaze::Decay&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the type conversions for by-value function arguments.This type trait applies the type conversions that are used for by-value function arguments. This conversions include lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type <code>T</code>, and the removal of top level cv-qualifiers.  <a href="../../df/dbe/structblaze_1_1Decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d50/structblaze_1_1Extent.html">blaze::Extent&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the size of array bounds.Via this type trait it is possible to query at compile time for the size of a particular array extent. In case the given template argument is an array type with a rank greater than N, the <em>value</em> member constant is set to the number of elements of the N'th array dimension. In all other cases, and especially in case the N'th array dimension is incomplete, <em>value</em> is set to 0.  <a href="../../d2/d50/structblaze_1_1Extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">blaze::HasSize&lt; T, Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type <em>T</em> is exactly <em><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a></em> bytes large, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">blaze::Has1Byte&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type <em>T</em> has one byte, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">blaze::Has2Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">blaze::Has4Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">blaze::Has8Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from<em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the classderives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">blaze::HaveSameSize&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">blaze::IsArithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">blaze::IsArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait tests whether or not the given template parameter is an array type. In case the given data type is an array type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../d9/d2c/structblaze_1_1IsArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html">blaze::IsAssignable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/dd9/structblaze_1_1IsAssignable.html" title="Compile time type check.The IsAssignable type trait tests whether the expression. ...">IsAssignable</a> type trait tests whether the expression.  <a href="../../df/dd9/structblaze_1_1IsAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html">blaze::IsNothrowAssignable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html" title="Compile time type check.The IsNothrowAssignable type trait tests whether the expression. ">IsNothrowAssignable</a> type trait tests whether the expression.  <a href="../../db/dd3/structblaze_1_1IsNothrowAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html">blaze::IsCopyAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../da/d54/structblaze_1_1IsCopyAssignable.html" title="Compile time type check.The IsCopyAssignable type trait tests whether the expression. ">IsCopyAssignable</a> type trait tests whether the expression.  <a href="../../da/d54/structblaze_1_1IsCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html">blaze::IsNothrowCopyAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html" title="Compile time type check.The IsNothrowCopyAssignable type trait tests whether the expression. ">IsNothrowCopyAssignable</a> type trait tests whether the expression.  <a href="../../d4/d7e/structblaze_1_1IsNothrowCopyAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html">blaze::IsMoveAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d6/d39/structblaze_1_1IsMoveAssignable.html" title="Compile time type check.The IsMoveAssignable type trait tests whether the expression. ">IsMoveAssignable</a> type trait tests whether the expression.  <a href="../../d6/d39/structblaze_1_1IsMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html">blaze::IsNothrowMoveAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html" title="Compile time type check.The IsNothrowMoveAssignable type trait tests whether the expression. ">IsNothrowMoveAssignable</a> type trait tests whether the expression.  <a href="../../db/def/structblaze_1_1IsNothrowMoveAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">blaze::IsBaseOf&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member contant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">blaze::IsBoolean&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">blaze::IsBuiltin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">blaze::IsCharacter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">blaze::IsClass&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">blaze::IsComplex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5e/structblaze_1_1IsComplexDouble.html">blaze::IsComplexDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;double&gt;</code>. In case the type is <code>complex&lt;double&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d5e/structblaze_1_1IsComplexDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d20/structblaze_1_1IsComplexFloat.html">blaze::IsComplexFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision complex types.This type trait tests whether or not the given template parameter is of type <code>complex&lt;float&gt;</code>. In case the type is <code>complex&lt;float&gt;</code> (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d20/structblaze_1_1IsComplexFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">blaze::IsConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html">blaze::IsConstructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/dc8/structblaze_1_1IsConstructible.html" title="Compile time type check.The IsConstructible type trait tests whether the expression. ">IsConstructible</a> type trait tests whether the expression.  <a href="../../d9/dc8/structblaze_1_1IsConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html">blaze::IsNothrowConstructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html" title="Compile time type check.The IsNothrowConstructible type trait tests whether the expression. ">IsNothrowConstructible</a> type trait tests whether the expression.  <a href="../../dd/de6/structblaze_1_1IsNothrowConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html">blaze::IsDefaultConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html" title="Compile time type check.The IsDefaultConstructible type trait tests whether the expression. ">IsDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d8/ddb/structblaze_1_1IsDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html">blaze::IsNothrowDefaultConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html" title="Compile time type check.The IsNothrowDefaultConstructible type trait tests whether the expression...">IsNothrowDefaultConstructible</a> type trait tests whether the expression.  <a href="../../d1/de5/structblaze_1_1IsNothrowDefaultConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html">blaze::IsCopyConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../df/d1e/structblaze_1_1IsCopyConstructible.html" title="Compile time type check.The IsCopyConstructible type trait tests whether the expression. ">IsCopyConstructible</a> type trait tests whether the expression.  <a href="../../df/d1e/structblaze_1_1IsCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html">blaze::IsNothrowCopyConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html" title="Compile time type check.The IsNothrowCopyConstructible type trait tests whether the expression...">IsNothrowCopyConstructible</a> type trait tests whether the expression.  <a href="../../d1/d6c/structblaze_1_1IsNothrowCopyConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html">blaze::IsMoveConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d1/d17/structblaze_1_1IsMoveConstructible.html" title="Compile time type check.The IsMoveConstructible type trait tests whether the expression. ">IsMoveConstructible</a> type trait tests whether the expression.  <a href="../../d1/d17/structblaze_1_1IsMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html">blaze::IsNothrowMoveConstructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html" title="Compile time type check.The IsNothrowMoveConstructible type trait tests whether the expression...">IsNothrowMoveConstructible</a> type trait tests whether the expression.  <a href="../../dc/dd5/structblaze_1_1IsNothrowMoveConstructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">blaze::IsConvertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the first argument can be converted to the second argument, the <em>value</em> member constnt is set to <em>true</em>, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html">blaze::IsDestructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d64/structblaze_1_1IsDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html">blaze::IsNothrowDestructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dc/d64/structblaze_1_1IsDestructible.html" title="Compile time type check.The IsDestructible type trait tests whether the expression. ">IsDestructible</a> type trait tests whether the expression.  <a href="../../dc/d8b/structblaze_1_1IsNothrowDestructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">blaze::IsDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">blaze::IsEmpty&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is an empty class type, i.e. a type without member data and virtual functions. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> it is an empty class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d47/structblaze_1_1IsEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd5/structblaze_1_1IsEnum.html">blaze::IsEnum&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complete enumeration types.This type trait tests whether or not the given template parameter is an enumeration type. In case the type is an enumeration type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dd5/structblaze_1_1IsEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">blaze::IsFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">blaze::IsFloatingPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">blaze::IsInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">blaze::IsIntegral&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">blaze::IsLong&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">blaze::IsLongDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d62/structblaze_1_1IsLValueReference.html">blaze::IsLValueReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an lvalue reference type. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> it is an lvalue reference type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d62/structblaze_1_1IsLValueReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">blaze::IsNumeric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">blaze::IsObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>T</em> is an object type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">blaze::IsPod&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data). In case the type is a POD, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">blaze::IsPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> it is a pointer type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">blaze::IsReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> it is a reference type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d45/structblaze_1_1IsRValueReference.html">blaze::IsRValueReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an rvalue reference type. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> it is an rvalue reference type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d45/structblaze_1_1IsRValueReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">blaze::IsStrictlySame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">blaze::IsSame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">blaze::IsShort&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">blaze::IsSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral or a floating point data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">blaze::IsUnion&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for union data types.This type trait tests whether or not the given template parameter is a union data type. In case the type is a union, the <em>value</em> member constant is set o <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/dc7/structblaze_1_1IsUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">blaze::IsUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6e/structblaze_1_1IsValid.html">blaze::IsValid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a valid or invalid data type (i.e. if the type is the INVALID_TYPE). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>T</em> is not the INVALID_TYPE class type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d6e/structblaze_1_1IsValid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">blaze::IsVectorizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, all built-in data types except <code>bool</code> and the according complex numbers are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">blaze::IsVoid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">blaze::IsVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">blaze::MakeSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into a signed integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding signed integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../da/da3/structblaze_1_1MakeSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">blaze::MakeUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into an unsigned integral type.This type trait provides the feature to convert the given integral or constant type <em>T</em> to the corresponding unsigned integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../d9/dd7/structblaze_1_1MakeUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db0/structblaze_1_1Rank.html">blaze::Rank&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for array ranks.This type trait determines the rank of the given template argument. In case the given type is an array type, the nested <em>value</em> member constant is set to the number of dimensions of <em>T</em>. Otherwise <em>value</em> is set to 0.  <a href="../../df/db0/structblaze_1_1Rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">blaze::RemoveAllExtents&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of all array extents.The <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait removes all array extents from the given type <em>T</em>.  <a href="../../de/d59/structblaze_1_1RemoveAllExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">blaze::RemoveConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">blaze::RemoveCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">blaze::RemoveExtent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of the top level array extent.The <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait removes the top level array extent from the given type <em>T</em>.  <a href="../../d7/d88/structblaze_1_1RemoveExtent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">blaze::RemovePointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">blaze::RemoveReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">blaze::RemoveVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3b380783804d78aa5b21e51415cc3564"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3b380783804d78aa5b21e51415cc3564"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga3b380783804d78aa5b21e51415cc3564">blaze::HighType_</a> = typename <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html">HighType</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga3b380783804d78aa5b21e51415cc3564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> type trait.The HighType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga3b380783804d78aa5b21e51415cc3564">More...</a><br /></td></tr>
<tr class="separator:ga3b380783804d78aa5b21e51415cc3564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga5a3fa9d03c150105c91bf86867ae6777">blaze::LowType_</a> = typename <a class="el" href="../../d5/d00/structblaze_1_1LowType.html">LowType</a>&lt; T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga5a3fa9d03c150105c91bf86867ae6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> type trait.The LowType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga5a3fa9d03c150105c91bf86867ae6777">More...</a><br /></td></tr>
<tr class="separator:ga5a3fa9d03c150105c91bf86867ae6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1054a603bf1d73c443e374227954a9b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">blaze::RemoveAdaptor_</a> = typename <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1054a603bf1d73c443e374227954a9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait.The RemoveAdaptor_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">More...</a><br /></td></tr>
<tr class="separator:ga1054a603bf1d73c443e374227954a9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">blaze::UnderlyingBuiltin_</a> = typename <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> type trait.The UnderlyingBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">More...</a><br /></td></tr>
<tr class="separator:ga21ed6b57b46e4eb4a400f581bca0f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">blaze::UnderlyingElement_</a> = typename <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> type trait.The UnderlyingElement_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">More...</a><br /></td></tr>
<tr class="separator:gaa1d099d4d07f45ddddd62de3908b3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11e3f75bd557307b815516615471dc20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">blaze::UnderlyingNumeric_</a> = typename <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga11e3f75bd557307b815516615471dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> type trait.The UnderlyingNumeric_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">More...</a><br /></td></tr>
<tr class="separator:ga11e3f75bd557307b815516615471dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa4d07e6853705c0c77730625effda54f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">blaze::AddConst_</a> = typename <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa4d07e6853705c0c77730625effda54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait.The AddConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">More...</a><br /></td></tr>
<tr class="separator:gaa4d07e6853705c0c77730625effda54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga929fa7c8723465e3db2d609625ca92cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">blaze::AddCV_</a> = typename <a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga929fa7c8723465e3db2d609625ca92cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait.The AddCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">More...</a><br /></td></tr>
<tr class="separator:ga929fa7c8723465e3db2d609625ca92cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">blaze::AddPointer_</a> = typename <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gad44dfb9fe9000add409150fa4b7e9d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait.The AddPointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">More...</a><br /></td></tr>
<tr class="separator:gad44dfb9fe9000add409150fa4b7e9d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">blaze::AddReference_</a> = typename <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait.The AddReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">More...</a><br /></td></tr>
<tr class="separator:ga1c3a003331b1147d9cb4991a46b9ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">blaze::AddVolatile_</a> = typename <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait.The AddVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">More...</a><br /></td></tr>
<tr class="separator:ga6a8cbfccf4f9d689a42e5d670499911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">blaze::CommonType_</a> = typename <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a>&lt; T... &gt;::Type</td></tr>
<tr class="memdesc:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait.The CommonType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">More...</a><br /></td></tr>
<tr class="separator:ga08c7cd3125c6a710a8e69ca26f4ea5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">blaze::Decay_</a> = typename <a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> type trait.The Decay_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">More...</a><br /></td></tr>
<tr class="separator:ga1dc48f717dd98041ce6ebfb5a3642541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a76caf184ea9b940528ac368da1b577"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">blaze::MakeSigned_</a> = typename <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga4a76caf184ea9b940528ac368da1b577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> type trait.The MakeSigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">More...</a><br /></td></tr>
<tr class="separator:ga4a76caf184ea9b940528ac368da1b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7d8cacb214951110d862d4183532c7d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">blaze::MakeUnsigned_</a> = typename <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga7d8cacb214951110d862d4183532c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> type trait.The MakeUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">More...</a><br /></td></tr>
<tr class="separator:ga7d8cacb214951110d862d4183532c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">blaze::RemoveAllExtents_</a> = typename <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga0c53798803a90d594d0ef14e1481f1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait.The RemoveAllExtents_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">More...</a><br /></td></tr>
<tr class="separator:ga0c53798803a90d594d0ef14e1481f1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">blaze::RemoveConst_</a> = typename <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:ga13fccfb14d335ce408ceab9457bf4df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait.The RemoveConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">More...</a><br /></td></tr>
<tr class="separator:ga13fccfb14d335ce408ceab9457bf4df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf21820cc9ce037667f76051caf920c2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">blaze::RemoveCV_</a> = typename <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaf21820cc9ce037667f76051caf920c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait.The RemoveCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">More...</a><br /></td></tr>
<tr class="separator:gaf21820cc9ce037667f76051caf920c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">blaze::RemoveExtent_</a> = typename <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait.The RemoveExtent_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">More...</a><br /></td></tr>
<tr class="separator:gacfbcd0119d3bddd693ffdb292c6e1a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac6e489fdde969ad7931b740b73da1a97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">blaze::RemovePointer_</a> = typename <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gac6e489fdde969ad7931b740b73da1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait.The RemovePointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">More...</a><br /></td></tr>
<tr class="separator:gac6e489fdde969ad7931b740b73da1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">blaze::RemoveReference_</a> = typename <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait.The RemoveReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">More...</a><br /></td></tr>
<tr class="separator:gaa0beac6880fd0f492a1166e1c254e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada49326a8f411400855a3b6e376ab62d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">blaze::RemoveVolatile_</a> = typename <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a>&lt; T &gt;::Type</td></tr>
<tr class="memdesc:gada49326a8f411400855a3b6e376ab62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait.The RemoveVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">More...</a><br /></td></tr>
<tr class="separator:gada49326a8f411400855a3b6e376ab62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa20e1ead2af9ccd19e3921e871e36b8"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa20e1ead2af9ccd19e3921e871e36b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html#gaaa20e1ead2af9ccd19e3921e871e36b8">blaze::Void_</a> = void</td></tr>
<tr class="memdesc:gaaa20e1ead2af9ccd19e3921e871e36b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This type trait maps an arbitrary sequence of types to the type <code>void</code>. It can for instance be used to determine the validity of an expression:  <a href="../../de/d5a/group__type__traits.html#gaaa20e1ead2af9ccd19e3921e871e36b8">More...</a><br /></td></tr>
<tr class="separator:gaaa20e1ead2af9ccd19e3921e871e36b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa4d07e6853705c0c77730625effda54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d07e6853705c0c77730625effda54f">&#9670;&nbsp;</a></span>AddConst_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa4d07e6853705c0c77730625effda54f">blaze::AddConst_</a> = typedef typename <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">AddConst</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait.The AddConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddConst&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddConst_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga929fa7c8723465e3db2d609625ca92cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929fa7c8723465e3db2d609625ca92cb">&#9670;&nbsp;</a></span>AddCV_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga929fa7c8723465e3db2d609625ca92cb">blaze::AddCV_</a> = typedef typename <a class="el" href="../../df/d58/structblaze_1_1AddCV.html">AddCV</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait.The AddCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddCV&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddCV_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gad44dfb9fe9000add409150fa4b7e9d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad44dfb9fe9000add409150fa4b7e9d63">&#9670;&nbsp;</a></span>AddPointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gad44dfb9fe9000add409150fa4b7e9d63">blaze::AddPointer_</a> = typedef typename <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">AddPointer</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait.The AddPointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddPointer&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddPointer_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1c3a003331b1147d9cb4991a46b9ea37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3a003331b1147d9cb4991a46b9ea37">&#9670;&nbsp;</a></span>AddReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1c3a003331b1147d9cb4991a46b9ea37">blaze::AddReference_</a> = typedef typename <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">AddReference</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait.The AddReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddReference&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddReference_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6a8cbfccf4f9d689a42e5d670499911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8cbfccf4f9d689a42e5d670499911f">&#9670;&nbsp;</a></span>AddVolatile_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga6a8cbfccf4f9d689a42e5d670499911f">blaze::AddVolatile_</a> = typedef typename <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">AddVolatile</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait.The AddVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> AddVolatile&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = AddVolatile_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08c7cd3125c6a710a8e69ca26f4ea5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c7cd3125c6a710a8e69ca26f4ea5b9">&#9670;&nbsp;</a></span>CommonType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga08c7cd3125c6a710a8e69ca26f4ea5b9">blaze::CommonType_</a> = typedef typename <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html">CommonType</a>&lt;T...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> type trait.The CommonType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/d1c/structblaze_1_1CommonType.html" title="Deduction of a type common to several types.The CommonType type trait deduces the result type of a mi...">CommonType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> CommonType&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = CommonType_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1dc48f717dd98041ce6ebfb5a3642541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dc48f717dd98041ce6ebfb5a3642541">&#9670;&nbsp;</a></span>Decay_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1dc48f717dd98041ce6ebfb5a3642541">blaze::Decay_</a> = typedef typename <a class="el" href="../../df/dbe/structblaze_1_1Decay.html">Decay</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> type trait.The Decay_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/dbe/structblaze_1_1Decay.html" title="Applies the type conversions for by-value function arguments.This type trait applies the type convers...">Decay</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> Decay&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = Decay_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3b380783804d78aa5b21e51415cc3564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b380783804d78aa5b21e51415cc3564">&#9670;&nbsp;</a></span>HighType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga3b380783804d78aa5b21e51415cc3564">blaze::HighType_</a> = typedef typename <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html">HighType</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> type trait.The HighType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dc/d1e/structblaze_1_1HighType.html" title="Base template for the HighType type trait. ">HighType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> HighType&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = HighType_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5a3fa9d03c150105c91bf86867ae6777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3fa9d03c150105c91bf86867ae6777">&#9670;&nbsp;</a></span>LowType_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga5a3fa9d03c150105c91bf86867ae6777">blaze::LowType_</a> = typedef typename <a class="el" href="../../d5/d00/structblaze_1_1LowType.html">LowType</a>&lt;T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> type trait.The LowType_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d00/structblaze_1_1LowType.html" title="Base template for the LowType type trait. ">LowType</a> class template. For instance, given the types <em>T1</em> and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> LowType&lt;T1,T2&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = LowType_&lt;T1,T2&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4a76caf184ea9b940528ac368da1b577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a76caf184ea9b940528ac368da1b577">&#9670;&nbsp;</a></span>MakeSigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga4a76caf184ea9b940528ac368da1b577">blaze::MakeSigned_</a> = typedef typename <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">MakeSigned</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> type trait.The MakeSigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html" title="Compile time type conversion into a signed integral type.This type trait provides the feature to conv...">MakeSigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MakeSigned&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MakeSigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7d8cacb214951110d862d4183532c7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8cacb214951110d862d4183532c7d7">&#9670;&nbsp;</a></span>MakeUnsigned_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga7d8cacb214951110d862d4183532c7d7">blaze::MakeUnsigned_</a> = typedef typename <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">MakeUnsigned</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> type trait.The MakeUnsigned_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html" title="Compile time type conversion into an unsigned integral type.This type trait provides the feature to c...">MakeUnsigned</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> MakeUnsigned&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = MakeUnsigned_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1054a603bf1d73c443e374227954a9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1054a603bf1d73c443e374227954a9b5">&#9670;&nbsp;</a></span>RemoveAdaptor_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga1054a603bf1d73c443e374227954a9b5">blaze::RemoveAdaptor_</a> = typedef typename <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">RemoveAdaptor</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait.The RemoveAdaptor_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveAdaptor&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveAdaptor_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0c53798803a90d594d0ef14e1481f1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c53798803a90d594d0ef14e1481f1aa">&#9670;&nbsp;</a></span>RemoveAllExtents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga0c53798803a90d594d0ef14e1481f1aa">blaze::RemoveAllExtents_</a> = typedef typename <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">RemoveAllExtents</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait.The RemoveAllExtents_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveAllExtents&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveAllExtents_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga13fccfb14d335ce408ceab9457bf4df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fccfb14d335ce408ceab9457bf4df0">&#9670;&nbsp;</a></span>RemoveConst_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">blaze::RemoveConst_</a> = typedef typename <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait.The RemoveConst_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveConst&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveConst_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf21820cc9ce037667f76051caf920c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21820cc9ce037667f76051caf920c2e">&#9670;&nbsp;</a></span>RemoveCV_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaf21820cc9ce037667f76051caf920c2e">blaze::RemoveCV_</a> = typedef typename <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait.The RemoveCV_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveCV&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveCV_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gacfbcd0119d3bddd693ffdb292c6e1a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbcd0119d3bddd693ffdb292c6e1a3a">&#9670;&nbsp;</a></span>RemoveExtent_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gacfbcd0119d3bddd693ffdb292c6e1a3a">blaze::RemoveExtent_</a> = typedef typename <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">RemoveExtent</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait.The RemoveExtent_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveExtent&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveExtent_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gac6e489fdde969ad7931b740b73da1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e489fdde969ad7931b740b73da1a97">&#9670;&nbsp;</a></span>RemovePointer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gac6e489fdde969ad7931b740b73da1a97">blaze::RemovePointer_</a> = typedef typename <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> type trait.The RemovePointer_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html" title="Removal of pointer modifiers.The RemovePointer type trait removes any pointer modifiers from the give...">RemovePointer</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemovePointer&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemovePointer_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa0beac6880fd0f492a1166e1c254e4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0beac6880fd0f492a1166e1c254e4cb">&#9670;&nbsp;</a></span>RemoveReference_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa0beac6880fd0f492a1166e1c254e4cb">blaze::RemoveReference_</a> = typedef typename <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> type trait.The RemoveReference_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html" title="Removal of reference modifiers.The RemoveReference type trait removes any reference modifiers from th...">RemoveReference</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveReference&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveReference_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gada49326a8f411400855a3b6e376ab62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada49326a8f411400855a3b6e376ab62d">&#9670;&nbsp;</a></span>RemoveVolatile_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gada49326a8f411400855a3b6e376ab62d">blaze::RemoveVolatile_</a> = typedef typename <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait.The RemoveVolatile_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> RemoveVolatile&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = RemoveVolatile_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga21ed6b57b46e4eb4a400f581bca0f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21ed6b57b46e4eb4a400f581bca0f616">&#9670;&nbsp;</a></span>UnderlyingBuiltin_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga21ed6b57b46e4eb4a400f581bca0f616">blaze::UnderlyingBuiltin_</a> = typedef typename <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">UnderlyingBuiltin</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> type trait.The UnderlyingBuiltin_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html" title="Evaluation of the underlying builtin element type of a given data type.Via this type trait it is poss...">UnderlyingBuiltin</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingBuiltin&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingBuiltin_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa1d099d4d07f45ddddd62de3908b3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d099d4d07f45ddddd62de3908b3be2">&#9670;&nbsp;</a></span>UnderlyingElement_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaa1d099d4d07f45ddddd62de3908b3be2">blaze::UnderlyingElement_</a> = typedef typename <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">UnderlyingElement</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> type trait.The UnderlyingElement_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html" title="Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate th...">UnderlyingElement</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingElement&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingElement_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga11e3f75bd557307b815516615471dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e3f75bd557307b815516615471dc20">&#9670;&nbsp;</a></span>UnderlyingNumeric_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#ga11e3f75bd557307b815516615471dc20">blaze::UnderlyingNumeric_</a> = typedef typename <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">UnderlyingNumeric</a>&lt;T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> type trait.The UnderlyingNumeric_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html" title="Evaluation of the underlying numeric element type of a given data type.Via this type trait it is poss...">UnderlyingNumeric</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> UnderlyingNumeric&lt;T&gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = UnderlyingNumeric_&lt;T&gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaaa20e1ead2af9ccd19e3921e871e36b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa20e1ead2af9ccd19e3921e871e36b8">&#9670;&nbsp;</a></span>Void_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/d5a/group__type__traits.html#gaaa20e1ead2af9ccd19e3921e871e36b8">blaze::Void_</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time type check.This type trait maps an arbitrary sequence of types to the type <code>void</code>. It can for instance be used to determine the validity of an expression: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> = Vo<span class="keywordtype">id</span>_&lt;&gt; &gt;</div><div class="line"><span class="keyword">struct </span>HasAdd : <span class="keyword">public</span> <a class="code" href="../../d4/d3a/group__util.html#ga24e5b7b706f77970ca22837afa80d8ef">FalseType</a> {};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2</div><div class="line">        , Void_&lt; decltype( std::declval&lt;T1&gt;() + std::declval&lt;T2&gt;() ) &gt;</div><div class="line"><span class="keyword">struct</span> HasAdd : <span class="keyword">public</span> <a class="code" href="../../d4/d3a/group__util.html#ga051a0e2cd81c0befe93b4fa1c0e29573">TrueType</a> {};</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:25 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
