<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dense Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Dense Vectors<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d5/d32/group__custom__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d32/group__custom__vector.html">CustomVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/da3/group__dynamic__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html">DynamicVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/dc9/group__hybrid__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html">HybridVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d95/group__static__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html">StaticVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d95/group__dense__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d95/group__dense__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional dense vectors.The <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html" title="Base class for N-dimensional dense vectors.The DenseVector class is a base class for all arbitrarily ...">DenseVector</a> class is a base class for all arbitrarily sized (N-dimensional) dense vectors. It provides an abstraction from the actual type of the dense vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d1/db2/structblaze_1_1DenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga27161a1cc9b8c6a9c05c321721ab07f0"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga27161a1cc9b8c6a9c05c321721ab07f0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga27161a1cc9b8c6a9c05c321721ab07f0">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga27161a1cc9b8c6a9c05c321721ab07f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga27161a1cc9b8c6a9c05c321721ab07f0">More...</a><br /></td></tr>
<tr class="separator:ga27161a1cc9b8c6a9c05c321721ab07f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0687296ef9a8887f1bfd63e0abdd52c8"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga0687296ef9a8887f1bfd63e0abdd52c8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0687296ef9a8887f1bfd63e0abdd52c8">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0687296ef9a8887f1bfd63e0abdd52c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga0687296ef9a8887f1bfd63e0abdd52c8">More...</a><br /></td></tr>
<tr class="separator:ga0687296ef9a8887f1bfd63e0abdd52c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208395a691efcbafe3eb6d71a780bd2f"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga208395a691efcbafe3eb6d71a780bd2f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga208395a691efcbafe3eb6d71a780bd2f">blaze::operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga208395a691efcbafe3eb6d71a780bd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga208395a691efcbafe3eb6d71a780bd2f">More...</a><br /></td></tr>
<tr class="separator:ga208395a691efcbafe3eb6d71a780bd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfe834a013060ca88438d596f805dd1"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gaadfe834a013060ca88438d596f805dd1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaadfe834a013060ca88438d596f805dd1">blaze::operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaadfe834a013060ca88438d596f805dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaadfe834a013060ca88438d596f805dd1">More...</a><br /></td></tr>
<tr class="separator:gaadfe834a013060ca88438d596f805dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1caf80ed364cf24ce29e3dc8e2962cc5"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1caf80ed364cf24ce29e3dc8e2962cc5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1caf80ed364cf24ce29e3dc8e2962cc5">blaze::cross</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1caf80ed364cf24ce29e3dc8e2962cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga1caf80ed364cf24ce29e3dc8e2962cc5">More...</a><br /></td></tr>
<tr class="separator:ga1caf80ed364cf24ce29e3dc8e2962cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11008683c78874da3555aeb9f0fd928e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga11008683c78874da3555aeb9f0fd928e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga11008683c78874da3555aeb9f0fd928e">blaze::operator/</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga11008683c78874da3555aeb9f0fd928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_100.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga11008683c78874da3555aeb9f0fd928e">More...</a><br /></td></tr>
<tr class="separator:ga11008683c78874da3555aeb9f0fd928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf2a03c078e6b32c5609d626ade0633"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0bf2a03c078e6b32c5609d626ade0633"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0bf2a03c078e6b32c5609d626ade0633">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0bf2a03c078e6b32c5609d626ade0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga0bf2a03c078e6b32c5609d626ade0633">More...</a><br /></td></tr>
<tr class="separator:ga0bf2a03c078e6b32c5609d626ade0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071fb4b27247d3de145f4e508fc0691e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga071fb4b27247d3de145f4e508fc0691e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga071fb4b27247d3de145f4e508fc0691e">blaze::map</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs, OP op)</td></tr>
<tr class="memdesc:ga071fb4b27247d3de145f4e508fc0691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given binary operation on each single element of the dense vectors <em>lhs</em> and <em>rhs</em>.  <a href="../../de/d90/group__dense__vector.html#ga071fb4b27247d3de145f4e508fc0691e">More...</a><br /></td></tr>
<tr class="separator:ga071fb4b27247d3de145f4e508fc0691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa9c4f445587601e8d37c1abfc5ad6a"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2aa9c4f445587601e8d37c1abfc5ad6a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2aa9c4f445587601e8d37c1abfc5ad6a">blaze::min</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2aa9c4f445587601e8d37c1abfc5ad6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the componentwise minimum of the dense vectors <em>lhs</em> and <em>rhs</em>.  <a href="../../de/d90/group__dense__vector.html#ga2aa9c4f445587601e8d37c1abfc5ad6a">More...</a><br /></td></tr>
<tr class="separator:ga2aa9c4f445587601e8d37c1abfc5ad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42224f960a02bd8ffd671728b40eeb45"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga42224f960a02bd8ffd671728b40eeb45"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga42224f960a02bd8ffd671728b40eeb45">blaze::max</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga42224f960a02bd8ffd671728b40eeb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the componentwise maximum of the dense vectors <em>lhs</em> and <em>rhs</em>.  <a href="../../de/d90/group__dense__vector.html#ga42224f960a02bd8ffd671728b40eeb45">More...</a><br /></td></tr>
<tr class="separator:ga42224f960a02bd8ffd671728b40eeb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115cd162a144fdec4adc5c0b169d3658"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga115cd162a144fdec4adc5c0b169d3658"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga115cd162a144fdec4adc5c0b169d3658">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga115cd162a144fdec4adc5c0b169d3658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga115cd162a144fdec4adc5c0b169d3658">More...</a><br /></td></tr>
<tr class="separator:ga115cd162a144fdec4adc5c0b169d3658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae507ea99d02574e604d2e021e04fef42"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gae507ea99d02574e604d2e021e04fef42"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae507ea99d02574e604d2e021e04fef42">blaze::operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae507ea99d02574e604d2e021e04fef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae507ea99d02574e604d2e021e04fef42">More...</a><br /></td></tr>
<tr class="separator:gae507ea99d02574e604d2e021e04fef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e35c9066d76b65e7e448af590cf5ce"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab5e35c9066d76b65e7e448af590cf5ce"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab5e35c9066d76b65e7e448af590cf5ce">blaze::eval</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab5e35c9066d76b65e7e448af590cf5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense vector expression <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gab5e35c9066d76b65e7e448af590cf5ce">More...</a><br /></td></tr>
<tr class="separator:gab5e35c9066d76b65e7e448af590cf5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d67fb22f7bf1b9d50bc6e04c7c653f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:gad3d67fb22f7bf1b9d50bc6e04c7c653f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad3d67fb22f7bf1b9d50bc6e04c7c653f">blaze::map</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, OP op)</td></tr>
<tr class="memdesc:gad3d67fb22f7bf1b9d50bc6e04c7c653f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gad3d67fb22f7bf1b9d50bc6e04c7c653f">More...</a><br /></td></tr>
<tr class="separator:gad3d67fb22f7bf1b9d50bc6e04c7c653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a08e08a2e4097d13a174cac203c2977"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga0a08e08a2e4097d13a174cac203c2977"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0a08e08a2e4097d13a174cac203c2977">blaze::forEach</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, OP op)</td></tr>
<tr class="memdesc:ga0a08e08a2e4097d13a174cac203c2977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0a08e08a2e4097d13a174cac203c2977">More...</a><br /></td></tr>
<tr class="separator:ga0a08e08a2e4097d13a174cac203c2977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc58047ba58281d6958d9024e6cc34f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabdc58047ba58281d6958d9024e6cc34f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabdc58047ba58281d6958d9024e6cc34f">blaze::abs</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gabdc58047ba58281d6958d9024e6cc34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gabdc58047ba58281d6958d9024e6cc34f">More...</a><br /></td></tr>
<tr class="separator:gabdc58047ba58281d6958d9024e6cc34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680e13a52e1270aa176cdf5185d770ad"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga680e13a52e1270aa176cdf5185d770ad"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga680e13a52e1270aa176cdf5185d770ad">blaze::floor</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga680e13a52e1270aa176cdf5185d770ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga680e13a52e1270aa176cdf5185d770ad">More...</a><br /></td></tr>
<tr class="separator:ga680e13a52e1270aa176cdf5185d770ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ad7dcc0bbe38f205906ed796bc90cd"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga10ad7dcc0bbe38f205906ed796bc90cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga10ad7dcc0bbe38f205906ed796bc90cd">blaze::ceil</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga10ad7dcc0bbe38f205906ed796bc90cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga10ad7dcc0bbe38f205906ed796bc90cd">More...</a><br /></td></tr>
<tr class="separator:ga10ad7dcc0bbe38f205906ed796bc90cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f328246326d9f3bfb01c67c3fcdd22"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga16f328246326d9f3bfb01c67c3fcdd22"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga16f328246326d9f3bfb01c67c3fcdd22">blaze::trunc</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga16f328246326d9f3bfb01c67c3fcdd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga16f328246326d9f3bfb01c67c3fcdd22">More...</a><br /></td></tr>
<tr class="separator:ga16f328246326d9f3bfb01c67c3fcdd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18628a06d7bb0020ba4f26ee24ad1480"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga18628a06d7bb0020ba4f26ee24ad1480"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga18628a06d7bb0020ba4f26ee24ad1480">blaze::round</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga18628a06d7bb0020ba4f26ee24ad1480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga18628a06d7bb0020ba4f26ee24ad1480">More...</a><br /></td></tr>
<tr class="separator:ga18628a06d7bb0020ba4f26ee24ad1480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3fefe6bdfcc3ff087ef6f2dd799977"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4c3fefe6bdfcc3ff087ef6f2dd799977"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4c3fefe6bdfcc3ff087ef6f2dd799977">blaze::conj</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4c3fefe6bdfcc3ff087ef6f2dd799977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the complex conjugate of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4c3fefe6bdfcc3ff087ef6f2dd799977">More...</a><br /></td></tr>
<tr class="separator:ga4c3fefe6bdfcc3ff087ef6f2dd799977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7361b5b338fe1d2f4afab6251c6b94e4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7361b5b338fe1d2f4afab6251c6b94e4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7361b5b338fe1d2f4afab6251c6b94e4">blaze::ctrans</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7361b5b338fe1d2f4afab6251c6b94e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose vector of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga7361b5b338fe1d2f4afab6251c6b94e4">More...</a><br /></td></tr>
<tr class="separator:ga7361b5b338fe1d2f4afab6251c6b94e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc48c20791badb50cf3d0e0a281cc240"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gacc48c20791badb50cf3d0e0a281cc240"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacc48c20791badb50cf3d0e0a281cc240">blaze::real</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gacc48c20791badb50cf3d0e0a281cc240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the real part of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gacc48c20791badb50cf3d0e0a281cc240">More...</a><br /></td></tr>
<tr class="separator:gacc48c20791badb50cf3d0e0a281cc240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b6aa4b943b253397df7738d67091ed"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga93b6aa4b943b253397df7738d67091ed"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga93b6aa4b943b253397df7738d67091ed">blaze::imag</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga93b6aa4b943b253397df7738d67091ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the imaginary part of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga93b6aa4b943b253397df7738d67091ed">More...</a><br /></td></tr>
<tr class="separator:ga93b6aa4b943b253397df7738d67091ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697f296a2a23c9a49871925370710d6f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga697f296a2a23c9a49871925370710d6f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga697f296a2a23c9a49871925370710d6f">blaze::sqrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga697f296a2a23c9a49871925370710d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga697f296a2a23c9a49871925370710d6f">More...</a><br /></td></tr>
<tr class="separator:ga697f296a2a23c9a49871925370710d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6e334755b021905f814bdc28c6a339"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5f6e334755b021905f814bdc28c6a339"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5f6e334755b021905f814bdc28c6a339">blaze::invsqrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga5f6e334755b021905f814bdc28c6a339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga5f6e334755b021905f814bdc28c6a339">More...</a><br /></td></tr>
<tr class="separator:ga5f6e334755b021905f814bdc28c6a339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad081e998285b88d36889b0da2002e4b4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad081e998285b88d36889b0da2002e4b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad081e998285b88d36889b0da2002e4b4">blaze::cbrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad081e998285b88d36889b0da2002e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gad081e998285b88d36889b0da2002e4b4">More...</a><br /></td></tr>
<tr class="separator:gad081e998285b88d36889b0da2002e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b44f42b0764f0607deb9840f91c7b4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga62b44f42b0764f0607deb9840f91c7b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga62b44f42b0764f0607deb9840f91c7b4">blaze::invcbrt</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga62b44f42b0764f0607deb9840f91c7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga62b44f42b0764f0607deb9840f91c7b4">More...</a><br /></td></tr>
<tr class="separator:ga62b44f42b0764f0607deb9840f91c7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe293a97923f4eee6525ec4c8318fd16"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename DT &gt; </td></tr>
<tr class="memitem:gabe293a97923f4eee6525ec4c8318fd16"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabe293a97923f4eee6525ec4c8318fd16">blaze::clamp</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:gabe293a97923f4eee6525ec4c8318fd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the dense vector <em>dv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>.  <a href="../../de/d90/group__dense__vector.html#gabe293a97923f4eee6525ec4c8318fd16">More...</a><br /></td></tr>
<tr class="separator:gabe293a97923f4eee6525ec4c8318fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed4362b690cdcb6abd70d8302c7fcf8"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename ET &gt; </td></tr>
<tr class="memitem:gaeed4362b690cdcb6abd70d8302c7fcf8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeed4362b690cdcb6abd70d8302c7fcf8">blaze::pow</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv, ET <a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>)</td></tr>
<tr class="memdesc:gaeed4362b690cdcb6abd70d8302c7fcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaeed4362b690cdcb6abd70d8302c7fcf8">More...</a><br /></td></tr>
<tr class="separator:gaeed4362b690cdcb6abd70d8302c7fcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9261f67f98ce641408ff345a7f37e99b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga9261f67f98ce641408ff345a7f37e99b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9261f67f98ce641408ff345a7f37e99b">blaze::exp</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga9261f67f98ce641408ff345a7f37e99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga9261f67f98ce641408ff345a7f37e99b">More...</a><br /></td></tr>
<tr class="separator:ga9261f67f98ce641408ff345a7f37e99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47fd782e8e5f58adeece7a460c78da6b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga47fd782e8e5f58adeece7a460c78da6b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga47fd782e8e5f58adeece7a460c78da6b">blaze::exp2</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga47fd782e8e5f58adeece7a460c78da6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga47fd782e8e5f58adeece7a460c78da6b">More...</a><br /></td></tr>
<tr class="separator:ga47fd782e8e5f58adeece7a460c78da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf42083ce05a6a286de7fcf802cf52d0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gacf42083ce05a6a286de7fcf802cf52d0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacf42083ce05a6a286de7fcf802cf52d0">blaze::exp10</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gacf42083ce05a6a286de7fcf802cf52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gacf42083ce05a6a286de7fcf802cf52d0">More...</a><br /></td></tr>
<tr class="separator:gacf42083ce05a6a286de7fcf802cf52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d4d686190a0114a5e2fd10fab7d88ab"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga9d4d686190a0114a5e2fd10fab7d88ab"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9d4d686190a0114a5e2fd10fab7d88ab">blaze::log</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga9d4d686190a0114a5e2fd10fab7d88ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga9d4d686190a0114a5e2fd10fab7d88ab">More...</a><br /></td></tr>
<tr class="separator:ga9d4d686190a0114a5e2fd10fab7d88ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7952db16440bbe37095edc4112c3f236"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7952db16440bbe37095edc4112c3f236"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7952db16440bbe37095edc4112c3f236">blaze::log2</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7952db16440bbe37095edc4112c3f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga7952db16440bbe37095edc4112c3f236">More...</a><br /></td></tr>
<tr class="separator:ga7952db16440bbe37095edc4112c3f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6362ed40fafc5d4bb140a0f2f157081c"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga6362ed40fafc5d4bb140a0f2f157081c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6362ed40fafc5d4bb140a0f2f157081c">blaze::log10</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga6362ed40fafc5d4bb140a0f2f157081c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga6362ed40fafc5d4bb140a0f2f157081c">More...</a><br /></td></tr>
<tr class="separator:ga6362ed40fafc5d4bb140a0f2f157081c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2191bcef341701eeddf91a461ca4df5"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa2191bcef341701eeddf91a461ca4df5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa2191bcef341701eeddf91a461ca4df5">blaze::sin</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaa2191bcef341701eeddf91a461ca4df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaa2191bcef341701eeddf91a461ca4df5">More...</a><br /></td></tr>
<tr class="separator:gaa2191bcef341701eeddf91a461ca4df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcba149c12a68f0612117b0ac5e9c94"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga3fcba149c12a68f0612117b0ac5e9c94"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga3fcba149c12a68f0612117b0ac5e9c94">blaze::asin</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga3fcba149c12a68f0612117b0ac5e9c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga3fcba149c12a68f0612117b0ac5e9c94">More...</a><br /></td></tr>
<tr class="separator:ga3fcba149c12a68f0612117b0ac5e9c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f32ef5064d0aad7f4b78aa49e8567e9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4f32ef5064d0aad7f4b78aa49e8567e9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4f32ef5064d0aad7f4b78aa49e8567e9">blaze::sinh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4f32ef5064d0aad7f4b78aa49e8567e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4f32ef5064d0aad7f4b78aa49e8567e9">More...</a><br /></td></tr>
<tr class="separator:ga4f32ef5064d0aad7f4b78aa49e8567e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf429193062fc4fe17f7dab1ecdd61bbc"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf429193062fc4fe17f7dab1ecdd61bbc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf429193062fc4fe17f7dab1ecdd61bbc">blaze::asinh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaf429193062fc4fe17f7dab1ecdd61bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaf429193062fc4fe17f7dab1ecdd61bbc">More...</a><br /></td></tr>
<tr class="separator:gaf429193062fc4fe17f7dab1ecdd61bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11877ae6e5b9759717ffd191d1a8a188"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga11877ae6e5b9759717ffd191d1a8a188"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga11877ae6e5b9759717ffd191d1a8a188">blaze::cos</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga11877ae6e5b9759717ffd191d1a8a188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga11877ae6e5b9759717ffd191d1a8a188">More...</a><br /></td></tr>
<tr class="separator:ga11877ae6e5b9759717ffd191d1a8a188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a32419517dd5f7d16ed46a1248e134"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf3a32419517dd5f7d16ed46a1248e134"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf3a32419517dd5f7d16ed46a1248e134">blaze::acos</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaf3a32419517dd5f7d16ed46a1248e134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaf3a32419517dd5f7d16ed46a1248e134">More...</a><br /></td></tr>
<tr class="separator:gaf3a32419517dd5f7d16ed46a1248e134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadec626855554d9d69236f72cdda3cee"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaadec626855554d9d69236f72cdda3cee"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaadec626855554d9d69236f72cdda3cee">blaze::cosh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaadec626855554d9d69236f72cdda3cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaadec626855554d9d69236f72cdda3cee">More...</a><br /></td></tr>
<tr class="separator:gaadec626855554d9d69236f72cdda3cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0925f356a0c635007bb541f76b57426d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0925f356a0c635007bb541f76b57426d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0925f356a0c635007bb541f76b57426d">blaze::acosh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0925f356a0c635007bb541f76b57426d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0925f356a0c635007bb541f76b57426d">More...</a><br /></td></tr>
<tr class="separator:ga0925f356a0c635007bb541f76b57426d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4021907ed10f49de2058afcfd9dd9ab5"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4021907ed10f49de2058afcfd9dd9ab5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4021907ed10f49de2058afcfd9dd9ab5">blaze::tan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4021907ed10f49de2058afcfd9dd9ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4021907ed10f49de2058afcfd9dd9ab5">More...</a><br /></td></tr>
<tr class="separator:ga4021907ed10f49de2058afcfd9dd9ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bfd034e3a66960279a81241cc5d811f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2bfd034e3a66960279a81241cc5d811f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2bfd034e3a66960279a81241cc5d811f">blaze::atan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga2bfd034e3a66960279a81241cc5d811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga2bfd034e3a66960279a81241cc5d811f">More...</a><br /></td></tr>
<tr class="separator:ga2bfd034e3a66960279a81241cc5d811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9d091fab9ceb63ce81a09db0eb6a6b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaec9d091fab9ceb63ce81a09db0eb6a6b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaec9d091fab9ceb63ce81a09db0eb6a6b">blaze::tanh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaec9d091fab9ceb63ce81a09db0eb6a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaec9d091fab9ceb63ce81a09db0eb6a6b">More...</a><br /></td></tr>
<tr class="separator:gaec9d091fab9ceb63ce81a09db0eb6a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4194f89da0a67e7f7e8cb21e445218ad"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4194f89da0a67e7f7e8cb21e445218ad"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4194f89da0a67e7f7e8cb21e445218ad">blaze::atanh</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4194f89da0a67e7f7e8cb21e445218ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga4194f89da0a67e7f7e8cb21e445218ad">More...</a><br /></td></tr>
<tr class="separator:ga4194f89da0a67e7f7e8cb21e445218ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f5c0f03e1ed5c8e16dae8cc40dbe97"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga89f5c0f03e1ed5c8e16dae8cc40dbe97"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga89f5c0f03e1ed5c8e16dae8cc40dbe97">blaze::erf</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga89f5c0f03e1ed5c8e16dae8cc40dbe97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga89f5c0f03e1ed5c8e16dae8cc40dbe97">More...</a><br /></td></tr>
<tr class="separator:ga89f5c0f03e1ed5c8e16dae8cc40dbe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae2d1a59b801fe6b662610ec24a669f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0ae2d1a59b801fe6b662610ec24a669f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0ae2d1a59b801fe6b662610ec24a669f">blaze::erfc</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0ae2d1a59b801fe6b662610ec24a669f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each single element of the dense vector <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0ae2d1a59b801fe6b662610ec24a669f">More...</a><br /></td></tr>
<tr class="separator:ga0ae2d1a59b801fe6b662610ec24a669f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6cc5088df35925de4fd78cadc5e48ac"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:gab6cc5088df35925de4fd78cadc5e48ac"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab6cc5088df35925de4fd78cadc5e48ac">blaze::operator/</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;vec, ST scalar)</td></tr>
<tr class="memdesc:gab6cc5088df35925de4fd78cadc5e48ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_105.png"/>).  <a href="../../de/d90/group__dense__vector.html#gab6cc5088df35925de4fd78cadc5e48ac">More...</a><br /></td></tr>
<tr class="separator:gab6cc5088df35925de4fd78cadc5e48ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5f32ec9f86eb038229aac9140529f2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0f5f32ec9f86eb038229aac9140529f2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0f5f32ec9f86eb038229aac9140529f2">blaze::operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0f5f32ec9f86eb038229aac9140529f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_106.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga0f5f32ec9f86eb038229aac9140529f2">More...</a><br /></td></tr>
<tr class="separator:ga0f5f32ec9f86eb038229aac9140529f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017b2878ba2aade930496c5e6e4f3a5c"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga017b2878ba2aade930496c5e6e4f3a5c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga017b2878ba2aade930496c5e6e4f3a5c">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;vec, ST scalar)</td></tr>
<tr class="memdesc:ga017b2878ba2aade930496c5e6e4f3a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga017b2878ba2aade930496c5e6e4f3a5c">More...</a><br /></td></tr>
<tr class="separator:ga017b2878ba2aade930496c5e6e4f3a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a778b138abc24b6b5f3afa0c65fbba"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename VT , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga29a778b138abc24b6b5f3afa0c65fbba"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga29a778b138abc24b6b5f3afa0c65fbba">blaze::operator*</a> (ST scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga29a778b138abc24b6b5f3afa0c65fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_107.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga29a778b138abc24b6b5f3afa0c65fbba">More...</a><br /></td></tr>
<tr class="separator:ga29a778b138abc24b6b5f3afa0c65fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e342358dc10b3f6965a418f0086a64"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa6e342358dc10b3f6965a418f0086a64"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa6e342358dc10b3f6965a418f0086a64">blaze::serial</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaa6e342358dc10b3f6965a418f0086a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense vector expression <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gaa6e342358dc10b3f6965a418f0086a64">More...</a><br /></td></tr>
<tr class="separator:gaa6e342358dc10b3f6965a418f0086a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c59164680249cd2556f589445e626b7"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga9c59164680249cd2556f589445e626b7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9c59164680249cd2556f589445e626b7">blaze::operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9c59164680249cd2556f589445e626b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga9c59164680249cd2556f589445e626b7">More...</a><br /></td></tr>
<tr class="separator:ga9c59164680249cd2556f589445e626b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dae5ebdd7963e6e556fb37673dfbfb1"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1dae5ebdd7963e6e556fb37673dfbfb1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1dae5ebdd7963e6e556fb37673dfbfb1">blaze::operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1dae5ebdd7963e6e556fb37673dfbfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga1dae5ebdd7963e6e556fb37673dfbfb1">More...</a><br /></td></tr>
<tr class="separator:ga1dae5ebdd7963e6e556fb37673dfbfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d879b923191020ce9fb2b0c880ac13"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga63d879b923191020ce9fb2b0c880ac13"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga63d879b923191020ce9fb2b0c880ac13">blaze::operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga63d879b923191020ce9fb2b0c880ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga63d879b923191020ce9fb2b0c880ac13">More...</a><br /></td></tr>
<tr class="separator:ga63d879b923191020ce9fb2b0c880ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa53b35ab31d62b9db2fc6b95443bd396"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa53b35ab31d62b9db2fc6b95443bd396"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa53b35ab31d62b9db2fc6b95443bd396">blaze::cross</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa53b35ab31d62b9db2fc6b95443bd396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa53b35ab31d62b9db2fc6b95443bd396">More...</a><br /></td></tr>
<tr class="separator:gaa53b35ab31d62b9db2fc6b95443bd396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835618dd9c448948a57921276764a503"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga835618dd9c448948a57921276764a503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga835618dd9c448948a57921276764a503">blaze::operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga835618dd9c448948a57921276764a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga835618dd9c448948a57921276764a503">More...</a><br /></td></tr>
<tr class="separator:ga835618dd9c448948a57921276764a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fed08f423f855abab38ddf20b8368f9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0fed08f423f855abab38ddf20b8368f9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0fed08f423f855abab38ddf20b8368f9">blaze::trans</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0fed08f423f855abab38ddf20b8368f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense vector.  <a href="../../de/d90/group__dense__vector.html#ga0fed08f423f855abab38ddf20b8368f9">More...</a><br /></td></tr>
<tr class="separator:ga0fed08f423f855abab38ddf20b8368f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3e3929793f5867b7322cc85e03f5e8"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gafd3e3929793f5867b7322cc85e03f5e8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd3e3929793f5867b7322cc85e03f5e8">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gafd3e3929793f5867b7322cc85e03f5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#gafd3e3929793f5867b7322cc85e03f5e8">More...</a><br /></td></tr>
<tr class="separator:gafd3e3929793f5867b7322cc85e03f5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82d8ed7619a03daf7d333c1456f94e5"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gae82d8ed7619a03daf7d333c1456f94e5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae82d8ed7619a03daf7d333c1456f94e5">blaze::operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae82d8ed7619a03daf7d333c1456f94e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae82d8ed7619a03daf7d333c1456f94e5">More...</a><br /></td></tr>
<tr class="separator:gae82d8ed7619a03daf7d333c1456f94e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55391a41cd8be61ed525232c46f50eff"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga55391a41cd8be61ed525232c46f50eff"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga55391a41cd8be61ed525232c46f50eff">blaze::cross</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga55391a41cd8be61ed525232c46f50eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga55391a41cd8be61ed525232c46f50eff">More...</a><br /></td></tr>
<tr class="separator:ga55391a41cd8be61ed525232c46f50eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace93fe6cd684ff18298afae747b71487"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gace93fe6cd684ff18298afae747b71487"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gace93fe6cd684ff18298afae747b71487">blaze::operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gace93fe6cd684ff18298afae747b71487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>).  <a href="../../de/d90/group__dense__vector.html#gace93fe6cd684ff18298afae747b71487">More...</a><br /></td></tr>
<tr class="separator:gace93fe6cd684ff18298afae747b71487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf99ae95b75a76c1214949c3529a277"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gacdf99ae95b75a76c1214949c3529a277"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacdf99ae95b75a76c1214949c3529a277">blaze::operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacdf99ae95b75a76c1214949c3529a277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#gacdf99ae95b75a76c1214949c3529a277">More...</a><br /></td></tr>
<tr class="separator:gacdf99ae95b75a76c1214949c3529a277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa206897dbf0a72f1401e2ea7da469439"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa206897dbf0a72f1401e2ea7da469439"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa206897dbf0a72f1401e2ea7da469439">blaze::cross</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa206897dbf0a72f1401e2ea7da469439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa206897dbf0a72f1401e2ea7da469439">More...</a><br /></td></tr>
<tr class="separator:gaa206897dbf0a72f1401e2ea7da469439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829fbb33d296ae9a5077e2f9d994402f"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga829fbb33d296ae9a5077e2f9d994402f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga829fbb33d296ae9a5077e2f9d994402f">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga829fbb33d296ae9a5077e2f9d994402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga829fbb33d296ae9a5077e2f9d994402f">More...</a><br /></td></tr>
<tr class="separator:ga829fbb33d296ae9a5077e2f9d994402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185bc319df1dfc711b9b361076f3ceed"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga185bc319df1dfc711b9b361076f3ceed"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga185bc319df1dfc711b9b361076f3ceed">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga185bc319df1dfc711b9b361076f3ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga185bc319df1dfc711b9b361076f3ceed">More...</a><br /></td></tr>
<tr class="separator:ga185bc319df1dfc711b9b361076f3ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79c2c26a0f55617ffc959dd9d4330ad"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:gaf79c2c26a0f55617ffc959dd9d4330ad"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf79c2c26a0f55617ffc959dd9d4330ad">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaf79c2c26a0f55617ffc959dd9d4330ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaf79c2c26a0f55617ffc959dd9d4330ad">More...</a><br /></td></tr>
<tr class="separator:gaf79c2c26a0f55617ffc959dd9d4330ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1625137795ad373bf4f011df946cc580"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga1625137795ad373bf4f011df946cc580"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1625137795ad373bf4f011df946cc580">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga1625137795ad373bf4f011df946cc580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga1625137795ad373bf4f011df946cc580">More...</a><br /></td></tr>
<tr class="separator:ga1625137795ad373bf4f011df946cc580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff577a9f6c1a805da24388977579608"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga4ff577a9f6c1a805da24388977579608"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4ff577a9f6c1a805da24388977579608">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga4ff577a9f6c1a805da24388977579608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga4ff577a9f6c1a805da24388977579608">More...</a><br /></td></tr>
<tr class="separator:ga4ff577a9f6c1a805da24388977579608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46c7c9a2a7a9d8ad600ab8027eeae7d"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:gab46c7c9a2a7a9d8ad600ab8027eeae7d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab46c7c9a2a7a9d8ad600ab8027eeae7d">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gab46c7c9a2a7a9d8ad600ab8027eeae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../de/d90/group__dense__vector.html#gab46c7c9a2a7a9d8ad600ab8027eeae7d">More...</a><br /></td></tr>
<tr class="separator:gab46c7c9a2a7a9d8ad600ab8027eeae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab71c44fc69da24aa7302f79fe8e94c94">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::assign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gab71c44fc69da24aa7302f79fe8e94c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#gab71c44fc69da24aa7302f79fe8e94c94">More...</a><br /></td></tr>
<tr class="separator:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeddb101c9648191274078dd4cd1ec782"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaeddb101c9648191274078dd4cd1ec782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeddb101c9648191274078dd4cd1ec782">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::assign</a> (<a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaeddb101c9648191274078dd4cd1ec782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#gaeddb101c9648191274078dd4cd1ec782">More...</a><br /></td></tr>
<tr class="separator:gaeddb101c9648191274078dd4cd1ec782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab5cbae5a2188a3a84d0585371e6110c1">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::addAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gab5cbae5a2188a3a84d0585371e6110c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#gab5cbae5a2188a3a84d0585371e6110c1">More...</a><br /></td></tr>
<tr class="separator:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa9737bc07f38a7e9144dc3fcb1c7114b">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::subAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gaa9737bc07f38a7e9144dc3fcb1c7114b">More...</a><br /></td></tr>
<tr class="separator:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e3422dd6679538dce1a983ad6f0682"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga24e3422dd6679538dce1a983ad6f0682"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga24e3422dd6679538dce1a983ad6f0682">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::multAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga24e3422dd6679538dce1a983ad6f0682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga24e3422dd6679538dce1a983ad6f0682">More...</a><br /></td></tr>
<tr class="separator:ga24e3422dd6679538dce1a983ad6f0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca09893f30865f9104e832111558e7e4"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaca09893f30865f9104e832111558e7e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaca09893f30865f9104e832111558e7e4">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::divAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaca09893f30865f9104e832111558e7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#gaca09893f30865f9104e832111558e7e4">More...</a><br /></td></tr>
<tr class="separator:gaca09893f30865f9104e832111558e7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc4b8f1172c5f7af3642d841ebe28b4"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga0dc4b8f1172c5f7af3642d841ebe28b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0dc4b8f1172c5f7af3642d841ebe28b4">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga0dc4b8f1172c5f7af3642d841ebe28b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#ga0dc4b8f1172c5f7af3642d841ebe28b4">More...</a><br /></td></tr>
<tr class="separator:ga0dc4b8f1172c5f7af3642d841ebe28b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e21bad3f571a989058871da4efaabce"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga9e21bad3f571a989058871da4efaabce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9e21bad3f571a989058871da4efaabce">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (<a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga9e21bad3f571a989058871da4efaabce"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#ga9e21bad3f571a989058871da4efaabce">More...</a><br /></td></tr>
<tr class="separator:ga9e21bad3f571a989058871da4efaabce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9186c328c4bb6dd6c90434e86ec5824"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae9186c328c4bb6dd6c90434e86ec5824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae9186c328c4bb6dd6c90434e86ec5824">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gae9186c328c4bb6dd6c90434e86ec5824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#gae9186c328c4bb6dd6c90434e86ec5824">More...</a><br /></td></tr>
<tr class="separator:gae9186c328c4bb6dd6c90434e86ec5824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5849ff9ff33e33f36971b0c887791a56"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga5849ff9ff33e33f36971b0c887791a56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5849ff9ff33e33f36971b0c887791a56">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga5849ff9ff33e33f36971b0c887791a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#ga5849ff9ff33e33f36971b0c887791a56">More...</a><br /></td></tr>
<tr class="separator:ga5849ff9ff33e33f36971b0c887791a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5662f9969a4c507d60f79e130c39747f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga5662f9969a4c507d60f79e130c39747f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5662f9969a4c507d60f79e130c39747f">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga5662f9969a4c507d60f79e130c39747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga5662f9969a4c507d60f79e130c39747f">More...</a><br /></td></tr>
<tr class="separator:ga5662f9969a4c507d60f79e130c39747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bf73009c5282452107c53ee847c92b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga46bf73009c5282452107c53ee847c92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga46bf73009c5282452107c53ee847c92b">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpDivAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga46bf73009c5282452107c53ee847c92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP division assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#ga46bf73009c5282452107c53ee847c92b">More...</a><br /></td></tr>
<tr class="separator:ga46bf73009c5282452107c53ee847c92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72244c7b369d76d1c9664afe484a9ed"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gad72244c7b369d76d1c9664afe484a9ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad72244c7b369d76d1c9664afe484a9ed">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gad72244c7b369d76d1c9664afe484a9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#gad72244c7b369d76d1c9664afe484a9ed">More...</a><br /></td></tr>
<tr class="separator:gad72244c7b369d76d1c9664afe484a9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb205130dda7705f408e634c5c80c6a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaabb205130dda7705f408e634c5c80c6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaabb205130dda7705f408e634c5c80c6a">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (<a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaabb205130dda7705f408e634c5c80c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#gaabb205130dda7705f408e634c5c80c6a">More...</a><br /></td></tr>
<tr class="separator:gaabb205130dda7705f408e634c5c80c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00abf8dc090abf79e9ce6c04beb86817"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga00abf8dc090abf79e9ce6c04beb86817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga00abf8dc090abf79e9ce6c04beb86817">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::addAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga00abf8dc090abf79e9ce6c04beb86817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#ga00abf8dc090abf79e9ce6c04beb86817">More...</a><br /></td></tr>
<tr class="separator:ga00abf8dc090abf79e9ce6c04beb86817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138f16c06c6407c305d2c554888c433f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga138f16c06c6407c305d2c554888c433f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga138f16c06c6407c305d2c554888c433f">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::subAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga138f16c06c6407c305d2c554888c433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#ga138f16c06c6407c305d2c554888c433f">More...</a><br /></td></tr>
<tr class="separator:ga138f16c06c6407c305d2c554888c433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94cdd6ab1f7de4df522ed623623e1a0f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga94cdd6ab1f7de4df522ed623623e1a0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga94cdd6ab1f7de4df522ed623623e1a0f">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::multAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga94cdd6ab1f7de4df522ed623623e1a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga94cdd6ab1f7de4df522ed623623e1a0f">More...</a><br /></td></tr>
<tr class="separator:ga94cdd6ab1f7de4df522ed623623e1a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71c7176e552fcc091eba0e7b39a8292"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae71c7176e552fcc091eba0e7b39a8292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae71c7176e552fcc091eba0e7b39a8292">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::divAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gae71c7176e552fcc091eba0e7b39a8292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#gae71c7176e552fcc091eba0e7b39a8292">More...</a><br /></td></tr>
<tr class="separator:gae71c7176e552fcc091eba0e7b39a8292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659748286bb228596938d4cded403cc3"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga659748286bb228596938d4cded403cc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga659748286bb228596938d4cded403cc3">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga659748286bb228596938d4cded403cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#ga659748286bb228596938d4cded403cc3">More...</a><br /></td></tr>
<tr class="separator:ga659748286bb228596938d4cded403cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882f8f7dbb4de6177cd871f64583ef15"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga882f8f7dbb4de6177cd871f64583ef15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga882f8f7dbb4de6177cd871f64583ef15">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (<a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga882f8f7dbb4de6177cd871f64583ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="#ga882f8f7dbb4de6177cd871f64583ef15">More...</a><br /></td></tr>
<tr class="separator:ga882f8f7dbb4de6177cd871f64583ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19691bb7e527a70f35daf2ae2e94cb3b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga19691bb7e527a70f35daf2ae2e94cb3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga19691bb7e527a70f35daf2ae2e94cb3b">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga19691bb7e527a70f35daf2ae2e94cb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#ga19691bb7e527a70f35daf2ae2e94cb3b">More...</a><br /></td></tr>
<tr class="separator:ga19691bb7e527a70f35daf2ae2e94cb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb2ad9ebe0655067b81928da72ea995"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaabb2ad9ebe0655067b81928da72ea995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaabb2ad9ebe0655067b81928da72ea995">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaabb2ad9ebe0655067b81928da72ea995"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gaabb2ad9ebe0655067b81928da72ea995">More...</a><br /></td></tr>
<tr class="separator:gaabb2ad9ebe0655067b81928da72ea995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b3240725c2db5ec31a1fb9fb531f36"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga02b3240725c2db5ec31a1fb9fb531f36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga02b3240725c2db5ec31a1fb9fb531f36">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga02b3240725c2db5ec31a1fb9fb531f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga02b3240725c2db5ec31a1fb9fb531f36">More...</a><br /></td></tr>
<tr class="separator:ga02b3240725c2db5ec31a1fb9fb531f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42da80a447ebaae7f28f3595184b76fb"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga42da80a447ebaae7f28f3595184b76fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga42da80a447ebaae7f28f3595184b76fb">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpDivAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga42da80a447ebaae7f28f3595184b76fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP division assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#ga42da80a447ebaae7f28f3595184b76fb">More...</a><br /></td></tr>
<tr class="separator:ga42da80a447ebaae7f28f3595184b76fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6868cf3b70208eed023b4e722066815"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae6868cf3b70208eed023b4e722066815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae6868cf3b70208eed023b4e722066815">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::addAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gae6868cf3b70208eed023b4e722066815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#gae6868cf3b70208eed023b4e722066815">More...</a><br /></td></tr>
<tr class="separator:gae6868cf3b70208eed023b4e722066815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe8a27b763bf7716c313756494e54dd"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gabbe8a27b763bf7716c313756494e54dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabbe8a27b763bf7716c313756494e54dd">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::subAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gabbe8a27b763bf7716c313756494e54dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gabbe8a27b763bf7716c313756494e54dd">More...</a><br /></td></tr>
<tr class="separator:gabbe8a27b763bf7716c313756494e54dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050da3682f47907ce839ebaff145168a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga050da3682f47907ce839ebaff145168a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga050da3682f47907ce839ebaff145168a">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::multAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga050da3682f47907ce839ebaff145168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga050da3682f47907ce839ebaff145168a">More...</a><br /></td></tr>
<tr class="separator:ga050da3682f47907ce839ebaff145168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b04165df41c337ece158c82ee397a8"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae5b04165df41c337ece158c82ee397a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae5b04165df41c337ece158c82ee397a8">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::divAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gae5b04165df41c337ece158c82ee397a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#gae5b04165df41c337ece158c82ee397a8">More...</a><br /></td></tr>
<tr class="separator:gae5b04165df41c337ece158c82ee397a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7302d7652a69eb738cd2504971276ac9"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga7302d7652a69eb738cd2504971276ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7302d7652a69eb738cd2504971276ac9">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga7302d7652a69eb738cd2504971276ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#ga7302d7652a69eb738cd2504971276ac9">More...</a><br /></td></tr>
<tr class="separator:ga7302d7652a69eb738cd2504971276ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff38f26f8d2194baa6eb5f40d5a9266"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaeff38f26f8d2194baa6eb5f40d5a9266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeff38f26f8d2194baa6eb5f40d5a9266">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaeff38f26f8d2194baa6eb5f40d5a9266"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gaeff38f26f8d2194baa6eb5f40d5a9266">More...</a><br /></td></tr>
<tr class="separator:gaeff38f26f8d2194baa6eb5f40d5a9266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97aa7e2000632226a5b3680470c5b50"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaf97aa7e2000632226a5b3680470c5b50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf97aa7e2000632226a5b3680470c5b50">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaf97aa7e2000632226a5b3680470c5b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#gaf97aa7e2000632226a5b3680470c5b50">More...</a><br /></td></tr>
<tr class="separator:gaf97aa7e2000632226a5b3680470c5b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1429668e2d75410e1d3d47396a202c2a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga1429668e2d75410e1d3d47396a202c2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1429668e2d75410e1d3d47396a202c2a">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpDivAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga1429668e2d75410e1d3d47396a202c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP division assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#ga1429668e2d75410e1d3d47396a202c2a">More...</a><br /></td></tr>
<tr class="separator:ga1429668e2d75410e1d3d47396a202c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1e32a5b5d80262c47f37c5fd8eb327"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaac1e32a5b5d80262c47f37c5fd8eb327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaac1e32a5b5d80262c47f37c5fd8eb327">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::addAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaac1e32a5b5d80262c47f37c5fd8eb327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#gaac1e32a5b5d80262c47f37c5fd8eb327">More...</a><br /></td></tr>
<tr class="separator:gaac1e32a5b5d80262c47f37c5fd8eb327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeede90738638a13b0240c468f64d72ad"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaeede90738638a13b0240c468f64d72ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeede90738638a13b0240c468f64d72ad">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::subAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaeede90738638a13b0240c468f64d72ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gaeede90738638a13b0240c468f64d72ad">More...</a><br /></td></tr>
<tr class="separator:gaeede90738638a13b0240c468f64d72ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e64f1922566825fe78a71a80e01268"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga87e64f1922566825fe78a71a80e01268"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga87e64f1922566825fe78a71a80e01268">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::multAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga87e64f1922566825fe78a71a80e01268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga87e64f1922566825fe78a71a80e01268">More...</a><br /></td></tr>
<tr class="separator:ga87e64f1922566825fe78a71a80e01268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4758fbfc5c6006015d3770ba2ab2b2b5"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga4758fbfc5c6006015d3770ba2ab2b2b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4758fbfc5c6006015d3770ba2ab2b2b5">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::divAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga4758fbfc5c6006015d3770ba2ab2b2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#ga4758fbfc5c6006015d3770ba2ab2b2b5">More...</a><br /></td></tr>
<tr class="separator:ga4758fbfc5c6006015d3770ba2ab2b2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7516874729090bff712ed1bce981d4a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gac7516874729090bff712ed1bce981d4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac7516874729090bff712ed1bce981d4a">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gac7516874729090bff712ed1bce981d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>).  <a href="#gac7516874729090bff712ed1bce981d4a">More...</a><br /></td></tr>
<tr class="separator:gac7516874729090bff712ed1bce981d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe76f4ef790e48ed9bb5396f61c66f2"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaabe76f4ef790e48ed9bb5396f61c66f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaabe76f4ef790e48ed9bb5396f61c66f2">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaabe76f4ef790e48ed9bb5396f61c66f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>).  <a href="#gaabe76f4ef790e48ed9bb5396f61c66f2">More...</a><br /></td></tr>
<tr class="separator:gaabe76f4ef790e48ed9bb5396f61c66f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938528b52e5175a55f314f0e429f4e60"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga938528b52e5175a55f314f0e429f4e60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga938528b52e5175a55f314f0e429f4e60">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga938528b52e5175a55f314f0e429f4e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>).  <a href="#ga938528b52e5175a55f314f0e429f4e60">More...</a><br /></td></tr>
<tr class="separator:ga938528b52e5175a55f314f0e429f4e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69cd21d5ffefe99ea3217570718e513a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga69cd21d5ffefe99ea3217570718e513a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt; VT2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga69cd21d5ffefe99ea3217570718e513a">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpDivAssign</a> (<a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga69cd21d5ffefe99ea3217570718e513a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP division assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>).  <a href="#ga69cd21d5ffefe99ea3217570718e513a">More...</a><br /></td></tr>
<tr class="separator:ga69cd21d5ffefe99ea3217570718e513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector operators</h2></td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">blaze::operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">More...</a><br /></td></tr>
<tr class="separator:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">blaze::operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga521be975d8edae170b5f159468392be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">More...</a><br /></td></tr>
<tr class="separator:ga521be975d8edae170b5f159468392be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">blaze::operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">More...</a><br /></td></tr>
<tr class="separator:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga97dd82d4debad3d8fc7a11d39e345127">blaze::operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga97dd82d4debad3d8fc7a11d39e345127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#ga97dd82d4debad3d8fc7a11d39e345127">More...</a><br /></td></tr>
<tr class="separator:ga97dd82d4debad3d8fc7a11d39e345127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45da3a514747e0dd835d01393e1eb985"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga45da3a514747e0dd835d01393e1eb985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga45da3a514747e0dd835d01393e1eb985">blaze::operator==</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga45da3a514747e0dd835d01393e1eb985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga45da3a514747e0dd835d01393e1eb985">More...</a><br /></td></tr>
<tr class="separator:ga45da3a514747e0dd835d01393e1eb985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">blaze::operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">More...</a><br /></td></tr>
<tr class="separator:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">blaze::operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">More...</a><br /></td></tr>
<tr class="separator:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">blaze::operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabde27bb0ee7f998bef03dceca10cdce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">More...</a><br /></td></tr>
<tr class="separator:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa769a4a7de2e4ba9b853c401e75fdc8d">blaze::operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#gaa769a4a7de2e4ba9b853c401e75fdc8d">More...</a><br /></td></tr>
<tr class="separator:gaa769a4a7de2e4ba9b853c401e75fdc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga017746aadc85298a8c84e4e7f5e24bef">blaze::operator!=</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga017746aadc85298a8c84e4e7f5e24bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga017746aadc85298a8c84e4e7f5e24bef">More...</a><br /></td></tr>
<tr class="separator:ga017746aadc85298a8c84e4e7f5e24bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector functions</h2></td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaee69fc388ff36a0cd55c36b24e6556f6">blaze::isnan</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense vector for not-a-number elements.  <a href="../../de/d90/group__dense__vector.html#gaee69fc388ff36a0cd55c36b24e6556f6">More...</a><br /></td></tr>
<tr class="separator:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e50fe25442dd50eb27aea89797d65a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga65e50fe25442dd50eb27aea89797d65a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga65e50fe25442dd50eb27aea89797d65a">blaze::isDivisor</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga65e50fe25442dd50eb27aea89797d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dense vector is a valid divisor.  <a href="../../de/d90/group__dense__vector.html#ga65e50fe25442dd50eb27aea89797d65a">More...</a><br /></td></tr>
<tr class="separator:ga65e50fe25442dd50eb27aea89797d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga527e3c01fa1ccc42fae90bb95cc50082">blaze::isUniform</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense vector is a uniform vector.  <a href="../../de/d90/group__dense__vector.html#ga527e3c01fa1ccc42fae90bb95cc50082">More...</a><br /></td></tr>
<tr class="separator:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">blaze::sqrLength</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the square length (magnitude) of the dense vector <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_57.png"/>.  <a href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">More...</a><br /></td></tr>
<tr class="separator:ga51d40e92bb2867d6d6b04ebbafd86b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3585e479887969c9f815c0223fe5284f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga3585e479887969c9f815c0223fe5284f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f">blaze::length</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv) -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~dv)))</td></tr>
<tr class="memdesc:ga3585e479887969c9f815c0223fe5284f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the length (magnitude) of the dense vector <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_58.png"/>.  <a href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f">More...</a><br /></td></tr>
<tr class="separator:ga3585e479887969c9f815c0223fe5284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1525e1c59a3fd1e94e1777746600374"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad1525e1c59a3fd1e94e1777746600374"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad1525e1c59a3fd1e94e1777746600374">blaze::min</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gad1525e1c59a3fd1e94e1777746600374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#gad1525e1c59a3fd1e94e1777746600374">More...</a><br /></td></tr>
<tr class="separator:gad1525e1c59a3fd1e94e1777746600374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7cd8640cf6c00926b89f0ae974e20da2">blaze::max</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#ga7cd8640cf6c00926b89f0ae974e20da2">More...</a><br /></td></tr>
<tr class="separator:ga7cd8640cf6c00926b89f0ae974e20da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabdc58047ba58281d6958d9024e6cc34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc58047ba58281d6958d9024e6cc34f">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">abs</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf3a32419517dd5f7d16ed46a1248e134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a32419517dd5f7d16ed46a1248e134">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">acos</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga0925f356a0c635007bb541f76b57426d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0925f356a0c635007bb541f76b57426d">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">acosh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga3fcba149c12a68f0612117b0ac5e9c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fcba149c12a68f0612117b0ac5e9c94">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">asin</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaf429193062fc4fe17f7dab1ecdd61bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf429193062fc4fe17f7dab1ecdd61bbc">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">asinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2bfd034e3a66960279a81241cc5d811f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bfd034e3a66960279a81241cc5d811f">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">atan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4194f89da0a67e7f7e8cb21e445218ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4194f89da0a67e7f7e8cb21e445218ad">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">atanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad081e998285b88d36889b0da2002e4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad081e998285b88d36889b0da2002e4b4">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">cbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga10ad7dcc0bbe38f205906ed796bc90cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ad7dcc0bbe38f205906ed796bc90cd">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">ceil</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabe293a97923f4eee6525ec4c8318fd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe293a97923f4eee6525ec4c8318fd16">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the dense vector <em>dv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function restricts each element of the input vector <em>dv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">clamp</a>( a, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4c3fefe6bdfcc3ff087ef6f2dd799977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3fefe6bdfcc3ff087ef6f2dd799977">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the complex conjugate of each single element of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of each single element of <em>dv</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt; complex&lt;double&gt;</a> &gt; a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga11877ae6e5b9759717ffd191d1a8a188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11877ae6e5b9759717ffd191d1a8a188">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">cos</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaadec626855554d9d69236f72cdda3cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadec626855554d9d69236f72cdda3cee">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">cosh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1caf80ed364cf24ce29e3dc8e2962cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1caf80ed364cf24ce29e3dc8e2962cc5">&#9670;&nbsp;</a></span>cross() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the cross product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa206897dbf0a72f1401e2ea7da469439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa206897dbf0a72f1401e2ea7da469439">&#9670;&nbsp;</a></span>cross() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the cross product of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa53b35ab31d62b9db2fc6b95443bd396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa53b35ab31d62b9db2fc6b95443bd396">&#9670;&nbsp;</a></span>cross() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the cross product of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL );</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga55391a41cd8be61ed525232c46f50eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55391a41cd8be61ed525232c46f50eff">&#9670;&nbsp;</a></span>cross() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the cross product of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL );</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7361b5b338fe1d2f4afab6251c6b94e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7361b5b338fe1d2f4afab6251c6b94e4">&#9670;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose vector of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>dv</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input vector <em>dv</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt; complex&lt;double&gt;</a> &gt; a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( a );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga89f5c0f03e1ed5c8e16dae8cc40dbe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f5c0f03e1ed5c8e16dae8cc40dbe97">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">erf</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0ae2d1a59b801fe6b662610ec24a669f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae2d1a59b801fe6b662610ec24a669f">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">erfc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab5e35c9066d76b65e7e448af590cf5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e35c9066d76b65e7e448af590cf5ce">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given dense vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given dense vector expression <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">eval</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9261f67f98ce641408ff345a7f37e99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9261f67f98ce641408ff345a7f37e99b">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacf42083ce05a6a286de7fcf802cf52d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf42083ce05a6a286de7fcf802cf52d0">&#9670;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">exp10</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga47fd782e8e5f58adeece7a460c78da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47fd782e8e5f58adeece7a460c78da6b">&#9670;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">exp2</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga680e13a52e1270aa176cdf5185d770ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680e13a52e1270aa176cdf5185d770ad">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">floor</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0a08e08a2e4097d13a174cac203c2977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a08e08a2e4097d13a174cac203c2977">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">forEach</a>( a, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga93b6aa4b943b253397df7738d67091ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b6aa4b943b253397df7738d67091ed">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the imaginary part of each single element of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>dv</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga62b44f42b0764f0607deb9840f91c7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b44f42b0764f0607deb9840f91c7b4">&#9670;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">invcbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga5f6e334755b021905f814bdc28c6a339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6e334755b021905f814bdc28c6a339">&#9670;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">invsqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga65e50fe25442dd50eb27aea89797d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e50fe25442dd50eb27aea89797d65a">&#9670;&nbsp;</a></span>isDivisor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDivisor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given dense vector is a valid divisor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the given vector is a valid divisor, <em>false</em> otherwise.</dd></dl>
<p>This function checks if the given dense vector is a valid divisor. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all elements of the vector are valid divisors the function returns <em>true</em>, if at least one element of the vector is not a valid divisor, the function returns <em>false</em>.</p>
<div class="fragment"><div class="line">StaticVector&lt;int,3UL&gt; a{ 1, -1, 2 };  <span class="comment">// isDivisor( a ) returns true</span></div><div class="line">StaticVector&lt;int,3UL&gt; b{ 1, -1, 0 };  <span class="comment">// isDivisor( b ) returns false</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gaee69fc388ff36a0cd55c36b24e6556f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee69fc388ff36a0cd55c36b24e6556f6">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given dense vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional dense vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( a ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for vectors with floating point elements. The attempt to use it for a vector with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga527e3c01fa1ccc42fae90bb95cc50082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527e3c01fa1ccc42fae90bb95cc50082">&#9670;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense vector is a uniform vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the vector is a uniform vector, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense vector is a uniform vector. The vector is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,blaze::columnVector&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( a ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a vector expression results in a uniform vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( a + b ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary vector. </p>

</div>
</div>
<a id="ga3585e479887969c9f815c0223fe5284f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3585e479887969c9f815c0223fe5284f">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto blaze::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td> -&gt;  decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~dv)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the length (magnitude) of the dense vector <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_58.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (magnitude) of the dense vector.</dd></dl>
<p>This function calculates the actual length (magnitude) of the dense vector. The return type of the <a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f" title="Calculation of the length (magnitude) of the dense vector . ">length()</a> function depends on the actual element type of the vector instance:</p>
<table border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>Type</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
<tr>
<td>complex&lt;T&gt; </td><td>complex&lt;T&gt;  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32" title="Calculation of the square length (magnitude) of the dense vector . ">sqrLength()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="ga9d4d686190a0114a5e2fd10fab7d88ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d4d686190a0114a5e2fd10fab7d88ab">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes natural logarithm for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">log</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga6362ed40fafc5d4bb140a0f2f157081c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6362ed40fafc5d4bb140a0f2f157081c">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logarithm of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes common logarithm for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">log10</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga7952db16440bbe37095edc4112c3f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7952db16440bbe37095edc4112c3f236">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes binary logarithm for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">log2</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga071fb4b27247d3de145f4e508fc0691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071fb4b27247d3de145f4e508fc0691e">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given binary operation on each single element of the dense vectors <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector operand. </td></tr>
    <tr><td class="paramname">op</td><td>The custom, binary operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary operation applied to each single element of <em>lhs</em> and <em>rhs</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given binary operation on each element of the input vectors <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( a, b, []( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">std::min</a>( x, y ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad3d67fb22f7bf1b9d50bc6e04c7c653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d67fb22f7bf1b9d50bc6e04c7c653f">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given custom operation on each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( a, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7cd8640cf6c00926b89f0ae974e20da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd8640cf6c00926b89f0ae974e20da2">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest dense vector element.</dd></dl>
<p>This function returns the largest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga42224f960a02bd8ffd671728b40eeb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42224f960a02bd8ffd671728b40eeb45">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the componentwise maximum of the dense vectors <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function computes the componentwise maximum of the two dense vectors <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>( a, b );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad1525e1c59a3fd1e94e1777746600374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1525e1c59a3fd1e94e1777746600374">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest dense vector element.</dd></dl>
<p>This function returns the smallest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga2aa9c4f445587601e8d37c1abfc5ad6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aa9c4f445587601e8d37c1abfc5ad6a">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the componentwise minimum of the dense vectors <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function computes the componentwise minimum of the two dense vectors <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( a, b );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1d006cc08bc800f749d0cffb9ddbb9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d006cc08bc800f749d0cffb9ddbb9a7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gabde27bb0ee7f998bef03dceca10cdce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde27bb0ee7f998bef03dceca10cdce3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gaa769a4a7de2e4ba9b853c401e75fdc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa769a4a7de2e4ba9b853c401e75fdc8d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga017746aadc85298a8c84e4e7f5e24bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017746aadc85298a8c84e4e7f5e24bef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="gae82d8ed7619a03daf7d333c1456f94e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae82d8ed7619a03daf7d333c1456f94e5">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL );</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gacdf99ae95b75a76c1214949c3529a277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf99ae95b75a76c1214949c3529a277">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaadfe834a013060ca88438d596f805dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfe834a013060ca88438d596f805dd1">&#9670;&nbsp;</a></span>operator%() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga63d879b923191020ce9fb2b0c880ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d879b923191020ce9fb2b0c880ac13">&#9670;&nbsp;</a></span>operator%() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_98.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL );</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b( 3UL );</div><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a % b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0bf2a03c078e6b32c5609d626ade0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf2a03c078e6b32c5609d626ade0633">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line">blaze::double res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>(a) * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga829fbb33d296ae9a5077e2f9d994402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829fbb33d296ae9a5077e2f9d994402f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the dense matrix type <em>MT</em> and the dense vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga185bc319df1dfc711b9b361076f3ceed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185bc319df1dfc711b9b361076f3ceed">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the dense matrix type <em>MT</em> and the sparse vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gafd3e3929793f5867b7322cc85e03f5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3e3929793f5867b7322cc85e03f5e8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the sparse matrix type <em>MT</em> and the dense vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4ff577a9f6c1a805da24388977579608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ff577a9f6c1a805da24388977579608">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the sparse matrix type <em>MT</em> and the dense vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf79c2c26a0f55617ffc959dd9d4330ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79c2c26a0f55617ffc959dd9d4330ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the dense matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1625137795ad373bf4f011df946cc580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1625137795ad373bf4f011df946cc580">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the sparse matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab46c7c9a2a7a9d8ad600ab8027eeae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab46c7c9a2a7a9d8ad600ab8027eeae7d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the dense matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0687296ef9a8887f1bfd63e0abdd52c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0687296ef9a8887f1bfd63e0abdd52c8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the dense matrix type <em>MT</em> and the sparse vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga017b2878ba2aade930496c5e6e4f3a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017b2878ba2aade930496c5e6e4f3a5c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a dense vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a * 1.25;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>VT::ElementType</em> and <em>ST</em>. Both data types <em>VT::ElementType</em> and <em>ST</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga115cd162a144fdec4adc5c0b169d3658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115cd162a144fdec4adc5c0b169d3658">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>T1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga29a778b138abc24b6b5f3afa0c65fbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a778b138abc24b6b5f3afa0c65fbba">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST , typename VT , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = 1.25 * a;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>ST</em> and <em>VT::ElementType</em>. Both data types <em>ST</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga27161a1cc9b8c6a9c05c321721ab07f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27161a1cc9b8c6a9c05c321721ab07f0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the dense matrix type <em>MT</em> and the dense vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga9c59164680249cd2556f589445e626b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c59164680249cd2556f589445e626b7">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1dae5ebdd7963e6e556fb37673dfbfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dae5ebdd7963e6e556fb37673dfbfb1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga208395a691efcbafe3eb6d71a780bd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208395a691efcbafe3eb6d71a780bd2f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gace93fe6cd684ff18298afae747b71487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace93fe6cd684ff18298afae747b71487">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a - b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga835618dd9c448948a57921276764a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga835618dd9c448948a57921276764a503">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a - b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0f5f32ec9f86eb038229aac9140529f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5f32ec9f86eb038229aac9140529f2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_106.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = -a;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given dense vector. </p>

</div>
</div>
<a id="gae507ea99d02574e604d2e021e04fef42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae507ea99d02574e604d2e021e04fef42">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a - b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga11008683c78874da3555aeb9f0fd928e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11008683c78874da3555aeb9f0fd928e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotient of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component quotient of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a / b;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab6cc5088df35925de4fd78cadc5e48ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6cc5088df35925de4fd78cadc5e48ac">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_105.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a dense vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a / 0.24;</div></div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>VT::ElementType</em> and <em>ST</em>. Both data types <em>VT::ElementType</em> and <em>ST</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="ga7718438f21d78c1c5cd61e11b620f3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7718438f21d78c1c5cd61e11b620f3ac">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga521be975d8edae170b5f159468392be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga521be975d8edae170b5f159468392be7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga90afa4cbe670f292f01e0a8c0989bcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90afa4cbe670f292f01e0a8c0989bcb4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga97dd82d4debad3d8fc7a11d39e345127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97dd82d4debad3d8fc7a11d39e345127">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga45da3a514747e0dd835d01393e1eb985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45da3a514747e0dd835d01393e1eb985">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="gaeed4362b690cdcb6abd70d8302c7fcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed4362b690cdcb6abd70d8302c7fcf8">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">pow</a>( a, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacc48c20791badb50cf3d0e0a281cc240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc48c20791badb50cf3d0e0a281cc240">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the real part of each single element of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>dv</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga18628a06d7bb0020ba4f26ee24ad1480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18628a06d7bb0020ba4f26ee24ad1480">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">round</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa6e342358dc10b3f6965a418f0086a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6e342358dc10b3f6965a418f0086a64">&#9670;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given dense vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense vector.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given dense vector expression <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">serial</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa2191bcef341701eeddf91a461ca4df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2191bcef341701eeddf91a461ca4df5">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">sin</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4f32ef5064d0aad7f4b78aa49e8567e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f32ef5064d0aad7f4b78aa49e8567e9">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">sinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga51d40e92bb2867d6d6b04ebbafd86b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d40e92bb2867d6d6b04ebbafd86b32">&#9670;&nbsp;</a></span>sqrLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::sqrLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the square length (magnitude) of the dense vector <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_57.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square length (magnitude) of the dense vector.</dd></dl>
<p>This function calculates the actual square length (magnitude) of the dense vector.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32" title="Calculation of the square length (magnitude) of the dense vector . ">sqrLength()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="ga697f296a2a23c9a49871925370710d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697f296a2a23c9a49871925370710d6f">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga4021907ed10f49de2058afcfd9dd9ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4021907ed10f49de2058afcfd9dd9ab5">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">tan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaec9d091fab9ceb63ce81a09db0eb6a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9d091fab9ceb63ce81a09db0eb6a6b">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent for each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each single element of <em>dv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">tanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga0fed08f423f855abab38ddf20b8368f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fed08f423f855abab38ddf20b8368f9">&#9670;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the dense vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a>    b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga16f328246326d9f3bfb01c67c3fcdd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f328246326d9f3bfb01c67c3fcdd22">&#9670;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense vector <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">trunc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga00abf8dc090abf79e9ce6c04beb86817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00abf8dc090abf79e9ce6c04beb86817">&#9670;&nbsp;</a></span>addAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="gab5cbae5a2188a3a84d0585371e6110c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5cbae5a2188a3a84d0585371e6110c1">&#9670;&nbsp;</a></span>addAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="gaac1e32a5b5d80262c47f37c5fd8eb327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac1e32a5b5d80262c47f37c5fd8eb327">&#9670;&nbsp;</a></span>addAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a id="gae6868cf3b70208eed023b4e722066815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6868cf3b70208eed023b4e722066815">&#9670;&nbsp;</a></span>addAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="gab71c44fc69da24aa7302f79fe8e94c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71c44fc69da24aa7302f79fe8e94c94">&#9670;&nbsp;</a></span>assign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="gad72244c7b369d76d1c9664afe484a9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad72244c7b369d76d1c9664afe484a9ed">&#9670;&nbsp;</a></span>assign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="gaabb205130dda7705f408e634c5c80c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb205130dda7705f408e634c5c80c6a">&#9670;&nbsp;</a></span>assign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="gaeddb101c9648191274078dd4cd1ec782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeddb101c9648191274078dd4cd1ec782">&#9670;&nbsp;</a></span>assign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- sparse matrix multiplication expression to a sparse vector. </p>

</div>
</div>
<a id="gae71c7176e552fcc091eba0e7b39a8292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae71c7176e552fcc091eba0e7b39a8292">&#9670;&nbsp;</a></span>divAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; divAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized division assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="ga4758fbfc5c6006015d3770ba2ab2b2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4758fbfc5c6006015d3770ba2ab2b2b5">&#9670;&nbsp;</a></span>divAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; divAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized division assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a id="gaca09893f30865f9104e832111558e7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca09893f30865f9104e832111558e7e4">&#9670;&nbsp;</a></span>divAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void divAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized division assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="gae5b04165df41c337ece158c82ee397a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b04165df41c337ece158c82ee397a8">&#9670;&nbsp;</a></span>divAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void divAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized division assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="ga94cdd6ab1f7de4df522ed623623e1a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94cdd6ab1f7de4df522ed623623e1a0f">&#9670;&nbsp;</a></span>multAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="ga87e64f1922566825fe78a71a80e01268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e64f1922566825fe78a71a80e01268">&#9670;&nbsp;</a></span>multAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a id="ga24e3422dd6679538dce1a983ad6f0682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e3422dd6679538dce1a983ad6f0682">&#9670;&nbsp;</a></span>multAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="ga050da3682f47907ce839ebaff145168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050da3682f47907ce839ebaff145168a">&#9670;&nbsp;</a></span>multAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="ga19691bb7e527a70f35daf2ae2e94cb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19691bb7e527a70f35daf2ae2e94cb3b">&#9670;&nbsp;</a></span>smpAddAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gac7516874729090bff712ed1bce981d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7516874729090bff712ed1bce981d4a">&#9670;&nbsp;</a></span>smpAddAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gae9186c328c4bb6dd6c90434e86ec5824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9186c328c4bb6dd6c90434e86ec5824">&#9670;&nbsp;</a></span>smpAddAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga7302d7652a69eb738cd2504971276ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7302d7652a69eb738cd2504971276ac9">&#9670;&nbsp;</a></span>smpAddAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_112.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga659748286bb228596938d4cded403cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga659748286bb228596938d4cded403cc3">&#9670;&nbsp;</a></span>smpAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga882f8f7dbb4de6177cd871f64583ef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga882f8f7dbb4de6177cd871f64583ef15">&#9670;&nbsp;</a></span>smpAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga0dc4b8f1172c5f7af3642d841ebe28b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc4b8f1172c5f7af3642d841ebe28b4">&#9670;&nbsp;</a></span>smpAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga9e21bad3f571a989058871da4efaabce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e21bad3f571a989058871da4efaabce">&#9670;&nbsp;</a></span>smpAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga42da80a447ebaae7f28f3595184b76fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42da80a447ebaae7f28f3595184b76fb">&#9670;&nbsp;</a></span>smpDivAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpDivAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP division assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP division assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga69cd21d5ffefe99ea3217570718e513a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69cd21d5ffefe99ea3217570718e513a">&#9670;&nbsp;</a></span>smpDivAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpDivAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP division assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP division assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga46bf73009c5282452107c53ee847c92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46bf73009c5282452107c53ee847c92b">&#9670;&nbsp;</a></span>smpDivAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpDivAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP division assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP division assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga1429668e2d75410e1d3d47396a202c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1429668e2d75410e1d3d47396a202c2a">&#9670;&nbsp;</a></span>smpDivAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpDivAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP division assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T/=\vec{x}^T*A $" src="../../form_115.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP division assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga02b3240725c2db5ec31a1fb9fb531f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b3240725c2db5ec31a1fb9fb531f36">&#9670;&nbsp;</a></span>smpMultAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga938528b52e5175a55f314f0e429f4e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938528b52e5175a55f314f0e429f4e60">&#9670;&nbsp;</a></span>smpMultAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga5662f9969a4c507d60f79e130c39747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5662f9969a4c507d60f79e130c39747f">&#9670;&nbsp;</a></span>smpMultAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gaf97aa7e2000632226a5b3680470c5b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97aa7e2000632226a5b3680470c5b50">&#9670;&nbsp;</a></span>smpMultAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gaabb2ad9ebe0655067b81928da72ea995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb2ad9ebe0655067b81928da72ea995">&#9670;&nbsp;</a></span>smpSubAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gaabe76f4ef790e48ed9bb5396f61c66f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabe76f4ef790e48ed9bb5396f61c66f2">&#9670;&nbsp;</a></span>smpSubAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga5849ff9ff33e33f36971b0c887791a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5849ff9ff33e33f36971b0c887791a56">&#9670;&nbsp;</a></span>smpSubAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="gaeff38f26f8d2194baa6eb5f40d5a9266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff38f26f8d2194baa6eb5f40d5a9266">&#9670;&nbsp;</a></span>smpSubAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseSMPAssign&lt;VT2&gt; &gt; smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a id="ga138f16c06c6407c305d2c554888c433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138f16c06c6407c305d2c554888c433f">&#9670;&nbsp;</a></span>subAssign <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a id="gaeede90738638a13b0240c468f64d72ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeede90738638a13b0240c468f64d72ad">&#9670;&nbsp;</a></span>subAssign <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; UseAssign&lt;VT2&gt; &gt; subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a id="gaa9737bc07f38a7e9144dc3fcb1c7114b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9737bc07f38a7e9144dc3fcb1c7114b">&#9670;&nbsp;</a></span>subAssign <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a id="gabbe8a27b763bf7716c313756494e54dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbe8a27b763bf7716c313756494e54dd">&#9670;&nbsp;</a></span>subAssign <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
