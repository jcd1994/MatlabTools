<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::CustomMatrix&lt; Type, AF, PF, SO &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d1/d48/classblaze_1_1CustomMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::CustomMatrix&lt; Type, AF, PF, SO &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a> &raquo; <a class="el" href="../../db/df0/group__dense__matrix.html">Dense Matrices</a> &raquo; <a class="el" href="../../d2/d77/group__custom__matrix.html">CustomMatrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a customizable matrix.The <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> class template provides the functionality to represent an external array of elements of arbitrary type and a fixed size as a native <b>Blaze</b> dense matrix data structure. Thus in contrast to all other dense matrix types a custom matrix does not perform any kind of memory allocation by itself, but it is provided with an existing array of element during construction. A custom matrix can therefore be considered an alias to the existing array.  
 <a href="../../de/d43/classblaze_1_1CustomMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dd/d83/dense_2CustomMatrix_8h_source.html">CustomMatrix.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; CustomMatrix&lt; Type, AF, PF, SO &gt;, SO &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d19/structblaze_1_1CustomMatrix_1_1Rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d19/structblaze_1_1CustomMatrix_1_1Rebind.html" title="Rebind mechanism to obtain a CustomMatrix with different data/element type. ">Rebind</a> mechanism to obtain a <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> with different data/element type.  <a href="../../d5/d19/structblaze_1_1CustomMatrix_1_1Rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/ddd/structblaze_1_1CustomMatrix_1_1Resize.html">Resize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/ddd/structblaze_1_1CustomMatrix_1_1Resize.html" title="Resize mechanism to obtain a CustomMatrix with different fixed dimensions. ">Resize</a> mechanism to obtain a <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> with different fixed dimensions.  <a href="../../da/ddd/structblaze_1_1CustomMatrix_1_1Resize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aedda32d64e36bea6174372203dbc0a9c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>simdEnabled</b> = IsVectorizable&lt;Type&gt;::value
 }<tr class="memdesc:aedda32d64e36bea6174372203dbc0a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SIMD optimization.  <a href="../../de/d43/classblaze_1_1CustomMatrix.html#aedda32d64e36bea6174372203dbc0a9c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aedda32d64e36bea6174372203dbc0a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3863e32a4cbbcfea52af2f32fd01fc05"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = !IsSMPAssignable&lt;Type&gt;::value
 }<tr class="memdesc:a3863e32a4cbbcfea52af2f32fd01fc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../de/d43/classblaze_1_1CustomMatrix.html#a3863e32a4cbbcfea52af2f32fd01fc05">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3863e32a4cbbcfea52af2f32fd01fc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec5a745521171eedb5b1724b26093a8"><td class="memItemLeft" align="right" valign="top"><a id="aaec5a745521171eedb5b1724b26093a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aaec5a745521171eedb5b1724b26093a8">This</a> = <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;</td></tr>
<tr class="memdesc:aaec5a745521171eedb5b1724b26093a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> instance. <br /></td></tr>
<tr class="separator:aaec5a745521171eedb5b1724b26093a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18a6af78c9bfd1c977a83ea6bf4357"><td class="memItemLeft" align="right" valign="top"><a id="a3b18a6af78c9bfd1c977a83ea6bf4357"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3b18a6af78c9bfd1c977a83ea6bf4357">BaseType</a> = <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aaec5a745521171eedb5b1724b26093a8">This</a>, SO &gt;</td></tr>
<tr class="memdesc:a3b18a6af78c9bfd1c977a83ea6bf4357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of this <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> instance. <br /></td></tr>
<tr class="separator:a3b18a6af78c9bfd1c977a83ea6bf4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4529c734fc05b078a09e9c4346addade"><td class="memItemLeft" align="right" valign="top"><a id="a4529c734fc05b078a09e9c4346addade"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4529c734fc05b078a09e9c4346addade">ResultType</a> = <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a>&lt; Type &gt;, SO &gt;</td></tr>
<tr class="memdesc:a4529c734fc05b078a09e9c4346addade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a4529c734fc05b078a09e9c4346addade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279e021391c240f6c133c0726a93953c"><td class="memItemLeft" align="right" valign="top"><a id="a279e021391c240f6c133c0726a93953c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a279e021391c240f6c133c0726a93953c">OppositeType</a> = <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a>&lt; Type &gt;,!SO &gt;</td></tr>
<tr class="memdesc:a279e021391c240f6c133c0726a93953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:a279e021391c240f6c133c0726a93953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79d8fcceec0473ae49ce871a830a883"><td class="memItemLeft" align="right" valign="top"><a id="ab79d8fcceec0473ae49ce871a830a883"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ab79d8fcceec0473ae49ce871a830a883">TransposeType</a> = <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; <a class="el" href="../../de/d5a/group__type__traits.html#ga13fccfb14d335ce408ceab9457bf4df0">RemoveConst_</a>&lt; Type &gt;,!SO &gt;</td></tr>
<tr class="memdesc:ab79d8fcceec0473ae49ce871a830a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:ab79d8fcceec0473ae49ce871a830a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb74f23475180d3034aac42df8c91df"><td class="memItemLeft" align="right" valign="top"><a id="a4bb74f23475180d3034aac42df8c91df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4bb74f23475180d3034aac42df8c91df">ElementType</a> = Type</td></tr>
<tr class="memdesc:a4bb74f23475180d3034aac42df8c91df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix elements. <br /></td></tr>
<tr class="separator:a4bb74f23475180d3034aac42df8c91df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94730efe3f3ca8006f2d1db39afb9bac"><td class="memItemLeft" align="right" valign="top"><a id="a94730efe3f3ca8006f2d1db39afb9bac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> = <a class="el" href="../../dc/d7b/group__simd.html#ga0b575b0b82167488f51b14b02b664ba2">SIMDTrait_</a>&lt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4bb74f23475180d3034aac42df8c91df">ElementType</a> &gt;</td></tr>
<tr class="memdesc:a94730efe3f3ca8006f2d1db39afb9bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type of the matrix elements. <br /></td></tr>
<tr class="separator:a94730efe3f3ca8006f2d1db39afb9bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f97ad17fe59b9ac18bd69757858898"><td class="memItemLeft" align="right" valign="top"><a id="af5f97ad17fe59b9ac18bd69757858898"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af5f97ad17fe59b9ac18bd69757858898">ReturnType</a> = const Type &amp;</td></tr>
<tr class="memdesc:af5f97ad17fe59b9ac18bd69757858898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:af5f97ad17fe59b9ac18bd69757858898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cba4a89b37a10e8ca113c1e2683ca83"><td class="memItemLeft" align="right" valign="top"><a id="a5cba4a89b37a10e8ca113c1e2683ca83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a5cba4a89b37a10e8ca113c1e2683ca83">CompositeType</a> = const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aaec5a745521171eedb5b1724b26093a8">This</a> &amp;</td></tr>
<tr class="memdesc:a5cba4a89b37a10e8ca113c1e2683ca83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a5cba4a89b37a10e8ca113c1e2683ca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467759dafbc79fac063a425ffe6e636d"><td class="memItemLeft" align="right" valign="top"><a id="a467759dafbc79fac063a425ffe6e636d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a467759dafbc79fac063a425ffe6e636d">Reference</a> = Type &amp;</td></tr>
<tr class="memdesc:a467759dafbc79fac063a425ffe6e636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant matrix value. <br /></td></tr>
<tr class="separator:a467759dafbc79fac063a425ffe6e636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af06a455ecdaafd1f6ef1ddf0e45602"><td class="memItemLeft" align="right" valign="top"><a id="a8af06a455ecdaafd1f6ef1ddf0e45602"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8af06a455ecdaafd1f6ef1ddf0e45602">ConstReference</a> = const Type &amp;</td></tr>
<tr class="memdesc:a8af06a455ecdaafd1f6ef1ddf0e45602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant matrix value. <br /></td></tr>
<tr class="separator:a8af06a455ecdaafd1f6ef1ddf0e45602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b9cad82ee0f5834058cbf06e2799c"><td class="memItemLeft" align="right" valign="top"><a id="a8a0b9cad82ee0f5834058cbf06e2799c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8a0b9cad82ee0f5834058cbf06e2799c">Pointer</a> = Type *</td></tr>
<tr class="memdesc:a8a0b9cad82ee0f5834058cbf06e2799c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant matrix value. <br /></td></tr>
<tr class="separator:a8a0b9cad82ee0f5834058cbf06e2799c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb30385840da2c793558f84add94f5d"><td class="memItemLeft" align="right" valign="top"><a id="a3cb30385840da2c793558f84add94f5d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3cb30385840da2c793558f84add94f5d">ConstPointer</a> = const Type *</td></tr>
<tr class="memdesc:a3cb30385840da2c793558f84add94f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant matrix value. <br /></td></tr>
<tr class="separator:a3cb30385840da2c793558f84add94f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef7ced3ceb87c8b0bff0b851ec15067"><td class="memItemLeft" align="right" valign="top"><a id="afef7ced3ceb87c8b0bff0b851ec15067"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#afef7ced3ceb87c8b0bff0b851ec15067">Iterator</a> = <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type, AF &gt;</td></tr>
<tr class="memdesc:afef7ced3ceb87c8b0bff0b851ec15067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:afef7ced3ceb87c8b0bff0b851ec15067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5abf098a59d93e042c2632cb45f7ae"><td class="memItemLeft" align="right" valign="top"><a id="a7f5abf098a59d93e042c2632cb45f7ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a> = <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; const Type, AF &gt;</td></tr>
<tr class="memdesc:a7f5abf098a59d93e042c2632cb45f7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a7f5abf098a59d93e042c2632cb45f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853a0280da9279c350e964e661e0acd0"><td class="memItemLeft" align="right" valign="top"><a id="a853a0280da9279c350e964e661e0acd0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> = MT</td></tr>
<tr class="memdesc:a853a0280da9279c350e964e661e0acd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br /></td></tr>
<tr class="separator:a853a0280da9279c350e964e661e0acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a23bfa39d06bd0f66a1048a3557785fa6"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t M, size_t N&gt; </td></tr>
<tr class="memitem:a23bfa39d06bd0f66a1048a3557785fa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a23bfa39d06bd0f66a1048a3557785fa6">operator=</a> (const Other(&amp;array)[M][N])</td></tr>
<tr class="memdesc:a23bfa39d06bd0f66a1048a3557785fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array assignment to all matrix elements.  <a href="#a23bfa39d06bd0f66a1048a3557785fa6">More...</a><br /></td></tr>
<tr class="separator:a23bfa39d06bd0f66a1048a3557785fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a883334304710f5bc777b87d06a622d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a1a883334304710f5bc777b87d06a622d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a1a883334304710f5bc777b87d06a622d">operator=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1a883334304710f5bc777b87d06a622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different matrices.  <a href="#a1a883334304710f5bc777b87d06a622d">More...</a><br /></td></tr>
<tr class="separator:a1a883334304710f5bc777b87d06a622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9abeabd3ff2805ecb478ed2d9179db"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a0e9abeabd3ff2805ecb478ed2d9179db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a0e9abeabd3ff2805ecb478ed2d9179db">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0e9abeabd3ff2805ecb478ed2d9179db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_30.png"/>).  <a href="#a0e9abeabd3ff2805ecb478ed2d9179db">More...</a><br /></td></tr>
<tr class="separator:a0e9abeabd3ff2805ecb478ed2d9179db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcc8568f7a3a939fa03383abe3d05d1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a2fcc8568f7a3a939fa03383abe3d05d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a2fcc8568f7a3a939fa03383abe3d05d1">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2fcc8568f7a3a939fa03383abe3d05d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_31.png"/>).  <a href="#a2fcc8568f7a3a939fa03383abe3d05d1">More...</a><br /></td></tr>
<tr class="separator:a2fcc8568f7a3a939fa03383abe3d05d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04441228a0f7e4f1c7f69c8fd039d5ae"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a04441228a0f7e4f1c7f69c8fd039d5ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a04441228a0f7e4f1c7f69c8fd039d5ae">operator%=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a04441228a0f7e4f1c7f69c8fd039d5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schur product assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A\circ=B $" src="../../form_32.png"/>).  <a href="#a04441228a0f7e4f1c7f69c8fd039d5ae">More...</a><br /></td></tr>
<tr class="separator:a04441228a0f7e4f1c7f69c8fd039d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790b9be36dc44ebbdbddb83d031014f8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a790b9be36dc44ebbdbddb83d031014f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a790b9be36dc44ebbdbddb83d031014f8">operator*=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a790b9be36dc44ebbdbddb83d031014f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_33.png"/>).  <a href="#a790b9be36dc44ebbdbddb83d031014f8">More...</a><br /></td></tr>
<tr class="separator:a790b9be36dc44ebbdbddb83d031014f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b27c659c78c2afa6a19cffd7cbfb87"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a86b27c659c78c2afa6a19cffd7cbfb87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a86b27c659c78c2afa6a19cffd7cbfb87">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a86b27c659c78c2afa6a19cffd7cbfb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_34.png"/>).  <a href="#a86b27c659c78c2afa6a19cffd7cbfb87">More...</a><br /></td></tr>
<tr class="separator:a86b27c659c78c2afa6a19cffd7cbfb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb835fff8042eb8d9d28f0fc42f7f12"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aacb835fff8042eb8d9d28f0fc42f7f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aacb835fff8042eb8d9d28f0fc42f7f12">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:aacb835fff8042eb8d9d28f0fc42f7f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_35.png"/>).  <a href="#aacb835fff8042eb8d9d28f0fc42f7f12">More...</a><br /></td></tr>
<tr class="separator:aacb835fff8042eb8d9d28f0fc42f7f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb77d523f95b73d39a97f065e85d9ac4"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:adb77d523f95b73d39a97f065e85d9ac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#adb77d523f95b73d39a97f065e85d9ac4">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:adb77d523f95b73d39a97f065e85d9ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>).  <a href="#adb77d523f95b73d39a97f065e85d9ac4">More...</a><br /></td></tr>
<tr class="separator:adb77d523f95b73d39a97f065e85d9ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9592bd117d5ccd7c7741d5060664f7"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a2e9592bd117d5ccd7c7741d5060664f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a2e9592bd117d5ccd7c7741d5060664f7">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2e9592bd117d5ccd7c7741d5060664f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major dense matrix.  <a href="#a2e9592bd117d5ccd7c7741d5060664f7">More...</a><br /></td></tr>
<tr class="separator:a2e9592bd117d5ccd7c7741d5060664f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71134ad6527d6b9d16eec3eb36a45e0e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a71134ad6527d6b9d16eec3eb36a45e0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a71134ad6527d6b9d16eec3eb36a45e0e">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a71134ad6527d6b9d16eec3eb36a45e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the assignment of a row-major dense matrix.  <a href="#a71134ad6527d6b9d16eec3eb36a45e0e">More...</a><br /></td></tr>
<tr class="separator:a71134ad6527d6b9d16eec3eb36a45e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf43081da01b257a55c93db4ba72abc3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:acf43081da01b257a55c93db4ba72abc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#acf43081da01b257a55c93db4ba72abc3">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acf43081da01b257a55c93db4ba72abc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major dense matrix.  <a href="#acf43081da01b257a55c93db4ba72abc3">More...</a><br /></td></tr>
<tr class="separator:acf43081da01b257a55c93db4ba72abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee25dc3fde653be82a40c6c7628a2b6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a9ee25dc3fde653be82a40c6c7628a2b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a9ee25dc3fde653be82a40c6c7628a2b6">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9ee25dc3fde653be82a40c6c7628a2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the addition assignment of a row-major dense matrix.  <a href="#a9ee25dc3fde653be82a40c6c7628a2b6">More...</a><br /></td></tr>
<tr class="separator:a9ee25dc3fde653be82a40c6c7628a2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3282c0640f33e7087204a32fe14b5d04"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a3282c0640f33e7087204a32fe14b5d04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3282c0640f33e7087204a32fe14b5d04">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3282c0640f33e7087204a32fe14b5d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major dense matrix.  <a href="#a3282c0640f33e7087204a32fe14b5d04">More...</a><br /></td></tr>
<tr class="separator:a3282c0640f33e7087204a32fe14b5d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9d1abc4703c9ac6190e4e5d046f878"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a3e9d1abc4703c9ac6190e4e5d046f878"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3e9d1abc4703c9ac6190e4e5d046f878">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3e9d1abc4703c9ac6190e4e5d046f878"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the subtraction assignment of a row-major dense matrix.  <a href="#a3e9d1abc4703c9ac6190e4e5d046f878">More...</a><br /></td></tr>
<tr class="separator:a3e9d1abc4703c9ac6190e4e5d046f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628061045ed8d9954598a2a71a91006"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ae628061045ed8d9954598a2a71a91006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedSchurAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ae628061045ed8d9954598a2a71a91006">schurAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae628061045ed8d9954598a2a71a91006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the Schur product assignment of a row-major dense matrix.  <a href="#ae628061045ed8d9954598a2a71a91006">More...</a><br /></td></tr>
<tr class="separator:ae628061045ed8d9954598a2a71a91006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeb1d10c1218c9bdedc88642362a007"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a4aeb1d10c1218c9bdedc88642362a007"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::BLAZE_TEMPLATE VectorizedSchurAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4aeb1d10c1218c9bdedc88642362a007">schurAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4aeb1d10c1218c9bdedc88642362a007"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized implementation of the Schur product assignment of a row-major dense matrix.  <a href="#a4aeb1d10c1218c9bdedc88642362a007">More...</a><br /></td></tr>
<tr class="separator:a4aeb1d10c1218c9bdedc88642362a007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a99fddd4e06d7ef0aaa9960c12089c4e5">operator~</a> () noexcept</td></tr>
<tr class="memdesc:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#a99fddd4e06d7ef0aaa9960c12089c4e5">More...</a><br /></td></tr>
<tr class="separator:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00af660c25d47d64c2beb7511329a3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a00af660c25d47d64c2beb7511329a3e5">operator~</a> () const noexcept</td></tr>
<tr class="memdesc:a00af660c25d47d64c2beb7511329a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a00af660c25d47d64c2beb7511329a3e5">More...</a><br /></td></tr>
<tr class="separator:a00af660c25d47d64c2beb7511329a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a66050ce9534c344071d933c5a6c80553"><td class="memItemLeft" align="right" valign="top"><a id="a66050ce9534c344071d933c5a6c80553"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a66050ce9534c344071d933c5a6c80553">CustomMatrix</a> ()</td></tr>
<tr class="memdesc:a66050ce9534c344071d933c5a6c80553"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>. <br /></td></tr>
<tr class="separator:a66050ce9534c344071d933c5a6c80553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc34b9e3709c4cf64dd5971e47f805ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#adc34b9e3709c4cf64dd5971e47f805ec">CustomMatrix</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:adc34b9e3709c4cf64dd5971e47f805ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>.  <a href="#adc34b9e3709c4cf64dd5971e47f805ec">More...</a><br /></td></tr>
<tr class="separator:adc34b9e3709c4cf64dd5971e47f805ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42dadf682945f2679297b9ff2cfd05a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ae42dadf682945f2679297b9ff2cfd05a">CustomMatrix</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nn)</td></tr>
<tr class="memdesc:ae42dadf682945f2679297b9ff2cfd05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>.  <a href="#ae42dadf682945f2679297b9ff2cfd05a">More...</a><br /></td></tr>
<tr class="separator:ae42dadf682945f2679297b9ff2cfd05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c34d17f823dde9d82a425bc25e2250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aa8c34d17f823dde9d82a425bc25e2250">CustomMatrix</a> (const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:aa8c34d17f823dde9d82a425bc25e2250"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>.  <a href="#aa8c34d17f823dde9d82a425bc25e2250">More...</a><br /></td></tr>
<tr class="separator:aa8c34d17f823dde9d82a425bc25e2250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce97c4aab8a5a0b52df0c26917407ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a5ce97c4aab8a5a0b52df0c26917407ed">CustomMatrix</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a5ce97c4aab8a5a0b52df0c26917407ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>.  <a href="#a5ce97c4aab8a5a0b52df0c26917407ed">More...</a><br /></td></tr>
<tr class="separator:a5ce97c4aab8a5a0b52df0c26917407ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a39f6900abc46cb8e03ff9863c39779f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a467759dafbc79fac063a425ffe6e636d">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a39f6900abc46cb8e03ff9863c39779f4">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) noexcept</td></tr>
<tr class="memdesc:a39f6900abc46cb8e03ff9863c39779f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#a39f6900abc46cb8e03ff9863c39779f4">More...</a><br /></td></tr>
<tr class="separator:a39f6900abc46cb8e03ff9863c39779f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909936b58c659029e9d9902404a2a562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8af06a455ecdaafd1f6ef1ddf0e45602">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a909936b58c659029e9d9902404a2a562">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const noexcept</td></tr>
<tr class="memdesc:a909936b58c659029e9d9902404a2a562"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#a909936b58c659029e9d9902404a2a562">More...</a><br /></td></tr>
<tr class="separator:a909936b58c659029e9d9902404a2a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13719677d367ec65b109fafba194dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a467759dafbc79fac063a425ffe6e636d">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af13719677d367ec65b109fafba194dc8">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:af13719677d367ec65b109fafba194dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the matrix elements.  <a href="#af13719677d367ec65b109fafba194dc8">More...</a><br /></td></tr>
<tr class="separator:af13719677d367ec65b109fafba194dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd224ec923fa7a04aa9e88d15bd9aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8af06a455ecdaafd1f6ef1ddf0e45602">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3dd224ec923fa7a04aa9e88d15bd9aba">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:a3dd224ec923fa7a04aa9e88d15bd9aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the matrix elements.  <a href="#a3dd224ec923fa7a04aa9e88d15bd9aba">More...</a><br /></td></tr>
<tr class="separator:a3dd224ec923fa7a04aa9e88d15bd9aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899a5adfd74385f4c02d3f13d97749ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8a0b9cad82ee0f5834058cbf06e2799c">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a899a5adfd74385f4c02d3f13d97749ae">data</a> () noexcept</td></tr>
<tr class="memdesc:a899a5adfd74385f4c02d3f13d97749ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#a899a5adfd74385f4c02d3f13d97749ae">More...</a><br /></td></tr>
<tr class="separator:a899a5adfd74385f4c02d3f13d97749ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae437d90881d10fc62aa0e056442ff94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3cb30385840da2c793558f84add94f5d">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ae437d90881d10fc62aa0e056442ff94a">data</a> () const noexcept</td></tr>
<tr class="memdesc:ae437d90881d10fc62aa0e056442ff94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#ae437d90881d10fc62aa0e056442ff94a">More...</a><br /></td></tr>
<tr class="separator:ae437d90881d10fc62aa0e056442ff94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0255c2f20ef5267beabed47579bbbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8a0b9cad82ee0f5834058cbf06e2799c">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a0a0255c2f20ef5267beabed47579bbbb">data</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="memdesc:a0a0255c2f20ef5267beabed47579bbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements of row/column <em>i</em>.  <a href="#a0a0255c2f20ef5267beabed47579bbbb">More...</a><br /></td></tr>
<tr class="separator:a0a0255c2f20ef5267beabed47579bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c97ba770da3db635176a7bbb209f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3cb30385840da2c793558f84add94f5d">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ae1c97ba770da3db635176a7bbb209f70">data</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:ae1c97ba770da3db635176a7bbb209f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements of row/column <em>i</em>.  <a href="#ae1c97ba770da3db635176a7bbb209f70">More...</a><br /></td></tr>
<tr class="separator:ae1c97ba770da3db635176a7bbb209f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236b9d928133bb9bc81a51767888937e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#afef7ced3ceb87c8b0bff0b851ec15067">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a236b9d928133bb9bc81a51767888937e">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="memdesc:a236b9d928133bb9bc81a51767888937e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#a236b9d928133bb9bc81a51767888937e">More...</a><br /></td></tr>
<tr class="separator:a236b9d928133bb9bc81a51767888937e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9b8cd66c5c3bb3d238cf994ce97bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aab9b8cd66c5c3bb3d238cf994ce97bc7">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:aab9b8cd66c5c3bb3d238cf994ce97bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#aab9b8cd66c5c3bb3d238cf994ce97bc7">More...</a><br /></td></tr>
<tr class="separator:aab9b8cd66c5c3bb3d238cf994ce97bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f83f5cf3bff0440baaf4573b9c6ba3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4f83f5cf3bff0440baaf4573b9c6ba3c">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:a4f83f5cf3bff0440baaf4573b9c6ba3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#a4f83f5cf3bff0440baaf4573b9c6ba3c">More...</a><br /></td></tr>
<tr class="separator:a4f83f5cf3bff0440baaf4573b9c6ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3aacaad32882156b38f1ce0c4a6edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#afef7ced3ceb87c8b0bff0b851ec15067">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ada3aacaad32882156b38f1ce0c4a6edc">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) noexcept</td></tr>
<tr class="memdesc:ada3aacaad32882156b38f1ce0c4a6edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#ada3aacaad32882156b38f1ce0c4a6edc">More...</a><br /></td></tr>
<tr class="separator:ada3aacaad32882156b38f1ce0c4a6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dc83e4b9b3867f369d109bfd7fd741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a19dc83e4b9b3867f369d109bfd7fd741">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:a19dc83e4b9b3867f369d109bfd7fd741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a19dc83e4b9b3867f369d109bfd7fd741">More...</a><br /></td></tr>
<tr class="separator:a19dc83e4b9b3867f369d109bfd7fd741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2e36203febb780846fe8249d16909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a1bd2e36203febb780846fe8249d16909">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:a1bd2e36203febb780846fe8249d16909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a1bd2e36203febb780846fe8249d16909">More...</a><br /></td></tr>
<tr class="separator:a1bd2e36203febb780846fe8249d16909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a8e21969cf61bad9ecec1b686404f0d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8e21969cf61bad9ecec1b686404f0d7b">operator=</a> (const Type &amp;<a class="el" href="../../dc/d7b/group__simd.html#ga123bb79d57112645ef44ef5675361a4c">set</a>)</td></tr>
<tr class="memdesc:a8e21969cf61bad9ecec1b686404f0d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all matrix elements.  <a href="#a8e21969cf61bad9ecec1b686404f0d7b">More...</a><br /></td></tr>
<tr class="separator:a8e21969cf61bad9ecec1b686404f0d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ed3884b1784de569bc5de60ed28dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a96ed3884b1784de569bc5de60ed28dbf">operator=</a> (<a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; <a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; &gt; list)</td></tr>
<tr class="memdesc:a96ed3884b1784de569bc5de60ed28dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">List assignment to all matrix elements.  <a href="#a96ed3884b1784de569bc5de60ed28dbf">More...</a><br /></td></tr>
<tr class="separator:a96ed3884b1784de569bc5de60ed28dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a915bae7188107c850eb532eb99411"><td class="memTemplParams" colspan="2"><a id="a96a915bae7188107c850eb532eb99411"></a>
template&lt;typename Other , size_t M, size_t N&gt; </td></tr>
<tr class="memitem:a96a915bae7188107c850eb532eb99411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Other(&amp;array)[M][N])</td></tr>
<tr class="separator:a96a915bae7188107c850eb532eb99411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac296e9415c9e0a438cf6e885ac9dc31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ac296e9415c9e0a438cf6e885ac9dc31a">operator=</a> (const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac296e9415c9e0a438cf6e885ac9dc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>.  <a href="#ac296e9415c9e0a438cf6e885ac9dc31a">More...</a><br /></td></tr>
<tr class="separator:ac296e9415c9e0a438cf6e885ac9dc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ecb9ee4ee930555ec110d6c2154ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a17ecb9ee4ee930555ec110d6c2154ce3">operator=</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a17ecb9ee4ee930555ec110d6c2154ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>.  <a href="#a17ecb9ee4ee930555ec110d6c2154ce3">More...</a><br /></td></tr>
<tr class="separator:a17ecb9ee4ee930555ec110d6c2154ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49d6942e5ada387a0fc89a444ae0fe7"><td class="memTemplParams" colspan="2"><a id="ac49d6942e5ada387a0fc89a444ae0fe7"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:ac49d6942e5ada387a0fc89a444ae0fe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ac49d6942e5ada387a0fc89a444ae0fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459907cba7d6f1f80e39c694edc26e8e"><td class="memTemplParams" colspan="2"><a id="a459907cba7d6f1f80e39c694edc26e8e"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a459907cba7d6f1f80e39c694edc26e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a459907cba7d6f1f80e39c694edc26e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b99d4d5b998dbbb48e92ef6e8dec92"><td class="memTemplParams" colspan="2"><a id="ac3b99d4d5b998dbbb48e92ef6e8dec92"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:ac3b99d4d5b998dbbb48e92ef6e8dec92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ac3b99d4d5b998dbbb48e92ef6e8dec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d7db065180861d393b58f8c79b06f"><td class="memTemplParams" colspan="2"><a id="a065d7db065180861d393b58f8c79b06f"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a065d7db065180861d393b58f8c79b06f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a065d7db065180861d393b58f8c79b06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9db75bb35b259049d0c311d9be7b27"><td class="memTemplParams" colspan="2"><a id="a4e9db75bb35b259049d0c311d9be7b27"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a4e9db75bb35b259049d0c311d9be7b27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a4e9db75bb35b259049d0c311d9be7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac944c335da309e941314c27cd7df3ccd"><td class="memTemplParams" colspan="2"><a id="ac944c335da309e941314c27cd7df3ccd"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac944c335da309e941314c27cd7df3ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:ac944c335da309e941314c27cd7df3ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66facfa227d77eef33180ade26c39db2"><td class="memTemplParams" colspan="2"><a id="a66facfa227d77eef33180ade26c39db2"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a66facfa227d77eef33180ade26c39db2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:a66facfa227d77eef33180ade26c39db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a1f6c7df24b32ffe46cf016c5aa096c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a1f6c7df24b32ffe46cf016c5aa096c62">rows</a> () const noexcept</td></tr>
<tr class="memdesc:a1f6c7df24b32ffe46cf016c5aa096c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the matrix.  <a href="#a1f6c7df24b32ffe46cf016c5aa096c62">More...</a><br /></td></tr>
<tr class="separator:a1f6c7df24b32ffe46cf016c5aa096c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dd938bd5f731578c57771f2fae53ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a83dd938bd5f731578c57771f2fae53ef">columns</a> () const noexcept</td></tr>
<tr class="memdesc:a83dd938bd5f731578c57771f2fae53ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the matrix.  <a href="#a83dd938bd5f731578c57771f2fae53ef">More...</a><br /></td></tr>
<tr class="separator:a83dd938bd5f731578c57771f2fae53ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7cee36af52c0b35b3a2652961279a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a9e7cee36af52c0b35b3a2652961279a6">spacing</a> () const noexcept</td></tr>
<tr class="memdesc:a9e7cee36af52c0b35b3a2652961279a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing between the beginning of two rows/columns.  <a href="#a9e7cee36af52c0b35b3a2652961279a6">More...</a><br /></td></tr>
<tr class="separator:a9e7cee36af52c0b35b3a2652961279a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f462845b3727e3e688bb23d298c95f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ac9f462845b3727e3e688bb23d298c95f">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:ac9f462845b3727e3e688bb23d298c95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the matrix.  <a href="#ac9f462845b3727e3e688bb23d298c95f">More...</a><br /></td></tr>
<tr class="separator:ac9f462845b3727e3e688bb23d298c95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f8851b784db370d5b963c262fe9531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aa2f8851b784db370d5b963c262fe9531">capacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const noexcept</td></tr>
<tr class="memdesc:aa2f8851b784db370d5b963c262fe9531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column.  <a href="#aa2f8851b784db370d5b963c262fe9531">More...</a><br /></td></tr>
<tr class="separator:aa2f8851b784db370d5b963c262fe9531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b0db5192d1b713a1b4e288ad497f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a84b0db5192d1b713a1b4e288ad497f98">nonZeros</a> () const</td></tr>
<tr class="memdesc:a84b0db5192d1b713a1b4e288ad497f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of non-zero elements in the matrix.  <a href="#a84b0db5192d1b713a1b4e288ad497f98">More...</a><br /></td></tr>
<tr class="separator:a84b0db5192d1b713a1b4e288ad497f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade409b7b2a58d1905edf06fe549405e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ade409b7b2a58d1905edf06fe549405e8">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:ade409b7b2a58d1905edf06fe549405e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column.  <a href="#ade409b7b2a58d1905edf06fe549405e8">More...</a><br /></td></tr>
<tr class="separator:ade409b7b2a58d1905edf06fe549405e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c63eea99b96e68d54572f3d060c53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aa0c63eea99b96e68d54572f3d060c53a">reset</a> ()</td></tr>
<tr class="memdesc:aa0c63eea99b96e68d54572f3d060c53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#aa0c63eea99b96e68d54572f3d060c53a">More...</a><br /></td></tr>
<tr class="separator:aa0c63eea99b96e68d54572f3d060c53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86439f15a775922e0a29661656d84cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a86439f15a775922e0a29661656d84cdf">reset</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a86439f15a775922e0a29661656d84cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column to the default initial values.  <a href="#a86439f15a775922e0a29661656d84cdf">More...</a><br /></td></tr>
<tr class="separator:a86439f15a775922e0a29661656d84cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ca06a74f9bf2233f62bb13b1c18d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a86ca06a74f9bf2233f62bb13b1c18d8e">clear</a> ()</td></tr>
<tr class="memdesc:a86ca06a74f9bf2233f62bb13b1c18d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the <img class="formulaInl" alt="$ M \times N $" src="../../form_29.png"/> matrix.  <a href="#a86ca06a74f9bf2233f62bb13b1c18d8e">More...</a><br /></td></tr>
<tr class="separator:a86ca06a74f9bf2233f62bb13b1c18d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a20b4ff6765a27ea1e75312e2d54016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a2a20b4ff6765a27ea1e75312e2d54016">swap</a> (<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:a2a20b4ff6765a27ea1e75312e2d54016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="#a2a20b4ff6765a27ea1e75312e2d54016">More...</a><br /></td></tr>
<tr class="separator:a2a20b4ff6765a27ea1e75312e2d54016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numeric functions</div></td></tr>
<tr class="memitem:a2350631eaa8d1ce0e9a464a5f4cd3b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a2350631eaa8d1ce0e9a464a5f4cd3b28">transpose</a> ()</td></tr>
<tr class="memdesc:a2350631eaa8d1ce0e9a464a5f4cd3b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place transpose of the matrix.  <a href="#a2350631eaa8d1ce0e9a464a5f4cd3b28">More...</a><br /></td></tr>
<tr class="separator:a2350631eaa8d1ce0e9a464a5f4cd3b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d696e34013684a07a6f671f36f5303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ad5d696e34013684a07a6f671f36f5303">ctranspose</a> ()</td></tr>
<tr class="memdesc:ad5d696e34013684a07a6f671f36f5303"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugate transpose of the matrix.  <a href="#ad5d696e34013684a07a6f671f36f5303">More...</a><br /></td></tr>
<tr class="separator:ad5d696e34013684a07a6f671f36f5303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95ce9a8f3e75e58a7299c17c9da7ee0"><td class="memTemplParams" colspan="2"><a id="af95ce9a8f3e75e58a7299c17c9da7ee0"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:af95ce9a8f3e75e58a7299c17c9da7ee0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:af95ce9a8f3e75e58a7299c17c9da7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resource management functions</div></td></tr>
<tr class="memitem:ab7802f0469eba893a552582172a7b75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ab7802f0469eba893a552582172a7b75a">reset</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:ab7802f0469eba893a552582172a7b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the custom matrix and replaces the array of elements with the given array.  <a href="#ab7802f0469eba893a552582172a7b75a">More...</a><br /></td></tr>
<tr class="separator:ab7802f0469eba893a552582172a7b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b3df846e2942cef9de3dc5586a448a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ac5b3df846e2942cef9de3dc5586a448a">reset</a> (Type *ptr, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nn)</td></tr>
<tr class="memdesc:ac5b3df846e2942cef9de3dc5586a448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the custom matrix and replaces the array of elements with the given array.  <a href="#ac5b3df846e2942cef9de3dc5586a448a">More...</a><br /></td></tr>
<tr class="separator:ac5b3df846e2942cef9de3dc5586a448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a3960be7b2021e03efbf9f871108dcec1"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3960be7b2021e03efbf9f871108dcec1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3960be7b2021e03efbf9f871108dcec1">canAlias</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:a3960be7b2021e03efbf9f871108dcec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix can alias with the given address <em>alias</em>.  <a href="#a3960be7b2021e03efbf9f871108dcec1">More...</a><br /></td></tr>
<tr class="separator:a3960be7b2021e03efbf9f871108dcec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdbd9c2c456dda6de599d45f4f258d4"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a7cdbd9c2c456dda6de599d45f4f258d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7cdbd9c2c456dda6de599d45f4f258d4">isAliased</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:a7cdbd9c2c456dda6de599d45f4f258d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is aliased with the given address <em>alias</em>.  <a href="#a7cdbd9c2c456dda6de599d45f4f258d4">More...</a><br /></td></tr>
<tr class="separator:a7cdbd9c2c456dda6de599d45f4f258d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be04d7bc7fc33faf7249583ba19df10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a5be04d7bc7fc33faf7249583ba19df10">isAligned</a> () const noexcept</td></tr>
<tr class="memdesc:a5be04d7bc7fc33faf7249583ba19df10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is properly aligned in memory.  <a href="#a5be04d7bc7fc33faf7249583ba19df10">More...</a><br /></td></tr>
<tr class="separator:a5be04d7bc7fc33faf7249583ba19df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01e706dc572063db13fb8ceb61a85cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ad01e706dc572063db13fb8ceb61a85cf">canSMPAssign</a> () const noexcept</td></tr>
<tr class="memdesc:ad01e706dc572063db13fb8ceb61a85cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix can be used in SMP assignments.  <a href="#ad01e706dc572063db13fb8ceb61a85cf">More...</a><br /></td></tr>
<tr class="separator:ad01e706dc572063db13fb8ceb61a85cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c29fd4820e8f3049dd1dce98961ddc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a6c29fd4820e8f3049dd1dce98961ddc0">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const noexcept</td></tr>
<tr class="memdesc:a6c29fd4820e8f3049dd1dce98961ddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load of a SIMD element of the matrix.  <a href="#a6c29fd4820e8f3049dd1dce98961ddc0">More...</a><br /></td></tr>
<tr class="separator:a6c29fd4820e8f3049dd1dce98961ddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f2a8b68558cab3c4164ccac430e5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ae34f2a8b68558cab3c4164ccac430e5b">loada</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const noexcept</td></tr>
<tr class="memdesc:ae34f2a8b68558cab3c4164ccac430e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of a SIMD element of the matrix.  <a href="#ae34f2a8b68558cab3c4164ccac430e5b">More...</a><br /></td></tr>
<tr class="separator:ae34f2a8b68558cab3c4164ccac430e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6c78efa61f63628f16b487ed2d7385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#adb6c78efa61f63628f16b487ed2d7385">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const noexcept</td></tr>
<tr class="memdesc:adb6c78efa61f63628f16b487ed2d7385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of a SIMD element of the matrix.  <a href="#adb6c78efa61f63628f16b487ed2d7385">More...</a><br /></td></tr>
<tr class="separator:adb6c78efa61f63628f16b487ed2d7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8259970b8a9cf4fb6cfa676921a9040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af8259970b8a9cf4fb6cfa676921a9040">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:af8259970b8a9cf4fb6cfa676921a9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store of a SIMD element of the matrix.  <a href="#af8259970b8a9cf4fb6cfa676921a9040">More...</a><br /></td></tr>
<tr class="separator:af8259970b8a9cf4fb6cfa676921a9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fd1f02a0aa1fb1c23c0c16d63a66ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aa4fd1f02a0aa1fb1c23c0c16d63a66ec">storea</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aa4fd1f02a0aa1fb1c23c0c16d63a66ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a SIMD element of the matrix.  <a href="#aa4fd1f02a0aa1fb1c23c0c16d63a66ec">More...</a><br /></td></tr>
<tr class="separator:aa4fd1f02a0aa1fb1c23c0c16d63a66ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34be37c69ab822215d0e3558e92ceb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af34be37c69ab822215d0e3558e92ceb4">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:af34be37c69ab822215d0e3558e92ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a SIMD element of the matrix.  <a href="#af34be37c69ab822215d0e3558e92ceb4">More...</a><br /></td></tr>
<tr class="separator:af34be37c69ab822215d0e3558e92ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a3c07f57382acee484270f3a9c76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a448a3c07f57382acee484270f3a9c76a">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a448a3c07f57382acee484270f3a9c76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a SIMD element of the matrix.  <a href="#a448a3c07f57382acee484270f3a9c76a">More...</a><br /></td></tr>
<tr class="separator:a448a3c07f57382acee484270f3a9c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e28f8364fa6dd875e1d37fa9d391cf9"><td class="memTemplParams" colspan="2"><a id="a0e28f8364fa6dd875e1d37fa9d391cf9"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a0e28f8364fa6dd875e1d37fa9d391cf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a0e28f8364fa6dd875e1d37fa9d391cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42496a22040e062b06088c0a9468b4"><td class="memTemplParams" colspan="2"><a id="adc42496a22040e062b06088c0a9468b4"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:adc42496a22040e062b06088c0a9468b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:adc42496a22040e062b06088c0a9468b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c883d67f6088e112578ee45acf169c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a45c883d67f6088e112578ee45acf169c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a45c883d67f6088e112578ee45acf169c">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a45c883d67f6088e112578ee45acf169c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major dense matrix.  <a href="#a45c883d67f6088e112578ee45acf169c">More...</a><br /></td></tr>
<tr class="separator:a45c883d67f6088e112578ee45acf169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd75d04defa249106a2c407439190fe"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a4fd75d04defa249106a2c407439190fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4fd75d04defa249106a2c407439190fe">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4fd75d04defa249106a2c407439190fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major sparse matrix.  <a href="#a4fd75d04defa249106a2c407439190fe">More...</a><br /></td></tr>
<tr class="separator:a4fd75d04defa249106a2c407439190fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f33dc6204cda4335bee55df2a157e4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a72f33dc6204cda4335bee55df2a157e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a72f33dc6204cda4335bee55df2a157e4">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a72f33dc6204cda4335bee55df2a157e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major sparse matrix.  <a href="#a72f33dc6204cda4335bee55df2a157e4">More...</a><br /></td></tr>
<tr class="separator:a72f33dc6204cda4335bee55df2a157e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba580e0fd4e74445bf42964871dfe7f"><td class="memTemplParams" colspan="2"><a id="a8ba580e0fd4e74445bf42964871dfe7f"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a8ba580e0fd4e74445bf42964871dfe7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedAddAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a8ba580e0fd4e74445bf42964871dfe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda832e916afd29e2b9b4cdb48d71c27"><td class="memTemplParams" colspan="2"><a id="aeda832e916afd29e2b9b4cdb48d71c27"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:aeda832e916afd29e2b9b4cdb48d71c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedAddAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aeda832e916afd29e2b9b4cdb48d71c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4e5258121c5731ea25b2599b846c6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a6da4e5258121c5731ea25b2599b846c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a6da4e5258121c5731ea25b2599b846c6">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6da4e5258121c5731ea25b2599b846c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major dense matrix.  <a href="#a6da4e5258121c5731ea25b2599b846c6">More...</a><br /></td></tr>
<tr class="separator:a6da4e5258121c5731ea25b2599b846c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697aa973c0aca3f96f28e59c4c34b4bd"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a697aa973c0aca3f96f28e59c4c34b4bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a697aa973c0aca3f96f28e59c4c34b4bd">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a697aa973c0aca3f96f28e59c4c34b4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major sparse matrix.  <a href="#a697aa973c0aca3f96f28e59c4c34b4bd">More...</a><br /></td></tr>
<tr class="separator:a697aa973c0aca3f96f28e59c4c34b4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532bb44cdd5f4526f37df279e17bac9e"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a532bb44cdd5f4526f37df279e17bac9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a532bb44cdd5f4526f37df279e17bac9e">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a532bb44cdd5f4526f37df279e17bac9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major sparse matrix.  <a href="#a532bb44cdd5f4526f37df279e17bac9e">More...</a><br /></td></tr>
<tr class="separator:a532bb44cdd5f4526f37df279e17bac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08873415698739bd1d8d241e906a71b8"><td class="memTemplParams" colspan="2"><a id="a08873415698739bd1d8d241e906a71b8"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a08873415698739bd1d8d241e906a71b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedSubAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a08873415698739bd1d8d241e906a71b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884209821da8106455f44b3aae04fb43"><td class="memTemplParams" colspan="2"><a id="a884209821da8106455f44b3aae04fb43"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a884209821da8106455f44b3aae04fb43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedSubAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a884209821da8106455f44b3aae04fb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bd9baed6069eddfbcc93247040631"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a8d5bd9baed6069eddfbcc93247040631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8d5bd9baed6069eddfbcc93247040631">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8d5bd9baed6069eddfbcc93247040631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major dense matrix.  <a href="#a8d5bd9baed6069eddfbcc93247040631">More...</a><br /></td></tr>
<tr class="separator:a8d5bd9baed6069eddfbcc93247040631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e4426e8dfe3a988ca24df3e074455a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a27e4426e8dfe3a988ca24df3e074455a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a27e4426e8dfe3a988ca24df3e074455a">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a27e4426e8dfe3a988ca24df3e074455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major sparse matrix.  <a href="#a27e4426e8dfe3a988ca24df3e074455a">More...</a><br /></td></tr>
<tr class="separator:a27e4426e8dfe3a988ca24df3e074455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcbcf34c1a2e460eb5d9b1e99b7ef70"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:acfcbcf34c1a2e460eb5d9b1e99b7ef70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#acfcbcf34c1a2e460eb5d9b1e99b7ef70">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acfcbcf34c1a2e460eb5d9b1e99b7ef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major sparse matrix.  <a href="#acfcbcf34c1a2e460eb5d9b1e99b7ef70">More...</a><br /></td></tr>
<tr class="separator:acfcbcf34c1a2e460eb5d9b1e99b7ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b48598d6f2208de3ed29de46ef7c14"><td class="memTemplParams" colspan="2"><a id="aa1b48598d6f2208de3ed29de46ef7c14"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:aa1b48598d6f2208de3ed29de46ef7c14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt; VectorizedSchurAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>schurAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aa1b48598d6f2208de3ed29de46ef7c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b3534755f9f9d81271b868c89fb74e"><td class="memTemplParams" colspan="2"><a id="ac0b3534755f9f9d81271b868c89fb74e"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ac0b3534755f9f9d81271b868c89fb74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; VectorizedSchurAssign&lt; MT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>schurAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:ac0b3534755f9f9d81271b868c89fb74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed069393df12931e7353da259733aee"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:abed069393df12931e7353da259733aee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#abed069393df12931e7353da259733aee">schurAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abed069393df12931e7353da259733aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the Schur product assignment of a column-major dense matrix.  <a href="#abed069393df12931e7353da259733aee">More...</a><br /></td></tr>
<tr class="separator:abed069393df12931e7353da259733aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dab4de5897eb667dd8beee94a810f05"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a4dab4de5897eb667dd8beee94a810f05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a4dab4de5897eb667dd8beee94a810f05">schurAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4dab4de5897eb667dd8beee94a810f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the Schur product assignment of a row-major sparse matrix.  <a href="#a4dab4de5897eb667dd8beee94a810f05">More...</a><br /></td></tr>
<tr class="separator:a4dab4de5897eb667dd8beee94a810f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d82bfd467ee43cba316f1064ce53c6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:aa1d82bfd467ee43cba316f1064ce53c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#aa1d82bfd467ee43cba316f1064ce53c6">schurAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa1d82bfd467ee43cba316f1064ce53c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the Schur product assignment of a column-major sparse matrix.  <a href="#aa1d82bfd467ee43cba316f1064ce53c6">More...</a><br /></td></tr>
<tr class="separator:aa1d82bfd467ee43cba316f1064ce53c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a09c3e34596d9650b5c584e79a318f174"><td class="memItemLeft" align="right" valign="top"><a id="a09c3e34596d9650b5c584e79a318f174"></a>enum &#160;</td><td class="memItemRight" valign="bottom">: size_t { <b>SIMDSIZE</b> = SIMDTrait&lt;ElementType&gt;::size
 }<tr class="memdesc:a09c3e34596d9650b5c584e79a318f174"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements packed within a single SIMD element. <br /></td></tr>
</td></tr>
<tr class="separator:a09c3e34596d9650b5c584e79a318f174"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:af4faddfbc2c29bf7601c7ef6d383384d"><td class="memItemLeft" align="right" valign="top"><a id="af4faddfbc2c29bf7601c7ef6d383384d"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af4faddfbc2c29bf7601c7ef6d383384d">m_</a></td></tr>
<tr class="memdesc:af4faddfbc2c29bf7601c7ef6d383384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of rows of the matrix. <br /></td></tr>
<tr class="separator:af4faddfbc2c29bf7601c7ef6d383384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155fdb6e64e8257ace36f08a5bc947d5"><td class="memItemLeft" align="right" valign="top"><a id="a155fdb6e64e8257ace36f08a5bc947d5"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a155fdb6e64e8257ace36f08a5bc947d5">n_</a></td></tr>
<tr class="memdesc:a155fdb6e64e8257ace36f08a5bc947d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of columns of the matrix. <br /></td></tr>
<tr class="separator:a155fdb6e64e8257ace36f08a5bc947d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09ac300fa4e28ca699cccb3c305cd37"><td class="memItemLeft" align="right" valign="top"><a id="ad09ac300fa4e28ca699cccb3c305cd37"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#ad09ac300fa4e28ca699cccb3c305cd37">nn_</a></td></tr>
<tr class="memdesc:ad09ac300fa4e28ca699cccb3c305cd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements between two rows. <br /></td></tr>
<tr class="separator:ad09ac300fa4e28ca699cccb3c305cd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68878e9f9335a2afbb0e7b07ff25f763"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a68878e9f9335a2afbb0e7b07ff25f763">v_</a></td></tr>
<tr class="memdesc:a68878e9f9335a2afbb0e7b07ff25f763"><td class="mdescLeft">&#160;</td><td class="mdescRight">The custom array of elements.  <a href="#a68878e9f9335a2afbb0e7b07ff25f763">More...</a><br /></td></tr>
<tr class="separator:a68878e9f9335a2afbb0e7b07ff25f763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt;<br />
class blaze::CustomMatrix&lt; Type, AF, PF, SO &gt;</h3>

<p>Efficient implementation of a customizable matrix.</p>
<p>The <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> class template provides the functionality to represent an external array of elements of arbitrary type and a fixed size as a native <b>Blaze</b> dense matrix data structure. Thus in contrast to all other dense matrix types a custom matrix does not perform any kind of memory allocation by itself, but it is provided with an existing array of element during construction. A custom matrix can therefore be considered an alias to the existing array. </p>
<p>The type of the elements, the properties of the given array of elements and the storage order of the matrix can be specified via the following four template parameters:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> PF, <span class="keywordtype">bool</span> SO &gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html#a66050ce9534c344071d933c5a6c80553">CustomMatrix</a>;</div></div><!-- fragment --><ul>
<li>Type: specifies the type of the matrix elements. <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>AF : specifies whether the represented, external arrays are properly aligned with respect to the available instruction set (SSE, AVX, ...) or not.</li>
<li>PF : specified whether the represented, external arrays are properly padded with respect to the available instruction set (SSE, AVX, ...) or not.</li>
<li>SO : specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the matrix. The default value is <a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>.</li>
</ul>
<p>The following examples give an impression of several possible types of custom matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom row-major matrix for unaligned, unpadded integer arrays</span></div><div class="line"><span class="keyword">using</span> UnalignedUnpadded = CustomMatrix&lt;int,unaligned,unpadded,rowMajor&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom column-major matrix for unaligned but padded &#39;float&#39; arrays</span></div><div class="line"><span class="keyword">using</span> UnalignedPadded = CustomMatrix&lt;float,unaligned,padded,columnMajor&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom row-major matrix for aligned, unpadded &#39;double&#39; arrays</span></div><div class="line"><span class="keyword">using</span> AlignedUnpadded = CustomMatrix&lt;double,aligned,unpadded,rowMajor&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom column-major matrix for aligned, padded &#39;complex&lt;double&gt;&#39; arrays</span></div><div class="line"><span class="keyword">using</span> AlignedPadded = CustomMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">aligned</a>,<a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">padded</a>,<a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">columnMajor</a>&gt;;</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="custommatrix_special_properties"></a>
Special Properties of Custom Matrices</h1>
<p>In comparison with the remaining <b>Blaze</b> dense matrix types <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> has several special characteristics. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> of these result from the fact that a custom matrix is not performing any kind of memory allocation, but instead is given an existing array of elements. The following sections discuss all of these characteristics:</p>
<ol type="1">
<li><b><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#custommatrix_memory_management">Memory Management</a></b></li>
<li><b><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#custommatrix_copy_operations">Copy Operations</a></b></li>
<li><b><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#custommatrix_alignment">Alignment</a></b></li>
<li><b><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#custommatrix_padding">Padding</a></b></li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="custommatrix_memory_management"></a>
Memory Management</h2>
<p>The <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a> class template acts as an adaptor for an existing array of elements. As such it provides everything that is required to use the array just like a native <b>Blaze</b> dense matrix data structure. However, this flexibility comes with the price that the user of a custom matrix is responsible for the resource management.</p>
<p>The following examples give an impression of several possible custom matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="comment">// Definition of a 3x4 custom row-major matrix with unaligned, unpadded and externally</span></div><div class="line"><span class="comment">// managed integer array. Note that the std::vector must be guaranteed to outlive the</span></div><div class="line"><span class="comment">// custom matrix!</span></div><div class="line">std::vector&lt;int&gt; vec( 12UL );</div><div class="line">CustomMatrix&lt;int,unaligned,unpadded&gt; A( &amp;vec[0], 3UL, 4UL );</div><div class="line"></div><div class="line"><span class="comment">// Definition of a custom 8x12 matrix for an aligned and padded integer array of</span></div><div class="line"><span class="comment">// capacity 128 (including 8 padding elements per row). Note that the std::unique_ptr</span></div><div class="line"><span class="comment">// must be guaranteed to outlive the custom matrix!</span></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory( allocate&lt;int&gt;( 128UL ) );</div><div class="line">CustomMatrix&lt;int,aligned,padded&gt; B( memory.get(), 8UL, 12UL, 16UL );</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="custommatrix_copy_operations"></a>
Copy Operations</h2>
<p>As with all dense matrices it is possible to copy construct a custom matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomMatrix&lt;int,unaligned,unpadded&gt;;</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vec( 6UL, 10 );    <span class="comment">// Vector of 6 integers of the value 10</span></div><div class="line">CustomType A( &amp;vec[0], 2UL, 3UL );  <span class="comment">// Represent the std::vector as Blaze dense matrix</span></div><div class="line">a[1] = 20;                          <span class="comment">// Also modifies the std::vector</span></div><div class="line"></div><div class="line">CustomType B( a );  <span class="comment">// Creating a copy of vector a</span></div><div class="line">b[2] = 20;          <span class="comment">// Also affects matrix A and the std::vector</span></div></div><!-- fragment --><p>It is important to note that a custom matrix acts as a reference to the specified array. Thus the result of the copy constructor is a new custom matrix that is referencing and representing the same array as the original custom matrix.</p>
<p>In contrast to copy construction, just as with references, copy assignment does not change which array is referenced by the custom matrices, but modifies the values of the array:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec2( 6UL, 4 );     <span class="comment">// Vector of 6 integers of the value 4</span></div><div class="line">CustomType C( &amp;vec2[0], 2UL, 3UL );  <span class="comment">// Represent the std::vector as Blaze dense matrix</span></div><div class="line"></div><div class="line">A = C;  <span class="comment">// Copy assignment: Set all values of matrix A and B to 4.</span></div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="custommatrix_alignment"></a>
Alignment</h2>
<p>In case the custom matrix is specified as <em>aligned</em> the passed array must adhere to some alignment restrictions based on the alignment requirements of the used data type and the used instruction set (SSE, AVX, ...). The restriction applies to the first element of each row/column: In case of a row-major matrix the first element of each row must be properly aligned, in case of a column-major matrix the first element of each column must be properly aligned. For instance, if a row-major matrix is used and AVX is active the first element of each row must be 32-bit aligned:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><span class="comment">// Allocation of 32-bit aligned memory</span></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory( allocate&lt;int&gt;( 40UL ) );</div><div class="line"></div><div class="line">CustomMatrix&lt;int,aligned,padded,rowMajor&gt; A( memory.get(), 5UL, 6UL, 8UL );</div></div><!-- fragment --><p>In the example, the row-major matrix has six columns. However, since with AVX eight integer values are loaded together the matrix is padded with two additional elements. This guarantees that the first element of each row is 32-bit aligned. In case the alignment requirements are violated, a <em>std::invalid_argument</em> exception is thrown.</p>
<p><br />
 </p>
<h2><a class="anchor" id="custommatrix_padding"></a>
Padding</h2>
<p>Adding padding elements to the end of an array can have a significant impact on performance. For instance, assuming that AVX is available, then two aligned, padded, 3x3 double precision matrices can be added via three SIMD addition operations:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomMatrix&lt;double,aligned,padded&gt;;</div><div class="line"></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory1( allocate&lt;double&gt;( 12UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory2( allocate&lt;double&gt;( 12UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory3( allocate&lt;double&gt;( 12UL ) );</div><div class="line"></div><div class="line"><span class="comment">// Creating padded custom 3x3 matrix with an additional padding element in each row</span></div><div class="line">CustomType A( memory1.get(), 3UL, 3UL, 4UL );</div><div class="line">CustomType B( memory2.get(), 3UL, 3UL, 4UL );</div><div class="line">CustomType C( memory3.get(), 3UL, 3UL, 4UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">C = A + B;  <span class="comment">// AVX-based matrix addition</span></div></div><!-- fragment --><p>In this example, maximum performance is possible. However, in case no padding elements are inserted a scalar addition has to be used:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CustomType = CustomMatrix&lt;double,aligned,unpadded&gt;;</div><div class="line"></div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory1( allocate&lt;double&gt;( 9UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory2( allocate&lt;double&gt;( 9UL ) );</div><div class="line">std::unique_ptr&lt;int[],Deallocate&gt; memory3( allocate&lt;double&gt;( 9UL ) );</div><div class="line"></div><div class="line"><span class="comment">// Creating unpadded custom 3x3 matrix</span></div><div class="line">CustomType A( memory1.get(), 3UL, 3UL );</div><div class="line">CustomType B( memory2.get(), 3UL, 3UL );</div><div class="line">CustomType C( memory3.get(), 3UL, 3UL );</div><div class="line"></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">C = A + B;  <span class="comment">// Scalar matrix addition</span></div></div><!-- fragment --><p>Note that the construction of padded and unpadded aligned matrices looks identical. However, in case of padded matrices, <b>Blaze</b> will zero initialize the padding element and use them in all computations in order to achieve maximum performance. In case of an unpadded matrix <b>Blaze</b> will ignore the elements with the downside that it is not possible to load a complete row to an AVX register, which makes it necessary to fall back to a scalar addition.</p>
<p>The number of padding elements is required to be sufficient with respect to the available instruction set: In case of an aligned padded custom matrix the added padding elements must guarantee that the total number of elements in each row/column is a multiple of the SIMD vector width. In case of an unaligned padded matrix the number of padding elements can be greater or equal the number of padding elements of an aligned padded custom matrix. In case the padding is insufficient with respect to the available instruction set, a <em>std::invalid_argument</em> exception is thrown.</p>
<p><br />
 </p>
<h1><a class="anchor" id="custommatrix_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The use of custom matrices in arithmetic operations is designed to be as natural and intuitive as possible. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> operations (addition, subtraction, multiplication, scaling, ...) can be expressed similar to a text book representation. Also, custom matrices can be combined with all other dense and sparse vectors and matrices. The following example gives an impression of the use of <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gac02fbb3ef9a09baf0b5e7b32a55cf6c7">blaze::aligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga2acdda4ff7a369ef66302e647ff0926f">blaze::padded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><span class="comment">// Non-initialized custom 2x3 row-major matrix. All given arrays are considered to be</span></div><div class="line"><span class="comment">// unaligned and unpadded. The memory is managed via a &#39;std::vector&#39;.</span></div><div class="line">std::vector&lt;double&gt; memory1( 6UL );</div><div class="line">CustomMatrix&lt;double,unaligned,unpadded&gt; A( memory1.data(), 2UL, 3UL );</div><div class="line"></div><div class="line">A(0,0) = 1.0; A(0,1) = 2.0; A(0,2) = 3.0;  <span class="comment">// Initialization of the first row</span></div><div class="line">A(1,0) = 4.0; A(1,1) = 5.0; A(1,2) = 6.0;  <span class="comment">// Initialization of the second row</span></div><div class="line"></div><div class="line"><span class="comment">// Non-initialized custom 2x3 row-major matrix with padding elements. All given arrays are</span></div><div class="line"><span class="comment">// required to be properly aligned and padded. The memory is managed via a &#39;std::unique_ptr&#39;.</span></div><div class="line">std::unique_ptr&lt;double[],Deallocate&gt; memory2( allocate&lt;double&gt;( 16UL ) );</div><div class="line">CustomMatrix&lt;double,aligned,padded&gt; B( memory2.get(), 2UL, 3UL, 8UL );</div><div class="line"></div><div class="line">B(0,0) = 1.0; B(0,1) = 3.0; B(0,2) = 5.0;    <span class="comment">// Initialization of the first row</span></div><div class="line">B(1,0) = 2.0; B(1,1) = 4.0; B(1,2) = 6.0;    <span class="comment">// Initialization of the second row</span></div><div class="line"></div><div class="line">CompressedMatrix&lt;float&gt; C( 2, 3 );        <span class="comment">// Empty row-major sparse single precision matrix</span></div><div class="line">DynamicMatrix&lt;float&gt;    D( 3, 2, 4.0F );  <span class="comment">// Directly, homogeneously initialized single precision 3x2 matrix</span></div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;    E( A );  <span class="comment">// Creation of a new row-major matrix as a copy of A</span></div><div class="line">DynamicMatrix&lt;double,columnMajor&gt; F;       <span class="comment">// Creation of a default column-major matrix</span></div><div class="line"></div><div class="line">E = A + B;     <span class="comment">// Matrix addition and assignment to a row-major matrix</span></div><div class="line">F = A - C;     <span class="comment">// Matrix subtraction and assignment to a column-major matrix</span></div><div class="line">F = A * D;     <span class="comment">// Matrix multiplication between two matrices of different element types</span></div><div class="line"></div><div class="line">A *= 2.0;      <span class="comment">// In-place scaling of matrix A</span></div><div class="line">E  = 2.0 * B;  <span class="comment">// Scaling of matrix B</span></div><div class="line">F  = D * 2.0;  <span class="comment">// Scaling of matrix D</span></div><div class="line"></div><div class="line">E += A - B;    <span class="comment">// Addition assignment</span></div><div class="line">E -= A + C;    <span class="comment">// Subtraction assignment</span></div><div class="line">F *= A * D;    <span class="comment">// Multiplication assignment</span></div></div><!-- fragment --> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aedda32d64e36bea6174372203dbc0a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedda32d64e36bea6174372203dbc0a9c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SIMD optimization. </p>
<p>The <em>simdEnabled</em> compilation flag indicates whether expressions the matrix is involved in can be optimized via SIMD operations. In case the element type of the matrix is a vectorizable data type, the <em>simdEnabled</em> compilation flag is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<a id="a3863e32a4cbbcfea52af2f32fd01fc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3863e32a4cbbcfea52af2f32fd01fc05">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SMP assignments. </p>
<p>The <em>smpAssignable</em> compilation flag indicates whether the matrix can be used in SMP (shared memory parallel) assignments (both on the left-hand and right-hand side of the assignment). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc34b9e3709c4cf64dd5971e47f805ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc34b9e3709c4cf64dd5971e47f805ec">&#9670;&nbsp;</a></span>CustomMatrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the array of elements. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the array of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates an unpadded custom matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. The construction fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...).</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is <b>NOT</b> available for padded custom matrices! </dd>
<dd>
The custom matrix does <b>NOT</b> take responsibility for the given array of elements! </dd></dl>

</div>
</div>
<a id="ae42dadf682945f2679297b9ff2cfd05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42dadf682945f2679297b9ff2cfd05a">&#9670;&nbsp;</a></span>CustomMatrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the array of elements. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the array of elements. </td></tr>
    <tr><td class="paramname">nn</td><td>The total number of elements between two rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a custom matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. The construction fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...);</li>
<li>... the specified spacing <em>nn</em> is insufficient for the given data type <em>Type</em> and the available instruction set.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The custom matrix does <b>NOT</b> take responsibility for the given array of elements! </dd></dl>

</div>
</div>
<a id="aa8c34d17f823dde9d82a425bc25e2250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c34d17f823dde9d82a425bc25e2250">&#9670;&nbsp;</a></span>CustomMatrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor initializes the custom matrix as an exact copy of the given custom matrix. </p>

</div>
</div>
<a id="a5ce97c4aab8a5a0b52df0c26917407ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce97c4aab8a5a0b52df0c26917407ed">&#9670;&nbsp;</a></span>CustomMatrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move constructor for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to be moved into this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6da4e5258121c5731ea25b2599b846c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da4e5258121c5731ea25b2599b846c6">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a697aa973c0aca3f96f28e59c4c34b4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697aa973c0aca3f96f28e59c4c34b4bd">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a532bb44cdd5f4526f37df279e17bac9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532bb44cdd5f4526f37df279e17bac9e">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="acf43081da01b257a55c93db4ba72abc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf43081da01b257a55c93db4ba72abc3">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a9ee25dc3fde653be82a40c6c7628a2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee25dc3fde653be82a40c6c7628a2b6">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a45c883d67f6088e112578ee45acf169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c883d67f6088e112578ee45acf169c">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a4fd75d04defa249106a2c407439190fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd75d04defa249106a2c407439190fe">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a72f33dc6204cda4335bee55df2a157e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f33dc6204cda4335bee55df2a157e4">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a2e9592bd117d5ccd7c7741d5060664f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9592bd117d5ccd7c7741d5060664f7">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a71134ad6527d6b9d16eec3eb36a45e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71134ad6527d6b9d16eec3eb36a45e0e">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="af13719677d367ec65b109fafba194dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13719677d367ec65b109fafba194dc8">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a467759dafbc79fac063a425ffe6e636d">Reference</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid matrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the subscript operator this function always performs a check of the given access indices. </p>

</div>
</div>
<a id="a3dd224ec923fa7a04aa9e88d15bd9aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd224ec923fa7a04aa9e88d15bd9aba">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8af06a455ecdaafd1f6ef1ddf0e45602">ConstReference</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid matrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the subscript operator this function always performs a check of the given access indices. </p>

</div>
</div>
<a id="a236b9d928133bb9bc81a51767888937e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236b9d928133bb9bc81a51767888937e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#afef7ced3ceb87c8b0bff0b851ec15067">Iterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="aab9b8cd66c5c3bb3d238cf994ce97bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9b8cd66c5c3bb3d238cf994ce97bc7">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="a3960be7b2021e03efbf9f871108dcec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3960be7b2021e03efbf9f871108dcec1">&#9670;&nbsp;</a></span>canAlias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this matrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the matrix. In contrast to the <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7cdbd9c2c456dda6de599d45f4f258d4" title="Returns whether the matrix is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a id="ad01e706dc572063db13fb8ceb61a85cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01e706dc572063db13fb8ceb61a85cf">&#9670;&nbsp;</a></span>canSMPAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the matrix can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current number of rows and/or columns of the matrix). </p>

</div>
</div>
<a id="ac9f462845b3727e3e688bb23d298c95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f462845b3727e3e688bb23d298c95f">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a id="aa2f8851b784db370d5b963c262fe9531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f8851b784db370d5b963c262fe9531">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a id="a4f83f5cf3bff0440baaf4573b9c6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f83f5cf3bff0440baaf4573b9c6ba3c">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a id="a1bd2e36203febb780846fe8249d16909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd2e36203febb780846fe8249d16909">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="a86ca06a74f9bf2233f62bb13b1c18d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ca06a74f9bf2233f62bb13b1c18d8e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the <img class="formulaInl" alt="$ M \times N $" src="../../form_29.png"/> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>After the <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a86ca06a74f9bf2233f62bb13b1c18d8e" title="Clearing the  matrix. ">clear()</a> function, the size of the matrix is 0. </p>

</div>
</div>
<a id="a83dd938bd5f731578c57771f2fae53ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dd938bd5f731578c57771f2fae53ef">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of columns of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a id="ad5d696e34013684a07a6f671f36f5303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d696e34013684a07a6f671f36f5303">&#9670;&nbsp;</a></span>ctranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::ctranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place conjugate transpose of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>Impossible transpose operation.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the matrix is not a square matrix, a <em>std::logic_error</em> exception is thrown. </p>

</div>
</div>
<a id="a899a5adfd74385f4c02d3f13d97749ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899a5adfd74385f4c02d3f13d97749ae">&#9670;&nbsp;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8a0b9cad82ee0f5834058cbf06e2799c">Pointer</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dynamic matrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dynamic matrix may use techniques such as padding to improve the alignment of the data. Whereas the number of elements within a row/column are given by the <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a1f6c7df24b32ffe46cf016c5aa096c62" title="Returns the current number of rows of the matrix. ">rows()</a></code> and <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a83dd938bd5f731578c57771f2fae53ef" title="Returns the current number of columns of the matrix. ">columns()</a></code> member functions, respectively, the total number of elements including padding is given by the <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a9e7cee36af52c0b35b3a2652961279a6" title="Returns the spacing between the beginning of two rows/columns. ">spacing()</a></code> member function. </p>

</div>
</div>
<a id="ae437d90881d10fc62aa0e056442ff94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae437d90881d10fc62aa0e056442ff94a">&#9670;&nbsp;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3cb30385840da2c793558f84add94f5d">ConstPointer</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dynamic matrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dynamic matrix may use techniques such as padding to improve the alignment of the data. Whereas the number of elements within a row/column are given by the <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a1f6c7df24b32ffe46cf016c5aa096c62" title="Returns the current number of rows of the matrix. ">rows()</a></code> and <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a83dd938bd5f731578c57771f2fae53ef" title="Returns the current number of columns of the matrix. ">columns()</a></code> member functions, respectively, the total number of elements including padding is given by the <code><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a9e7cee36af52c0b35b3a2652961279a6" title="Returns the spacing between the beginning of two rows/columns. ">spacing()</a></code> member function. </p>

</div>
</div>
<a id="a0a0255c2f20ef5267beabed47579bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0255c2f20ef5267beabed47579bbbb">&#9670;&nbsp;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8a0b9cad82ee0f5834058cbf06e2799c">Pointer</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage for the elements in row/column <em>i</em>. </p>

</div>
</div>
<a id="ae1c97ba770da3db635176a7bbb209f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c97ba770da3db635176a7bbb209f70">&#9670;&nbsp;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3cb30385840da2c793558f84add94f5d">ConstPointer</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage for the elements in row/column <em>i</em>. </p>

</div>
</div>
<a id="ada3aacaad32882156b38f1ce0c4a6edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3aacaad32882156b38f1ce0c4a6edc">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#afef7ced3ceb87c8b0bff0b851ec15067">Iterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="a19dc83e4b9b3867f369d109bfd7fd741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dc83e4b9b3867f369d109bfd7fd741">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a7f5abf098a59d93e042c2632cb45f7ae">ConstIterator</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a id="a7cdbd9c2c456dda6de599d45f4f258d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdbd9c2c456dda6de599d45f4f258d4">&#9670;&nbsp;</a></span>isAliased()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this matrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the matrix. In contrast to the <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a3960be7b2021e03efbf9f871108dcec1" title="Returns whether the matrix can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a id="a5be04d7bc7fc33faf7249583ba19df10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be04d7bc7fc33faf7249583ba19df10">&#9670;&nbsp;</a></span>isAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the matrix is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of each row/column of the matrix are guaranteed to conform to the alignment restrictions of the element type <em>Type</em>. </p>

</div>
</div>
<a id="a6c29fd4820e8f3049dd1dce98961ddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c29fd4820e8f3049dd1dce98961ddc0">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs a load of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller then the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="ae34f2a8b68558cab3c4164ccac430e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f2a8b68558cab3c4164ccac430e5b">&#9670;&nbsp;</a></span>loada()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::loada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned load of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs an aligned load of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="adb6c78efa61f63628f16b487ed2d7385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6c78efa61f63628f16b487ed2d7385">&#9670;&nbsp;</a></span>loadu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned load of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function performs an unaligned load of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a84b0db5192d1b713a1b4e288ad497f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b0db5192d1b713a1b4e288ad497f98">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of non-zero elements in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the dense matrix. </dd></dl>

</div>
</div>
<a id="ade409b7b2a58d1905edf06fe549405e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade409b7b2a58d1905edf06fe549405e8">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a id="a04441228a0f7e4f1c7f69c8fd039d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04441228a0f7e4f1c7f69c8fd039d5ae">&#9670;&nbsp;</a></span>operator%=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schur product assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A\circ=B $" src="../../form_32.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a39f6900abc46cb8e03ff9863c39779f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f6900abc46cb8e03ff9863c39779f4">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a467759dafbc79fac063a425ffe6e636d">Reference</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>This function only performs an index check in case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active. In contrast, the <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af13719677d367ec65b109fafba194dc8" title="Checked access to the matrix elements. ">at()</a> function is guaranteed to perform a check of the given access indices. </p>

</div>
</div>
<a id="a909936b58c659029e9d9902404a2a562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909936b58c659029e9d9902404a2a562">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::<a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a8af06a455ecdaafd1f6ef1ddf0e45602">ConstReference</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>This function only performs an index check in case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active. In contrast, the <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#af13719677d367ec65b109fafba194dc8" title="Checked access to the matrix elements. ">at()</a> function is guaranteed to perform a check of the given access indices. </p>

</div>
</div>
<a id="a790b9be36dc44ebbdbddb83d031014f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790b9be36dc44ebbdbddb83d031014f8">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_33.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="a86b27c659c78c2afa6a19cffd7cbfb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b27c659c78c2afa6a19cffd7cbfb87">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt; &gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_34.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a id="a0e9abeabd3ff2805ecb478ed2d9179db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9abeabd3ff2805ecb478ed2d9179db">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_30.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a2fcc8568f7a3a939fa03383abe3d05d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcc8568f7a3a939fa03383abe3d05d1">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_31.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="aacb835fff8042eb8d9d28f0fc42f7f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb835fff8042eb8d9d28f0fc42f7f12">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt; &gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_35.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a id="a8e21969cf61bad9ecec1b686404f0d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e21969cf61bad9ecec1b686404f0d7b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all matrix elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>

</div>
</div>
<a id="a96ed3884b1784de569bc5de60ed28dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ed3884b1784de569bc5de60ed28dbf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; <a class="el" href="../../d8/dd9/classblaze_1_1initializer__list.html">initializer_list</a>&lt; Type &gt; &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The initializer list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to static matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly assign to all elements of the matrix by means of an initializer list:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> array[9] = { 0, 0, 0,</div><div class="line">                       0, 0, 0,</div><div class="line">                       0, 0, 0 };</div><div class="line"><a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix&lt;int,unaligned,unpadded,rowMajor&gt;</a> A( array, 3UL, 3UL );</div><div class="line">A = { { 1, 2, 3 },</div><div class="line">      { 4, 5 },</div><div class="line">      { 7, 8, 9 } };</div></div><!-- fragment --><p>The matrix elements are assigned the values from the given initializer list. Missing values are initialized as default (as e.g. the value 6 in the example). Note that in case the size of the top-level initializer list exceeds the number of rows or the size of any nested list exceeds the number of columns, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="ac296e9415c9e0a438cf6e885ac9dc31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac296e9415c9e0a438cf6e885ac9dc31a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The matrix is initialized as a copy of the given matrix. In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a17ecb9ee4ee930555ec110d6c2154ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ecb9ee4ee930555ec110d6c2154ce3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html" title="Efficient implementation of a customizable matrix.The CustomMatrix class template provides the functi...">CustomMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>

</div>
</div>
<a id="a23bfa39d06bd0f66a1048a3557785fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bfa39d06bd0f66a1048a3557785fa6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t M, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[M][N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><img class="formulaInl" alt="$ M \times N $" src="../../form_29.png"/> dimensional array for the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid array size.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly set all elements of the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">blaze::unaligned</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> array[9] = { 0, 0, 0,</div><div class="line">                       0, 0, 0,</div><div class="line">                       0, 0, 0 };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> init[3][3] = { { 1, 2, 3 },</div><div class="line">                         { 4, 5 },</div><div class="line">                         { 7, 8, 9 } };</div><div class="line"><a class="code" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix&lt;int,unaligned,unpadded,rowMajor&gt;</a> A( array, 3UL, 3UL );</div><div class="line">A = init;</div></div><!-- fragment --><p>The matrix is assigned the values from the given array. Missing values are initialized with default values (as e.g. the value 6 in the example). Note that the size of the array must match the size of the custom matrix. Otherwise a <em>std::invalid_argument</em> exception is thrown. Also note that after the assignment <em>array</em> will have the same entries as <em>init</em>. </p>

</div>
</div>
<a id="a1a883334304710f5bc777b87d06a622d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a883334304710f5bc777b87d06a622d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The matrix is initialized as a copy of the given matrix. In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="a99fddd4e06d7ef0aaa9960c12089c4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fddd4e06d7ef0aaa9960c12089c4e5">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a id="a00af660c25d47d64c2beb7511329a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00af660c25d47d64c2beb7511329a3e5">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a id="aa0c63eea99b96e68d54572f3d060c53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c63eea99b96e68d54572f3d060c53a">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a86439f15a775922e0a29661656d84cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86439f15a775922e0a29661656d84cdf">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the specified row/column to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the values in the specified row/column to their default value. In case the storage order is set to <em>rowMajor</em> the function resets the values in row <em>i</em>, in case the storage order is set to <em>columnMajor</em> the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a id="ab7802f0469eba893a552582172a7b75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7802f0469eba893a552582172a7b75a">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the custom matrix and replaces the array of elements with the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the array of elements. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the array of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the custom matrix to the given array of elements of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. The function fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...).</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>This function is <b>NOT</b> available for padded custom matrices! </dd>
<dd>
In case a deleter was specified, the previously referenced array will only be destroyed when the last custom matrix referencing the array goes out of scope. </dd>
<dd>
The custom matrix does NOT take responsibility for the new array of elements! </dd></dl>

</div>
</div>
<a id="ac5b3df846e2942cef9de3dc5586a448a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b3df846e2942cef9de3dc5586a448a">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the custom matrix and replaces the array of elements with the given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The array of elements to be used by the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the array of elements. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the array of elements. </td></tr>
    <tr><td class="paramname">nn</td><td>The total number of elements between two rows/columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of custom matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the custom matrix to the given array of elements of size <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. The function fails if ...</p>
<ul>
<li>... the passed pointer is <code>nullptr</code>;</li>
<li>... the alignment flag <em>AF</em> is set to <em>aligned</em>, but the passed pointer is not properly aligned according to the available instruction set (SSE, AVX, ...).</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>In case a deleter was specified, the previously referenced array will only be destroyed when the last custom matrix referencing the array goes out of scope. </dd>
<dd>
The custom matrix does NOT take responsibility for the new array of elements! </dd></dl>

</div>
</div>
<a id="a1f6c7df24b32ffe46cf016c5aa096c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6c7df24b32ffe46cf016c5aa096c62">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of rows of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a id="adb77d523f95b73d39a97f065e85d9ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb77d523f95b73d39a97f065e85d9ac4">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;&amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the matrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix.</dd></dl>
<p>This function scales the matrix by applying the given scalar value <em>scalar</em> to each element of the matrix. For built-in and <code>complex</code> data types it has the same effect as using the multiplication assignment operator:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d32/classblaze_1_1CustomVector.html">blaze::CustomVector</a>;</div><div class="line"><span class="keyword">using</span> blaze::unaliged;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">blaze::unpadded</a>;</div><div class="line"></div><div class="line">CustomMatrix&lt;int,unaligned,unpadded&gt; A( ... );</div><div class="line"></div><div class="line">A *= 4;        <span class="comment">// Scaling of the matrix</span></div><div class="line">A.scale( 4 );  <span class="comment">// Same effect as above</span></div></div><!-- fragment --> 
</div>
</div>
<a id="abed069393df12931e7353da259733aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed069393df12931e7353da259733aee">&#9670;&nbsp;</a></span>schurAssign() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::schurAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the Schur product assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a4dab4de5897eb667dd8beee94a810f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dab4de5897eb667dd8beee94a810f05">&#9670;&nbsp;</a></span>schurAssign() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::schurAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the Schur product assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="aa1d82bfd467ee43cba316f1064ce53c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d82bfd467ee43cba316f1064ce53c6">&#9670;&nbsp;</a></span>schurAssign() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::schurAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the Schur product assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="ae628061045ed8d9954598a2a71a91006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae628061045ed8d9954598a2a71a91006">&#9670;&nbsp;</a></span>schurAssign() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedSchurAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::schurAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the Schur product assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a4aeb1d10c1218c9bdedc88642362a007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aeb1d10c1218c9bdedc88642362a007">&#9670;&nbsp;</a></span>schurAssign() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedSchurAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::schurAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the Schur product assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a9e7cee36af52c0b35b3a2652961279a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7cee36af52c0b35b3a2652961279a6">&#9670;&nbsp;</a></span>spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::spacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the spacing between the beginning of two rows/columns. </p>
<dl class="section return"><dt>Returns</dt><dd>The spacing between the beginning of two rows/columns.</dd></dl>
<p>This function returns the spacing between the beginning of two rows/columns, i.e. the total number of elements of a row/column. In case the storage order is set to <em>rowMajor</em> the function returns the spacing between two rows, in case the storage flag is set to <em>columnMajor</em> the function returns the spacing between two columns. </p>

</div>
</div>
<a id="af8259970b8a9cf4fb6cfa676921a9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8259970b8a9cf4fb6cfa676921a9040">&#9670;&nbsp;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs a store of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="aa4fd1f02a0aa1fb1c23c0c16d63a66ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fd1f02a0aa1fb1c23c0c16d63a66ec">&#9670;&nbsp;</a></span>storea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::storea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned store of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="af34be37c69ab822215d0e3558e92ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34be37c69ab822215d0e3558e92ceb4">&#9670;&nbsp;</a></span>storeu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned store of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a448a3c07f57382acee484270f3a9c76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448a3c07f57382acee484270f3a9c76a">&#9670;&nbsp;</a></span>stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html#a94730efe3f3ca8006f2d1db39afb9bac">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of a SIMD element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store of a specific SIMD element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the SIMD element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a8d5bd9baed6069eddfbcc93247040631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bd9baed6069eddfbcc93247040631">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a27e4426e8dfe3a988ca24df3e074455a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e4426e8dfe3a988ca24df3e074455a">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="acfcbcf34c1a2e460eb5d9b1e99b7ef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcbcf34c1a2e460eb5d9b1e99b7ef70">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a3282c0640f33e7087204a32fe14b5d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3282c0640f33e7087204a32fe14b5d04">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">DisableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a3e9d1abc4703c9ac6190e4e5d046f878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9d1abc4703c9ac6190e4e5d046f878">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;typename <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt;Type,AF,PF,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT&gt; &gt; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a2a20b4ff6765a27ea1e75312e2d54016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a20b4ff6765a27ea1e75312e2d54016">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a2350631eaa8d1ce0e9a464a5f4cd3b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2350631eaa8d1ce0e9a464a5f4cd3b28">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool AF, bool PF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">CustomMatrix</a>&lt; Type, AF, PF, SO &gt; &amp; <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place transpose of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>Impossible transpose operation.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the matrix is not a square matrix, a <em>std::logic_error</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a68878e9f9335a2afbb0e7b07ff25f763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68878e9f9335a2afbb0e7b07ff25f763">&#9670;&nbsp;</a></span>v_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool AF, bool PF, bool SO = defaultStorageOrder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="../../de/d43/classblaze_1_1CustomMatrix.html">blaze::CustomMatrix</a>&lt; Type, AF, PF, SO &gt;::v_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The custom array of elements. </p>
<p>Access to the matrix elements is gained via the function call operator. In case of row-major order the memory layout of the elements is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ N &amp; N+1 &amp; N+2 &amp; \cdots &amp; 2 \cdot N-1 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ M \cdot N-N &amp; M \cdot N-N+1 &amp; M \cdot N-N+2 &amp; \cdots &amp; M \cdot N-1 \\ \end{array}\right)\]" src="../../form_37.png"/>
</p>
<p>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/dense/<a class="el" href="../../dd/d83/dense_2CustomMatrix_8h_source.html">CustomMatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
