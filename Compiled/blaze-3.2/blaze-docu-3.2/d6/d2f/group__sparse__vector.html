<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Vectors<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d9/dd2/group__sparse__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd2/group__sparse__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/da9/group__compressed__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html">CompressedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">blaze::VectorAccessProxy&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br />
The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa395d51bc4927588b1e5f891f48bb774"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaa395d51bc4927588b1e5f891f48bb774"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa395d51bc4927588b1e5f891f48bb774">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa395d51bc4927588b1e5f891f48bb774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaa395d51bc4927588b1e5f891f48bb774">More...</a><br /></td></tr>
<tr class="separator:gaa395d51bc4927588b1e5f891f48bb774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b678a8f6af2e3a6a115cab83d3f0caa"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga6b678a8f6af2e3a6a115cab83d3f0caa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga6b678a8f6af2e3a6a115cab83d3f0caa">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6b678a8f6af2e3a6a115cab83d3f0caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga6b678a8f6af2e3a6a115cab83d3f0caa">More...</a><br /></td></tr>
<tr class="separator:ga6b678a8f6af2e3a6a115cab83d3f0caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bce1c81f985e9674c27289982bc835c"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:ga1bce1c81f985e9674c27289982bc835c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1bce1c81f985e9674c27289982bc835c">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga1bce1c81f985e9674c27289982bc835c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_109.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1bce1c81f985e9674c27289982bc835c">More...</a><br /></td></tr>
<tr class="separator:ga1bce1c81f985e9674c27289982bc835c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014d39d2c1ff2a5a5805fc8a690abf49"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga014d39d2c1ff2a5a5805fc8a690abf49"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga014d39d2c1ff2a5a5805fc8a690abf49">blaze::operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga014d39d2c1ff2a5a5805fc8a690abf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the componentwise division of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_100.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga014d39d2c1ff2a5a5805fc8a690abf49">More...</a><br /></td></tr>
<tr class="separator:ga014d39d2c1ff2a5a5805fc8a690abf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b3c3e8bfc80daa827b02da8c7b1d2b"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga83b3c3e8bfc80daa827b02da8c7b1d2b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga83b3c3e8bfc80daa827b02da8c7b1d2b">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga83b3c3e8bfc80daa827b02da8c7b1d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga83b3c3e8bfc80daa827b02da8c7b1d2b">More...</a><br /></td></tr>
<tr class="separator:ga83b3c3e8bfc80daa827b02da8c7b1d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190582f767f4e5183c2902ef8029ba5e"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga190582f767f4e5183c2902ef8029ba5e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga190582f767f4e5183c2902ef8029ba5e">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga190582f767f4e5183c2902ef8029ba5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga190582f767f4e5183c2902ef8029ba5e">More...</a><br /></td></tr>
<tr class="separator:ga190582f767f4e5183c2902ef8029ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cd4c15c18583182495fdb6b4e610df"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga38cd4c15c18583182495fdb6b4e610df"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga38cd4c15c18583182495fdb6b4e610df">blaze::eval</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga38cd4c15c18583182495fdb6b4e610df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga38cd4c15c18583182495fdb6b4e610df">More...</a><br /></td></tr>
<tr class="separator:ga38cd4c15c18583182495fdb6b4e610df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d88ed25e0cce091bc43fde2bd3112e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:ga47d88ed25e0cce091bc43fde2bd3112e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47d88ed25e0cce091bc43fde2bd3112e">blaze::map</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, OP op)</td></tr>
<tr class="memdesc:ga47d88ed25e0cce091bc43fde2bd3112e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga47d88ed25e0cce091bc43fde2bd3112e">More...</a><br /></td></tr>
<tr class="separator:ga47d88ed25e0cce091bc43fde2bd3112e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad850e6729ae5a9c161a47a23d297480b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename OP &gt; </td></tr>
<tr class="memitem:gad850e6729ae5a9c161a47a23d297480b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad850e6729ae5a9c161a47a23d297480b">blaze::forEach</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, OP op)</td></tr>
<tr class="memdesc:gad850e6729ae5a9c161a47a23d297480b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gad850e6729ae5a9c161a47a23d297480b">More...</a><br /></td></tr>
<tr class="separator:gad850e6729ae5a9c161a47a23d297480b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138a4ad14ff35e8a0202c77da9ee7f13"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga138a4ad14ff35e8a0202c77da9ee7f13"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga138a4ad14ff35e8a0202c77da9ee7f13">blaze::abs</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga138a4ad14ff35e8a0202c77da9ee7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga138a4ad14ff35e8a0202c77da9ee7f13">More...</a><br /></td></tr>
<tr class="separator:ga138a4ad14ff35e8a0202c77da9ee7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59431d25397d8a466909f21b48e0a938"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga59431d25397d8a466909f21b48e0a938"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga59431d25397d8a466909f21b48e0a938">blaze::floor</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga59431d25397d8a466909f21b48e0a938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga59431d25397d8a466909f21b48e0a938">More...</a><br /></td></tr>
<tr class="separator:ga59431d25397d8a466909f21b48e0a938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c72a5c9dc342048d132bfeb4d0c933"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa2c72a5c9dc342048d132bfeb4d0c933"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa2c72a5c9dc342048d132bfeb4d0c933">blaze::ceil</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa2c72a5c9dc342048d132bfeb4d0c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa2c72a5c9dc342048d132bfeb4d0c933">More...</a><br /></td></tr>
<tr class="separator:gaa2c72a5c9dc342048d132bfeb4d0c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872c7924a01aa0aae584e8277be5ead3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga872c7924a01aa0aae584e8277be5ead3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga872c7924a01aa0aae584e8277be5ead3">blaze::trunc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga872c7924a01aa0aae584e8277be5ead3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga872c7924a01aa0aae584e8277be5ead3">More...</a><br /></td></tr>
<tr class="separator:ga872c7924a01aa0aae584e8277be5ead3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad389b5b9e6c3428c20a81bbd1555ab9a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad389b5b9e6c3428c20a81bbd1555ab9a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad389b5b9e6c3428c20a81bbd1555ab9a">blaze::round</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad389b5b9e6c3428c20a81bbd1555ab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gad389b5b9e6c3428c20a81bbd1555ab9a">More...</a><br /></td></tr>
<tr class="separator:gad389b5b9e6c3428c20a81bbd1555ab9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c19de23aff5073073cf920d064cc1e4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7c19de23aff5073073cf920d064cc1e4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7c19de23aff5073073cf920d064cc1e4">blaze::conj</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga7c19de23aff5073073cf920d064cc1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the complex conjugate of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga7c19de23aff5073073cf920d064cc1e4">More...</a><br /></td></tr>
<tr class="separator:ga7c19de23aff5073073cf920d064cc1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a9645d50801d57e40858e951d0264b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga48a9645d50801d57e40858e951d0264b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga48a9645d50801d57e40858e951d0264b">blaze::ctrans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga48a9645d50801d57e40858e951d0264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose vector of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga48a9645d50801d57e40858e951d0264b">More...</a><br /></td></tr>
<tr class="separator:ga48a9645d50801d57e40858e951d0264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeec67f0ff032266b1fdb68564fc693f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gafeec67f0ff032266b1fdb68564fc693f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafeec67f0ff032266b1fdb68564fc693f">blaze::real</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gafeec67f0ff032266b1fdb68564fc693f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the real parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gafeec67f0ff032266b1fdb68564fc693f">More...</a><br /></td></tr>
<tr class="separator:gafeec67f0ff032266b1fdb68564fc693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8541699139ba0157a881b320b3338422"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga8541699139ba0157a881b320b3338422"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga8541699139ba0157a881b320b3338422">blaze::imag</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga8541699139ba0157a881b320b3338422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the imaginary parts of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga8541699139ba0157a881b320b3338422">More...</a><br /></td></tr>
<tr class="separator:ga8541699139ba0157a881b320b3338422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afbf318bde0df5073d0902a43aed0fd"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga5afbf318bde0df5073d0902a43aed0fd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga5afbf318bde0df5073d0902a43aed0fd">blaze::sqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga5afbf318bde0df5073d0902a43aed0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga5afbf318bde0df5073d0902a43aed0fd">More...</a><br /></td></tr>
<tr class="separator:ga5afbf318bde0df5073d0902a43aed0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813e1812e2cac549aef68c6ccc0d3cd9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga813e1812e2cac549aef68c6ccc0d3cd9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga813e1812e2cac549aef68c6ccc0d3cd9">blaze::invsqrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga813e1812e2cac549aef68c6ccc0d3cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga813e1812e2cac549aef68c6ccc0d3cd9">More...</a><br /></td></tr>
<tr class="separator:ga813e1812e2cac549aef68c6ccc0d3cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeed229e92a9ba40f6db3d31349f1b95"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gadeed229e92a9ba40f6db3d31349f1b95"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gadeed229e92a9ba40f6db3d31349f1b95">blaze::cbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gadeed229e92a9ba40f6db3d31349f1b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gadeed229e92a9ba40f6db3d31349f1b95">More...</a><br /></td></tr>
<tr class="separator:gadeed229e92a9ba40f6db3d31349f1b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eae3064e4229c793e139dda5161f73e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0eae3064e4229c793e139dda5161f73e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0eae3064e4229c793e139dda5161f73e">blaze::invcbrt</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga0eae3064e4229c793e139dda5161f73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga0eae3064e4229c793e139dda5161f73e">More...</a><br /></td></tr>
<tr class="separator:ga0eae3064e4229c793e139dda5161f73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f78aa1a9cb272c09540bceeaea8d8f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename DT &gt; </td></tr>
<tr class="memitem:ga60f78aa1a9cb272c09540bceeaea8d8f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga60f78aa1a9cb272c09540bceeaea8d8f">blaze::clamp</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga60f78aa1a9cb272c09540bceeaea8d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga60f78aa1a9cb272c09540bceeaea8d8f">More...</a><br /></td></tr>
<tr class="separator:ga60f78aa1a9cb272c09540bceeaea8d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c335c240ca38f92f7ef171c1b35519a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF, typename ET &gt; </td></tr>
<tr class="memitem:ga5c335c240ca38f92f7ef171c1b35519a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga5c335c240ca38f92f7ef171c1b35519a">blaze::pow</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv, ET <a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>)</td></tr>
<tr class="memdesc:ga5c335c240ca38f92f7ef171c1b35519a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga5c335c240ca38f92f7ef171c1b35519a">More...</a><br /></td></tr>
<tr class="separator:ga5c335c240ca38f92f7ef171c1b35519a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2680f034f76874e7e8bbc88e476ab4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga3b2680f034f76874e7e8bbc88e476ab4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3b2680f034f76874e7e8bbc88e476ab4">blaze::exp</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga3b2680f034f76874e7e8bbc88e476ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga3b2680f034f76874e7e8bbc88e476ab4">More...</a><br /></td></tr>
<tr class="separator:ga3b2680f034f76874e7e8bbc88e476ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30bb36ae7fc883daaa69dea220ca4f3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad30bb36ae7fc883daaa69dea220ca4f3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad30bb36ae7fc883daaa69dea220ca4f3">blaze::exp2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad30bb36ae7fc883daaa69dea220ca4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gad30bb36ae7fc883daaa69dea220ca4f3">More...</a><br /></td></tr>
<tr class="separator:gad30bb36ae7fc883daaa69dea220ca4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0ba778da6e0712f04b7118044a08f0"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaed0ba778da6e0712f04b7118044a08f0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaed0ba778da6e0712f04b7118044a08f0">blaze::exp10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaed0ba778da6e0712f04b7118044a08f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaed0ba778da6e0712f04b7118044a08f0">More...</a><br /></td></tr>
<tr class="separator:gaed0ba778da6e0712f04b7118044a08f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac09e1f496af9b1a3ea8e5c70936503d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaac09e1f496af9b1a3ea8e5c70936503d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaac09e1f496af9b1a3ea8e5c70936503d">blaze::log</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaac09e1f496af9b1a3ea8e5c70936503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaac09e1f496af9b1a3ea8e5c70936503d">More...</a><br /></td></tr>
<tr class="separator:gaac09e1f496af9b1a3ea8e5c70936503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc62ab77453f8081c0023eb356f2edc"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gadbc62ab77453f8081c0023eb356f2edc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gadbc62ab77453f8081c0023eb356f2edc">blaze::log2</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gadbc62ab77453f8081c0023eb356f2edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gadbc62ab77453f8081c0023eb356f2edc">More...</a><br /></td></tr>
<tr class="separator:gadbc62ab77453f8081c0023eb356f2edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658d75e8fbf5cde5c884b1852668ab2b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga658d75e8fbf5cde5c884b1852668ab2b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga658d75e8fbf5cde5c884b1852668ab2b">blaze::log10</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga658d75e8fbf5cde5c884b1852668ab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga658d75e8fbf5cde5c884b1852668ab2b">More...</a><br /></td></tr>
<tr class="separator:ga658d75e8fbf5cde5c884b1852668ab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade946c0a7beb893b5ff0a3bac70cd3a3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gade946c0a7beb893b5ff0a3bac70cd3a3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gade946c0a7beb893b5ff0a3bac70cd3a3">blaze::sin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gade946c0a7beb893b5ff0a3bac70cd3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gade946c0a7beb893b5ff0a3bac70cd3a3">More...</a><br /></td></tr>
<tr class="separator:gade946c0a7beb893b5ff0a3bac70cd3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade5abcb463781c4e7686765de99d13cd"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gade5abcb463781c4e7686765de99d13cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gade5abcb463781c4e7686765de99d13cd">blaze::asin</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gade5abcb463781c4e7686765de99d13cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gade5abcb463781c4e7686765de99d13cd">More...</a><br /></td></tr>
<tr class="separator:gade5abcb463781c4e7686765de99d13cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24ee6d4efb60b2aacc3486b1991736f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa24ee6d4efb60b2aacc3486b1991736f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa24ee6d4efb60b2aacc3486b1991736f">blaze::sinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa24ee6d4efb60b2aacc3486b1991736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa24ee6d4efb60b2aacc3486b1991736f">More...</a><br /></td></tr>
<tr class="separator:gaa24ee6d4efb60b2aacc3486b1991736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabefe2dbf3d7aa55b799d7b1510107a99"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gabefe2dbf3d7aa55b799d7b1510107a99"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabefe2dbf3d7aa55b799d7b1510107a99">blaze::asinh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gabefe2dbf3d7aa55b799d7b1510107a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gabefe2dbf3d7aa55b799d7b1510107a99">More...</a><br /></td></tr>
<tr class="separator:gabefe2dbf3d7aa55b799d7b1510107a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4fc3309bdf707b0a1935d4b627c04e"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2e4fc3309bdf707b0a1935d4b627c04e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2e4fc3309bdf707b0a1935d4b627c04e">blaze::cos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga2e4fc3309bdf707b0a1935d4b627c04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga2e4fc3309bdf707b0a1935d4b627c04e">More...</a><br /></td></tr>
<tr class="separator:ga2e4fc3309bdf707b0a1935d4b627c04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d814cf436d800f44976fdab07f2dab"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab3d814cf436d800f44976fdab07f2dab"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3d814cf436d800f44976fdab07f2dab">blaze::acos</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gab3d814cf436d800f44976fdab07f2dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gab3d814cf436d800f44976fdab07f2dab">More...</a><br /></td></tr>
<tr class="separator:gab3d814cf436d800f44976fdab07f2dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade38381c4a1d0bfc36ddf875cde0f435"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gade38381c4a1d0bfc36ddf875cde0f435"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gade38381c4a1d0bfc36ddf875cde0f435">blaze::cosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gade38381c4a1d0bfc36ddf875cde0f435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gade38381c4a1d0bfc36ddf875cde0f435">More...</a><br /></td></tr>
<tr class="separator:gade38381c4a1d0bfc36ddf875cde0f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60ea9b7c312a7eeea5aaccbfea09fc4"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf60ea9b7c312a7eeea5aaccbfea09fc4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaf60ea9b7c312a7eeea5aaccbfea09fc4">blaze::acosh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaf60ea9b7c312a7eeea5aaccbfea09fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaf60ea9b7c312a7eeea5aaccbfea09fc4">More...</a><br /></td></tr>
<tr class="separator:gaf60ea9b7c312a7eeea5aaccbfea09fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399bc2b1e669ac322121ed4838a96e7f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga399bc2b1e669ac322121ed4838a96e7f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga399bc2b1e669ac322121ed4838a96e7f">blaze::tan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga399bc2b1e669ac322121ed4838a96e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga399bc2b1e669ac322121ed4838a96e7f">More...</a><br /></td></tr>
<tr class="separator:ga399bc2b1e669ac322121ed4838a96e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545f01c5eeba27757b24ac87b114558a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga545f01c5eeba27757b24ac87b114558a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga545f01c5eeba27757b24ac87b114558a">blaze::atan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga545f01c5eeba27757b24ac87b114558a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga545f01c5eeba27757b24ac87b114558a">More...</a><br /></td></tr>
<tr class="separator:ga545f01c5eeba27757b24ac87b114558a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fad0366d91212eabef3b34fa3e5b2f"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga66fad0366d91212eabef3b34fa3e5b2f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga66fad0366d91212eabef3b34fa3e5b2f">blaze::tanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga66fad0366d91212eabef3b34fa3e5b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga66fad0366d91212eabef3b34fa3e5b2f">More...</a><br /></td></tr>
<tr class="separator:ga66fad0366d91212eabef3b34fa3e5b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137c022f2a5486bf06f4488e020a8697"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga137c022f2a5486bf06f4488e020a8697"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga137c022f2a5486bf06f4488e020a8697">blaze::atanh</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga137c022f2a5486bf06f4488e020a8697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga137c022f2a5486bf06f4488e020a8697">More...</a><br /></td></tr>
<tr class="separator:ga137c022f2a5486bf06f4488e020a8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a343c502334074dced94ddbc9c6212"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf0a343c502334074dced94ddbc9c6212"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaf0a343c502334074dced94ddbc9c6212">blaze::erf</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaf0a343c502334074dced94ddbc9c6212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gaf0a343c502334074dced94ddbc9c6212">More...</a><br /></td></tr>
<tr class="separator:gaf0a343c502334074dced94ddbc9c6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285abf7365eea3fcdf666b5adc85bfe9"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga285abf7365eea3fcdf666b5adc85bfe9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga285abf7365eea3fcdf666b5adc85bfe9">blaze::erfc</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga285abf7365eea3fcdf666b5adc85bfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function of each non-zero element of the sparse vector <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga285abf7365eea3fcdf666b5adc85bfe9">More...</a><br /></td></tr>
<tr class="separator:ga285abf7365eea3fcdf666b5adc85bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07691a2a7528bf0c43893347e22b65ab"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga07691a2a7528bf0c43893347e22b65ab"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga07691a2a7528bf0c43893347e22b65ab">blaze::operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;vec, ST scalar)</td></tr>
<tr class="memdesc:ga07691a2a7528bf0c43893347e22b65ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_105.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga07691a2a7528bf0c43893347e22b65ab">More...</a><br /></td></tr>
<tr class="separator:ga07691a2a7528bf0c43893347e22b65ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac255c52fee9a5590c1171b7074557c2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaac255c52fee9a5590c1171b7074557c2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaac255c52fee9a5590c1171b7074557c2">blaze::operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaac255c52fee9a5590c1171b7074557c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_106.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaac255c52fee9a5590c1171b7074557c2">More...</a><br /></td></tr>
<tr class="separator:gaac255c52fee9a5590c1171b7074557c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb31c6c51a14ce407ea27853ab96d900"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:gadb31c6c51a14ce407ea27853ab96d900"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gadb31c6c51a14ce407ea27853ab96d900">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;vec, ST scalar)</td></tr>
<tr class="memdesc:gadb31c6c51a14ce407ea27853ab96d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gadb31c6c51a14ce407ea27853ab96d900">More...</a><br /></td></tr>
<tr class="separator:gadb31c6c51a14ce407ea27853ab96d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713407d88e703d262f02491cf4da4e2e"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename VT , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga713407d88e703d262f02491cf4da4e2e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga713407d88e703d262f02491cf4da4e2e">blaze::operator*</a> (ST scalar, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga713407d88e703d262f02491cf4da4e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga713407d88e703d262f02491cf4da4e2e">More...</a><br /></td></tr>
<tr class="separator:ga713407d88e703d262f02491cf4da4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1523f1b0a61f66d0093d76996e2793a2"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1523f1b0a61f66d0093d76996e2793a2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1523f1b0a61f66d0093d76996e2793a2">blaze::serial</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga1523f1b0a61f66d0093d76996e2793a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse vector expression <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga1523f1b0a61f66d0093d76996e2793a2">More...</a><br /></td></tr>
<tr class="separator:ga1523f1b0a61f66d0093d76996e2793a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ea04ce094c8a8800330557f38aa7a6"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga40ea04ce094c8a8800330557f38aa7a6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga40ea04ce094c8a8800330557f38aa7a6">blaze::operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga40ea04ce094c8a8800330557f38aa7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga40ea04ce094c8a8800330557f38aa7a6">More...</a><br /></td></tr>
<tr class="separator:ga40ea04ce094c8a8800330557f38aa7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadaedfa24216f24adac7ae1e6c19833a"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaadaedfa24216f24adac7ae1e6c19833a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaadaedfa24216f24adac7ae1e6c19833a">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaadaedfa24216f24adac7ae1e6c19833a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaadaedfa24216f24adac7ae1e6c19833a">More...</a><br /></td></tr>
<tr class="separator:gaadaedfa24216f24adac7ae1e6c19833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe25b3cf20a237da55cfee9a637c4728"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:gafe25b3cf20a237da55cfee9a637c4728"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gafe25b3cf20a237da55cfee9a637c4728">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafe25b3cf20a237da55cfee9a637c4728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gafe25b3cf20a237da55cfee9a637c4728">More...</a><br /></td></tr>
<tr class="separator:gafe25b3cf20a237da55cfee9a637c4728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b82bc3359ce9099f2a358b8f63b223c"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3b82bc3359ce9099f2a358b8f63b223c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3b82bc3359ce9099f2a358b8f63b223c">blaze::operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3b82bc3359ce9099f2a358b8f63b223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga3b82bc3359ce9099f2a358b8f63b223c">More...</a><br /></td></tr>
<tr class="separator:ga3b82bc3359ce9099f2a358b8f63b223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86975801f5f17602be1f0e0f41f3280"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad86975801f5f17602be1f0e0f41f3280"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad86975801f5f17602be1f0e0f41f3280">blaze::trans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad86975801f5f17602be1f0e0f41f3280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gad86975801f5f17602be1f0e0f41f3280">More...</a><br /></td></tr>
<tr class="separator:gad86975801f5f17602be1f0e0f41f3280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab560241255736c7bf6bebc5be03ed414"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename VT &gt; </td></tr>
<tr class="memitem:gab560241255736c7bf6bebc5be03ed414"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab560241255736c7bf6bebc5be03ed414">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gab560241255736c7bf6bebc5be03ed414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gab560241255736c7bf6bebc5be03ed414">More...</a><br /></td></tr>
<tr class="separator:gab560241255736c7bf6bebc5be03ed414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a49ae222a3aa2dd83c2f143ffc54d6"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga19a49ae222a3aa2dd83c2f143ffc54d6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga19a49ae222a3aa2dd83c2f143ffc54d6">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga19a49ae222a3aa2dd83c2f143ffc54d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga19a49ae222a3aa2dd83c2f143ffc54d6">More...</a><br /></td></tr>
<tr class="separator:ga19a49ae222a3aa2dd83c2f143ffc54d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df8c469ccf63c5d2756843ae5925bcf"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga9df8c469ccf63c5d2756843ae5925bcf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9df8c469ccf63c5d2756843ae5925bcf">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9df8c469ccf63c5d2756843ae5925bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga9df8c469ccf63c5d2756843ae5925bcf">More...</a><br /></td></tr>
<tr class="separator:ga9df8c469ccf63c5d2756843ae5925bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector operators</h2></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">blaze::operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">More...</a><br /></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">blaze::operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">More...</a><br /></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector functions</h2></td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">blaze::isnan</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4490b16f3da675eb29db391adcf46f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse vector for not-a-number elements.  <a href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">More...</a><br /></td></tr>
<tr class="separator:ga4490b16f3da675eb29db391adcf46f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">blaze::isUniform</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa58862b9f216db8c76842cd7c649d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse vector is a uniform vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">More...</a><br /></td></tr>
<tr class="separator:gaa58862b9f216db8c76842cd7c649d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">blaze::sqrLength</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga26eb8f27519826300e4c6e05540f4f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the square length (magnitude) of the sparse vector <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_57.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#ga26eb8f27519826300e4c6e05540f4f7a">More...</a><br /></td></tr>
<tr class="separator:ga26eb8f27519826300e4c6e05540f4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa69b4ec965b7288218a79549c50b51db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">blaze::length</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv) -&gt; decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~sv)))</td></tr>
<tr class="memdesc:gaa69b4ec965b7288218a79549c50b51db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the length (magnitude) of the sparse vector <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_58.png"/>.  <a href="../../d6/d2f/group__sparse__vector.html#gaa69b4ec965b7288218a79549c50b51db">More...</a><br /></td></tr>
<tr class="separator:gaa69b4ec965b7288218a79549c50b51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">blaze::min</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gaa1c42aadfa3bdbe0be24df9ecd47c222">More...</a><br /></td></tr>
<tr class="separator:gaa1c42aadfa3bdbe0be24df9ecd47c222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad7f496dbc22cefdf5b31975f57271caf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">blaze::max</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad7f496dbc22cefdf5b31975f57271caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gad7f496dbc22cefdf5b31975f57271caf">More...</a><br /></td></tr>
<tr class="separator:gad7f496dbc22cefdf5b31975f57271caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
VectorAccessProxy global functions</h2></td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">blaze::reset</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4ccb520d1605428c703fb1e231984b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d6/d2f/group__sparse__vector.html#ga4ccb520d1605428c703fb1e231984b8a">More...</a><br /></td></tr>
<tr class="separator:ga4ccb520d1605428c703fb1e231984b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">blaze::clear</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga548f8ae65fde704870019a244c4aa68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d6/d2f/group__sparse__vector.html#ga548f8ae65fde704870019a244c4aa68d">More...</a><br /></td></tr>
<tr class="separator:ga548f8ae65fde704870019a244c4aa68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba3f019c98da133fbf9b16c2b53852f"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename VT &gt; </td></tr>
<tr class="memitem:gabba3f019c98da133fbf9b16c2b53852f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabba3f019c98da133fbf9b16c2b53852f">blaze::isDefault</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabba3f019c98da133fbf9b16c2b53852f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d6/d2f/group__sparse__vector.html#gabba3f019c98da133fbf9b16c2b53852f">More...</a><br /></td></tr>
<tr class="separator:gabba3f019c98da133fbf9b16c2b53852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e26ecb73b8bcfe8bd94a94919631411"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename VT &gt; </td></tr>
<tr class="memitem:ga8e26ecb73b8bcfe8bd94a94919631411"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga8e26ecb73b8bcfe8bd94a94919631411">blaze::isReal</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8e26ecb73b8bcfe8bd94a94919631411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector element represents a real number.  <a href="../../d6/d2f/group__sparse__vector.html#ga8e26ecb73b8bcfe8bd94a94919631411">More...</a><br /></td></tr>
<tr class="separator:ga8e26ecb73b8bcfe8bd94a94919631411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9f295f8179f7187eb3fca4974c522c"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename VT &gt; </td></tr>
<tr class="memitem:gabc9f295f8179f7187eb3fca4974c522c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gabc9f295f8179f7187eb3fca4974c522c">blaze::isZero</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabc9f295f8179f7187eb3fca4974c522c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d6/d2f/group__sparse__vector.html#gabc9f295f8179f7187eb3fca4974c522c">More...</a><br /></td></tr>
<tr class="separator:gabc9f295f8179f7187eb3fca4974c522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888d956abf65c37c5d4cae7e6d53dd70"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename VT &gt; </td></tr>
<tr class="memitem:ga888d956abf65c37c5d4cae7e6d53dd70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga888d956abf65c37c5d4cae7e6d53dd70">blaze::isOne</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga888d956abf65c37c5d4cae7e6d53dd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d6/d2f/group__sparse__vector.html#ga888d956abf65c37c5d4cae7e6d53dd70">More...</a><br /></td></tr>
<tr class="separator:ga888d956abf65c37c5d4cae7e6d53dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga577795ebd00f8faab87d16b964d158cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">blaze::isnan</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga577795ebd00f8faab87d16b964d158cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d6/d2f/group__sparse__vector.html#ga577795ebd00f8faab87d16b964d158cc">More...</a><br /></td></tr>
<tr class="separator:ga577795ebd00f8faab87d16b964d158cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gad2a932337ccd811dc6d27859066a47b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">blaze::swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gad2a932337ccd811dc6d27859066a47b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d6/d2f/group__sparse__vector.html#gad2a932337ccd811dc6d27859066a47b4">More...</a><br /></td></tr>
<tr class="separator:gad2a932337ccd811dc6d27859066a47b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga533b968699a6e37d569137d4481bcef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">blaze::swap</a> (const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga533b968699a6e37d569137d4481bcef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#ga533b968699a6e37d569137d4481bcef4">More...</a><br /></td></tr>
<tr class="separator:ga533b968699a6e37d569137d4481bcef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:gae1ec20cc3a5938208cd23728631130f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">blaze::swap</a> (T &amp;a, const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:gae1ec20cc3a5938208cd23728631130f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d6/d2f/group__sparse__vector.html#gae1ec20cc3a5938208cd23728631130f0">More...</a><br /></td></tr>
<tr class="separator:gae1ec20cc3a5938208cd23728631130f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga138a4ad14ff35e8a0202c77da9ee7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga138a4ad14ff35e8a0202c77da9ee7f13">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">abs</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab3d814cf436d800f44976fdab07f2dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d814cf436d800f44976fdab07f2dab">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">acos</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaf60ea9b7c312a7eeea5aaccbfea09fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60ea9b7c312a7eeea5aaccbfea09fc4">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">acosh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gade5abcb463781c4e7686765de99d13cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade5abcb463781c4e7686765de99d13cd">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">asin</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gabefe2dbf3d7aa55b799d7b1510107a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabefe2dbf3d7aa55b799d7b1510107a99">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">asinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga545f01c5eeba27757b24ac87b114558a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545f01c5eeba27757b24ac87b114558a">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">atan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga137c022f2a5486bf06f4488e020a8697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga137c022f2a5486bf06f4488e020a8697">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">atanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gadeed229e92a9ba40f6db3d31349f1b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeed229e92a9ba40f6db3d31349f1b95">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">cbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaa2c72a5c9dc342048d132bfeb4d0c933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2c72a5c9dc342048d132bfeb4d0c933">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">ceil</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga60f78aa1a9cb272c09540bceeaea8d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f78aa1a9cb272c09540bceeaea8d8f">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the sparse vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function resetricts each element of the input vector <em>sv</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">clamp</a>( a, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga548f8ae65fde704870019a244c4aa68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548f8ae65fde704870019a244c4aa68d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga7c19de23aff5073073cf920d064cc1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c19de23aff5073073cf920d064cc1e4">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the complex conjugate of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of each single element of <em>sv</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga2e4fc3309bdf707b0a1935d4b627c04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4fc3309bdf707b0a1935d4b627c04e">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">cos</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gade38381c4a1d0bfc36ddf875cde0f435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade38381c4a1d0bfc36ddf875cde0f435">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">cosh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga48a9645d50801d57e40858e951d0264b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48a9645d50801d57e40858e951d0264b">&#9670;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose vector of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>sv</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input vector <em>sv</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt; complex&lt;double&gt;</a> &gt; a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( a );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( a ) );  <span class="comment">// Computing the conjugate transpose vector</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gaf0a343c502334074dced94ddbc9c6212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a343c502334074dced94ddbc9c6212">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">erf</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga285abf7365eea3fcdf666b5adc85bfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285abf7365eea3fcdf666b5adc85bfe9">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">erfc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga38cd4c15c18583182495fdb6b4e610df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38cd4c15c18583182495fdb6b4e610df">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">eval</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3b2680f034f76874e7e8bbc88e476ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2680f034f76874e7e8bbc88e476ab4">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaed0ba778da6e0712f04b7118044a08f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed0ba778da6e0712f04b7118044a08f0">&#9670;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">exp10</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad30bb36ae7fc883daaa69dea220ca4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30bb36ae7fc883daaa69dea220ca4f3">&#9670;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">exp2</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga59431d25397d8a466909f21b48e0a938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59431d25397d8a466909f21b48e0a938">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">floor</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad850e6729ae5a9c161a47a23d297480b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad850e6729ae5a9c161a47a23d297480b">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">forEach</a>( a, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8541699139ba0157a881b320b3338422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8541699139ba0157a881b320b3338422">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the imaginary parts of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>sv</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0eae3064e4229c793e139dda5161f73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eae3064e4229c793e139dda5161f73e">&#9670;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">invcbrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga813e1812e2cac549aef68c6ccc0d3cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813e1812e2cac549aef68c6ccc0d3cd9">&#9670;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">invsqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gabba3f019c98da133fbf9b16c2b53852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabba3f019c98da133fbf9b16c2b53852f">&#9670;&nbsp;</a></span>isDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga4490b16f3da675eb29db391adcf46f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4490b16f3da675eb29db391adcf46f98">&#9670;&nbsp;</a></span>isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the given sparse vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional sparse vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( a ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for vectors with floating point elements. The attempt to use it for a vector with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga577795ebd00f8faab87d16b964d158cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577795ebd00f8faab87d16b964d158cc">&#9670;&nbsp;</a></span>isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is not a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in not a number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is not a number (NaN). In case it is not a number, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga888d956abf65c37c5d4cae7e6d53dd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga888d956abf65c37c5d4cae7e6d53dd70">&#9670;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 1, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 1. In case it is 1, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga8e26ecb73b8bcfe8bd94a94919631411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e26ecb73b8bcfe8bd94a94919631411">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector element represents a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector element represents a real number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the a real number. In case the element is of built-in type, the function returns <em>true</em>. In case the element is of complex type, the function returns <em>true</em> if the imaginary part is equal to 0. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaa58862b9f216db8c76842cd7c649d092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa58862b9f216db8c76842cd7c649d092">&#9670;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse vector is a uniform vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the vector is a uniform vector, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse vector is a uniform vector. The vector is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,blaze::columnVector&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( a ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a vector expression results in a uniform vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( a + b ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary vector. </p>

</div>
</div>
<a id="gabc9f295f8179f7187eb3fca4974c522c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc9f295f8179f7187eb3fca4974c522c">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 0, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 0. In case it is 0, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaa69b4ec965b7288218a79549c50b51db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69b4ec965b7288218a79549c50b51db">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto blaze::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td> -&gt;  decltype(<a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>(<a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32">sqrLength</a>(~sv)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the length (magnitude) of the sparse vector <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_58.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length (magnitude) of the sparse vector.</dd></dl>
<p>This function calculates the actual length (magnitude) of the sparse vector. The return type of the <a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f" title="Calculation of the length (magnitude) of the dense vector . ">length()</a> function depends on the actual element type of the vector instance:</p>
<table border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>Type</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
<tr>
<td>complex&lt;T&gt; </td><td>complex&lt;T&gt;  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga3585e479887969c9f815c0223fe5284f" title="Calculation of the length (magnitude) of the dense vector . ">length()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="gaac09e1f496af9b1a3ea8e5c70936503d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac09e1f496af9b1a3ea8e5c70936503d">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes the natural logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">log</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga658d75e8fbf5cde5c884b1852668ab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658d75e8fbf5cde5c884b1852668ab2b">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes the common logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">log10</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gadbc62ab77453f8081c0023eb356f2edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc62ab77453f8081c0023eb356f2edc">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logaritm of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes the binary logarithm for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">log2</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga47d88ed25e0cce091bc43fde2bd3112e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d88ed25e0cce091bc43fde2bd3112e">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given custom operation on each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( a, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad7f496dbc22cefdf5b31975f57271caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f496dbc22cefdf5b31975f57271caf">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse vector element.</dd></dl>
<p>This function returns the largest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<dl class="section note"><dt>Note</dt><dd>In case the compressed vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the maximum of this vector is 0:</dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} -1 &amp; 0 &amp; -3 &amp; 0 \\ \end{array}\right) \]" src="../../form_169.png"/>
</p>
 
</div>
</div>
<a id="gaa1c42aadfa3bdbe0be24df9ecd47c222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1c42aadfa3bdbe0be24df9ecd47c222">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse vector element.</dd></dl>
<p>This function returns the smallest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<dl class="section note"><dt>Note</dt><dd>In case the sparse vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the minimum of this vector is 0:</dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} 1 &amp; 0 &amp; 3 &amp; 0 \\ \end{array}\right) \]" src="../../form_168.png"/>
</p>
 
</div>
</div>
<a id="ga47bd825d8a1516cf16134c4dc9ac918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47bd825d8a1516cf16134c4dc9ac918a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gaa395d51bc4927588b1e5f891f48bb774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa395d51bc4927588b1e5f891f48bb774">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = a * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga190582f767f4e5183c2902ef8029ba5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga190582f767f4e5183c2902ef8029ba5e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga83b3c3e8bfc80daa827b02da8c7b1d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b3c3e8bfc80daa827b02da8c7b1d2b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = a * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gafe25b3cf20a237da55cfee9a637c4728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe25b3cf20a237da55cfee9a637c4728">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaadaedfa24216f24adac7ae1e6c19833a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadaedfa24216f24adac7ae1e6c19833a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two sparse vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">blaze::real</a> res;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>(a) * b;</div></div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1bce1c81f985e9674c27289982bc835c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bce1c81f985e9674c27289982bc835c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_109.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the sparse matrix type <em>MT</em> and the sparse vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab560241255736c7bf6bebc5be03ed414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab560241255736c7bf6bebc5be03ed414">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_85.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = A * x;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>MT::ElementType</em> and <em>VT::ElementType</em>. Both the sparse matrix type <em>MT</em> and the sparse vector type <em>VT</em> as well as the two element types <em>MT::ElementType</em> and <em>VT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga19a49ae222a3aa2dd83c2f143ffc54d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a49ae222a3aa2dd83c2f143ffc54d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the sparse vector type <em>VT</em> and the sparse matrix type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga9df8c469ccf63c5d2756843ae5925bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df8c469ccf63c5d2756843ae5925bcf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the sparse vector type <em>VT</em> and the sparse matrix type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga6b678a8f6af2e3a6a115cab83d3f0caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b678a8f6af2e3a6a115cab83d3f0caa">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gadb31c6c51a14ce407ea27853ab96d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb31c6c51a14ce407ea27853ab96d900">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_45.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a sparse vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a * 1.25;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>VT::ElementType</em> and <em>ST</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga713407d88e703d262f02491cf4da4e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713407d88e703d262f02491cf4da4e2e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST , typename VT , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = 1.25 * a;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>ST</em> and <em>VT::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga40ea04ce094c8a8800330557f38aa7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ea04ce094c8a8800330557f38aa7a6">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga3b82bc3359ce9099f2a358b8f63b223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b82bc3359ce9099f2a358b8f63b223c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_104.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a - b;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaac255c52fee9a5590c1171b7074557c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac255c52fee9a5590c1171b7074557c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_106.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = -a;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse vector. </p>

</div>
</div>
<a id="ga014d39d2c1ff2a5a5805fc8a690abf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014d39d2c1ff2a5a5805fc8a690abf49">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division operator for the componentwise division of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotient of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component quotient of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, c;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a / b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga07691a2a7528bf0c43893347e22b65ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07691a2a7528bf0c43893347e22b65ab">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ST , bool TF, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_105.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a sparse vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = a / 0.24;</div></div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>VT::ElementType</em> and <em>ST</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="ga3abacbc4a4ecdb439384f1ce2ae38246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3abacbc4a4ecdb439384f1ce2ae38246">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga5c335c240ca38f92f7ef171c1b35519a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c335c240ca38f92f7ef171c1b35519a">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gafeec67f0ff032266b1fdb68564fc693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeec67f0ff032266b1fdb68564fc693f">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the real parts of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>sv</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4ccb520d1605428c703fb1e231984b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ccb520d1605428c703fb1e231984b8a">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="gad389b5b9e6c3428c20a81bbd1555ab9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad389b5b9e6c3428c20a81bbd1555ab9a">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">round</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1523f1b0a61f66d0093d76996e2793a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1523f1b0a61f66d0093d76996e2793a2">&#9670;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">serial</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gade946c0a7beb893b5ff0a3bac70cd3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade946c0a7beb893b5ff0a3bac70cd3a3">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">sin</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa24ee6d4efb60b2aacc3486b1991736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa24ee6d4efb60b2aacc3486b1991736f">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">sinh</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga26eb8f27519826300e4c6e05540f4f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26eb8f27519826300e4c6e05540f4f7a">&#9670;&nbsp;</a></span>sqrLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt; blaze::sqrLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the square length (magnitude) of the sparse vector <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_57.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square length (magnitude) of the vector.</dd></dl>
<p>This function calculates the actual square length (magnitude) of the sparse vector.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga51d40e92bb2867d6d6b04ebbafd86b32" title="Calculation of the square length (magnitude) of the dense vector . ">sqrLength()</a> function results in a compile time error! </dd></dl>

</div>
</div>
<a id="ga5afbf318bde0df5073d0902a43aed0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5afbf318bde0df5073d0902a43aed0fd">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad2a932337ccd811dc6d27859066a47b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a932337ccd811dc6d27859066a47b4">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga533b968699a6e37d569137d4481bcef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga533b968699a6e37d569137d4481bcef4">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="gae1ec20cc3a5938208cd23728631130f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ec20cc3a5938208cd23728631130f0">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga399bc2b1e669ac322121ed4838a96e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399bc2b1e669ac322121ed4838a96e7f">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">tan</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga66fad0366d91212eabef3b34fa3e5b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66fad0366d91212eabef3b34fa3e5b2f">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each non-zero element of <em>sv</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">tanh</a>( a );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gad86975801f5f17602be1f0e0f41f3280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad86975801f5f17602be1f0e0f41f3280">&#9670;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the sparse vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( a );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga872c7924a01aa0aae584e8277be5ead3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872c7924a01aa0aae584e8277be5ead3">&#9670;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse vector <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse vector.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">trunc</a>( a );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:24 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
