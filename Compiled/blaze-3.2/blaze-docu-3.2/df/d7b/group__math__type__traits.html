<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of columns of a matrix.The <a class="el" href="../../d5/d84/structblaze_1_1Columns.html" title="Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...">Columns</a> type trait evaluates the number of columns of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of columns (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of columns. In all other cases, <em>value</em> is set to -1.  <a href="../../d5/d84/structblaze_1_1Columns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8c/structblaze_1_1HasAdd.html">blaze::HasAdd&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of an addition operator for the given data types.This type trait provides the information whether an addition operator (i.e. operator+) exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case the operator is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d8c/structblaze_1_1HasAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1HasConstDataAccess.html">blaze::HasConstDataAccess&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to constant data.This type trait tests whether the given data type provides a low-level access to constant data via a const 'data' member function. In case the according member function is provided, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/dd2/structblaze_1_1HasConstDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de7/structblaze_1_1HasDiv.html">blaze::HasDiv&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a division operator for the given data types.This type trait provides the information whether a division operator (i.e. operator/) exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case the operator is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/de7/structblaze_1_1HasDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d42/structblaze_1_1HasMax.html">blaze::HasMax&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a <a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a> operation for the given data types.This type trait provides the information whether a binary <a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a> operation exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case a binary <a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a> operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d42/structblaze_1_1HasMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d60/structblaze_1_1HasMin.html">blaze::HasMin&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a <a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a> operation for the given data types.This type trait provides the information whether a binary <a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a> operation exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case a binary <a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a> operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d60/structblaze_1_1HasMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dae/structblaze_1_1HasMult.html">blaze::HasMult&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a multiplication operator for the given data types.This type trait provides the information whether a multiplication operator (i.e. operator*) exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case the operator is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/dae/structblaze_1_1HasMult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html">blaze::HasMutableDataAccess&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to mutable data.This type trait tests whether the given data type provides a low-level access to mutable data via a non-const 'data' member function. In case the according member function is provided, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da7/structblaze_1_1HasSIMDAbs.html">blaze::HasSIMDAbs&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD absolute value operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD absolute value operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d7/da7/structblaze_1_1HasSIMDAbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc1/structblaze_1_1HasSIMDAcos.html">blaze::HasSIMDAcos&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/dc1/structblaze_1_1HasSIMDAcos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d75/structblaze_1_1HasSIMDAcosh.html">blaze::HasSIMDAcosh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse hyperbolic cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d75/structblaze_1_1HasSIMDAcosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/structblaze_1_1HasSIMDAdd.html">blaze::HasSIMDAdd&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD addition for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), and the used compiler, this type trait provides the information whether a SIMD addition operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD addition is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d8/dfc/structblaze_1_1HasSIMDAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d72/structblaze_1_1HasSIMDAsin.html">blaze::HasSIMDAsin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d72/structblaze_1_1HasSIMDAsin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d74/structblaze_1_1HasSIMDAsinh.html">blaze::HasSIMDAsinh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic inverse sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/d74/structblaze_1_1HasSIMDAsinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfc/structblaze_1_1HasSIMDAtan.html">blaze::HasSIMDAtan&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dfc/structblaze_1_1HasSIMDAtan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d35/structblaze_1_1HasSIMDAtanh.html">blaze::HasSIMDAtanh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse hyperbolic tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse hyperbolic tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d2/d35/structblaze_1_1HasSIMDAtanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de0/structblaze_1_1HasSIMDCbrt.html">blaze::HasSIMDCbrt&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD cubic root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD cubic root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../db/de0/structblaze_1_1HasSIMDCbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d06/structblaze_1_1HasSIMDCeil.html">blaze::HasSIMDCeil&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD ceil operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD ceil operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d3/d06/structblaze_1_1HasSIMDCeil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8d/structblaze_1_1HasSIMDConj.html">blaze::HasSIMDConj&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD conjugate operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD conjugate operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d9/d8d/structblaze_1_1HasSIMDConj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc0/structblaze_1_1HasSIMDCos.html">blaze::HasSIMDCos&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dc0/structblaze_1_1HasSIMDCos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d2c/structblaze_1_1HasSIMDCosh.html">blaze::HasSIMDCosh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic cosine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic cosine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dd/d2c/structblaze_1_1HasSIMDCosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d72/structblaze_1_1HasSIMDDiv.html">blaze::HasSIMDDiv&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD division for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD division operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD division is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d0/d72/structblaze_1_1HasSIMDDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd9/structblaze_1_1HasSIMDErf.html">blaze::HasSIMDErf&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD error function (<code>erf</code>) operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD error function (<code>erf</code>) operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../de/dd9/structblaze_1_1HasSIMDErf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfe/structblaze_1_1HasSIMDErfc.html">blaze::HasSIMDErfc&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD complementary error function (<code>erfc</code>) operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD complementary error function (<code>erfc</code>) operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d7/dfe/structblaze_1_1HasSIMDErfc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d62/structblaze_1_1HasSIMDExp.html">blaze::HasSIMDExp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/d62/structblaze_1_1HasSIMDExp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d02/structblaze_1_1HasSIMDExp10.html">blaze::HasSIMDExp10&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../df/d02/structblaze_1_1HasSIMDExp10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ded/structblaze_1_1HasSIMDExp2.html">blaze::HasSIMDExp2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></code> operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></code> operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d8/ded/structblaze_1_1HasSIMDExp2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3d/structblaze_1_1HasSIMDFloor.html">blaze::HasSIMDFloor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD floor operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD floor operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d1/d3d/structblaze_1_1HasSIMDFloor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db9/structblaze_1_1HasSIMDInvCbrt.html">blaze::HasSIMDInvCbrt&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse cubic root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse cubic root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d4/db9/structblaze_1_1HasSIMDInvCbrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/structblaze_1_1HasSIMDInvSqrt.html">blaze::HasSIMDInvSqrt&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD inverse square root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD inverse square root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d6/db1/structblaze_1_1HasSIMDInvSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d25/structblaze_1_1HasSIMDLog.html">blaze::HasSIMDLog&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD natural logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD natural logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d7/d25/structblaze_1_1HasSIMDLog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de2/structblaze_1_1HasSIMDLog10.html">blaze::HasSIMDLog10&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD common logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD common logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../db/de2/structblaze_1_1HasSIMDLog10.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd0/structblaze_1_1HasSIMDLog2.html">blaze::HasSIMDLog2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD binary logarithm operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD binary logarithm operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/dd0/structblaze_1_1HasSIMDLog2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d63/structblaze_1_1HasSIMDMax.html">blaze::HasSIMDMax&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD max operation for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), and the used compiler, this type trait provides the information whether a SIMD max operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d2/d63/structblaze_1_1HasSIMDMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db7/structblaze_1_1HasSIMDMin.html">blaze::HasSIMDMin&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD min operation for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), and the used compiler, this type trait provides the information whether a SIMD min operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../de/db7/structblaze_1_1HasSIMDMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/structblaze_1_1HasSIMDMult.html">blaze::HasSIMDMult&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD multiplication for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD multiplication operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD multiplication is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d3/de8/structblaze_1_1HasSIMDMult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da6/structblaze_1_1HasSIMDPow.html">blaze::HasSIMDPow&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD power operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD power operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dd/da6/structblaze_1_1HasSIMDPow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d45/structblaze_1_1HasSIMDRound.html">blaze::HasSIMDRound&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD round operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD round operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d0/d45/structblaze_1_1HasSIMDRound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d55/structblaze_1_1HasSIMDSin.html">blaze::HasSIMDSin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d0/d55/structblaze_1_1HasSIMDSin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de7/structblaze_1_1HasSIMDSinh.html">blaze::HasSIMDSinh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic sine operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic sine operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d9/de7/structblaze_1_1HasSIMDSinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df3/structblaze_1_1HasSIMDSqrt.html">blaze::HasSIMDSqrt&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD square root operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD square root operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../d8/df3/structblaze_1_1HasSIMDSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9c/structblaze_1_1HasSIMDSub.html">blaze::HasSIMDSub&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD subtraction for the given data types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD subtraction operation exists for the two given data types <em>T1</em> and <em>T2</em> (ignoring the cv-qualifiers). In case the SIMD subtraction is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that AVX is available:  <a href="../../de/d9c/structblaze_1_1HasSIMDSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfb/structblaze_1_1HasSIMDTan.html">blaze::HasSIMDTan&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../d3/dfb/structblaze_1_1HasSIMDTan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d01/structblaze_1_1HasSIMDTanh.html">blaze::HasSIMDTanh&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD hyperbolic tangent operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD hyperbolic tangent operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d01/structblaze_1_1HasSIMDTanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d75/structblaze_1_1HasSIMDTrunc.html">blaze::HasSIMDTrunc&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a SIMD trunc operation for the given data type.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...) and the used compiler, this type trait provides the information whether a SIMD trunc operation exists for the given data type <em>T</em> (ignoring the cv-qualifiers). In case the SIMD operation is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example assumes that the Intel SVML is available:  <a href="../../dc/d75/structblaze_1_1HasSIMDTrunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dee/structblaze_1_1HasSub.html">blaze::HasSub&lt; T1, T2, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of a subtraction operator for the given data types.This type trait provides the information whether a subtraction operator (i.e. operator+) exists for the two given data types <em>T1</em> and <em>T2</em> (taking the cv-qualifiers into account). In case the operator is available, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dee/structblaze_1_1HasSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">blaze::IsAdaptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for adaptors.This type trait tests whether the given template parameter is an adaptor type (for instance <em><a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a></em>, <em><a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a></em>, or <em><a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a></em>). In case the type is an adaptor type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example demonstrates this by means of the mentioned matrix adaptors:  <a href="../../d4/da2/structblaze_1_1IsAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html">blaze::IsAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an addition expression template.This type trait class tests whether or not the given type <em>Type</em> is an addition expression template (i.e. an expression representing a vector addition or a matrix addition). In order to qualify as a valid addition expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class. In case the given type is a valid addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d07/structblaze_1_1IsAligned.html">blaze::IsAligned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the alignment of data types.This type trait tests whether the given data type guarantees to provide aligned data values with respect to the requirements of the available instruction set. For instance, vectorizable data types such as built-in and complex data types are required to be 16-bit aligned for SSE, 32-bit aligned for AVX, and 64-bit aligned for MIC. In case the data type is properly aligned, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../de/d07/structblaze_1_1IsAligned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da4/structblaze_1_1IsBinaryMapExpr.html">blaze::IsBinaryMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a binary map expression template.This type trait class tests whether or not the given type <em>Type</em> is a binary map expression template. In order to qualify as a valid binary map expression template, the given type has to derive publicly from the <a class="el" href="../../db/d02/structblaze_1_1BinaryMapExpr.html" title="Base class for all for-each expression templates.The BinaryMapExpr class serves as a tag for all expr...">BinaryMapExpr</a> base class. In case the given type is a valid binary map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/da4/structblaze_1_1IsBinaryMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html">blaze::IsBLASCompatible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is a data type compatible to the BLAS standard. The BLAS standard supports <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> and <code>complex&lt;double&gt;</code> values. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type is BLAS compatible, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d1b/structblaze_1_1IsBLASCompatible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html">blaze::IsColumn&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for columns.This type trait tests whether or not the given template parameter is a column (i.e. dense or sparse column). In case the type is a column, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d61/structblaze_1_1IsColumn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">blaze::IsColumnMajorMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column-major matrix types.This type trait tests whether or not the given template argument is a column-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a column-major matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column vector types.This type trait tests whether or not the given template argument is a column dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a>). In case the type is a column vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d10/structblaze_1_1IsColumnVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">blaze::IsComputation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a computational expression template.This type trait class tests whether or not the given type <em>Type</em> is a computational expression template (i.e. a mathematical operation such as an addition, a subtraction, a multiplication, a division, an absolute value calculation, ...). In order to qualify as a valid computational expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class. In case the given type is a valid computational expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/daf/structblaze_1_1IsComputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html">blaze::IsCrossExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a cross product expression template.This type trait class tests whether or not the given type <em>Type</em> is a cross product expression template. In order to qualify as a valid cross product expression template, the given type has to derive publicly from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class. In case the given type is a valid cross product expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d43/structblaze_1_1IsCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/df1/structblaze_1_1IsCustom.html">blaze::IsCustom&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for custom data types.This type trait tests whether the given data type is a custom data type, i.e. a custom vector or a custom matrix. In case the data type a custom data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d1/df1/structblaze_1_1IsCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/ddc/structblaze_1_1IsDeclaration.html">blaze::IsDeclaration&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declaration expression template.This type trait class tests whether the given type <em>Type</em> is a declaration expression template. In order to qualify as a valid declaration expression template, the given type has to derive publicly from the <a class="el" href="../../d2/da2/structblaze_1_1Declaration.html" title="Base class for all declaration expression templates.The Declaration class serves as a tag for all dec...">Declaration</a> base class. In case the given type is a valid declaration expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/ddc/structblaze_1_1IsDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html">blaze::IsDeclDiagExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a decldiag expression template.This type trait class tests whether or not the given type <em>Type</em> is a decldiag expression template. In order to qualify as a valid decldiag expression template, the given type has to derive publicly from the <a class="el" href="../../dd/d42/structblaze_1_1DeclDiagExpr.html" title="Base class for all decldiag expression templates.The DeclDiagExpr class serves as a tag for all expre...">DeclDiagExpr</a> base class. In case the given type is a valid decldiag expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d3b/structblaze_1_1IsDeclDiagExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dce/structblaze_1_1IsDeclExpr.html">blaze::IsDeclExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declaration expression template.This type trait class tests whether or not the given type <em>Type</em> is a declaration expression template. In order to qualify as a valid declaration expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d56/structblaze_1_1DeclExpr.html" title="Base class for all matrix for-each expression templates.The DeclExpr class serves as a tag for all ex...">DeclExpr</a> base class. In case the given type is a valid declaration expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/dce/structblaze_1_1IsDeclExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html">blaze::IsDeclHermExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declherm expression template.This type trait class tests whether or not the given type <em>Type</em> is a declherm expression template. In order to qualify as a valid declherm expression template, the given type has to derive publicly from the <a class="el" href="../../dc/dc8/structblaze_1_1DeclHermExpr.html" title="Base class for all declherm expression templates.The DeclHermExpr class serves as a tag for all expre...">DeclHermExpr</a> base class. In case the given type is a valid declherm expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d07/structblaze_1_1IsDeclHermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html">blaze::IsDeclLowExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a decllow expression template.This type trait class tests whether or not the given type <em>Type</em> is a decllow expression template. In order to qualify as a valid decllow expression template, the given type has to derive publicly from the <a class="el" href="../../d0/d14/structblaze_1_1DeclLowExpr.html" title="Base class for all decllow expression templates.The DeclLowExpr class serves as a tag for all express...">DeclLowExpr</a> base class. In case the given type is a valid decllow expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d9e/structblaze_1_1IsDeclLowExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html">blaze::IsDeclSymExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declsym expression template.This type trait class tests whether or not the given type <em>Type</em> is a declsym expression template. In order to qualify as a valid declsym expression template, the given type has to derive publicly from the <a class="el" href="../../d8/db3/structblaze_1_1DeclSymExpr.html" title="Base class for all declsym expression templates.The DeclSymExpr class serves as a tag for all express...">DeclSymExpr</a> base class. In case the given type is a valid declsym expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d3d/structblaze_1_1IsDeclSymExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html">blaze::IsDeclUppExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a declupp expression template.This type trait class tests whether or not the given type <em>Type</em> is a declupp expression template. In order to qualify as a valid declupp expression template, the given type has to derive publicly from the <a class="el" href="../../d1/dcc/structblaze_1_1DeclUppExpr.html" title="Base class for all declupp expression templates.The DeclUppExpr class serves as a tag for all express...">DeclUppExpr</a> base class. In case the given type is a valid declupp expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/dc0/structblaze_1_1IsDeclUppExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">blaze::IsDenseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense matrix types.This type trait tests whether or not the given template parameter is a dense, N-dimensional matrix type. In case the type is a dense matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">blaze::IsDenseVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense vector types.This type trait tests whether or not the given template parameter is a dense, N-dimensional vector type. In case the type is a dense vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d50/structblaze_1_1IsDenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">blaze::IsDiagonal&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for diagonal matrices.This type trait tests whether or not the given template parameter is a diagonal matrix type (i.e. a matrix type that is guaranteed to be diagonal at compile time). In case the type is a diagonal matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d38/structblaze_1_1IsDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html">blaze::IsDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a division expression template.This type trait class tests whether or not the given type <em>Type</em> is a division expression template (i.e. an expression representing a vector/scalar division or a matrix/scalar division). In order to qualify as a valid division expression template, the given type has to derive publicly from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class. In case the given type is a valid division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d13/structblaze_1_1IsDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html">blaze::IsEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is an evaluation expression template. In order to qualify as a valid evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class. In case the given type is a valid evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d62/structblaze_1_1IsEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">blaze::IsExpression&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an expression template.This type trait class tests whether or not the given type <em>Type</em> is a Blaze expression template. In order to qualify as a valid expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class. In case the given type is a valid expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d44/structblaze_1_1IsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d23/structblaze_1_1IsGeneral.html">blaze::IsGeneral&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for general matrices.This type trait tests whether or not the given template parameter is a general matrix type (i.e. a matrix type that is neither symmetric, Hermitian, lower triangular or upper triangular at compile time). In case the type is a general matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d23/structblaze_1_1IsGeneral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/daf/structblaze_1_1IsHermitian.html">blaze::IsHermitian&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for Hermitian matrices.This type trait tests whether or not the given template parameter is an Hermitian matrix type (i.e. a matrix type that is guaranteed to be Hermitian at compile time). In case the type is a Hermitian matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/daf/structblaze_1_1IsHermitian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db0/structblaze_1_1IsIdentity.html">blaze::IsIdentity&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for identity matrices.This type trait tests whether or not the given template parameter is an identity matrix type (i.e. a matrix type that is guaranteed to be an identity matrix at compile time). In case the type is an identity matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/db0/structblaze_1_1IsIdentity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd5/structblaze_1_1IsInvertible.html">blaze::IsInvertible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is invertible. The type is considered to be invertible if it is either BLAS compatible (i.e. <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code>), <code>long double</code>, <code>complex&lt;long double&gt;</code> or any dense matrix type with a BLAS compatible element type. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the given type is invertible, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/dd5/structblaze_1_1IsInvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">blaze::IsLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower triangular matrices.This type trait tests whether or not the given template parameter is a lower triangular matrix type (i.e. a matrix type that is guaranteed to be lower triangular at compile time). This also includes lower unitriangular and strictly lower triangular matrices. In case the type is a lower triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d64/structblaze_1_1IsLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html">blaze::IsMatEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class. In case the given type is a valid matrix evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d49/structblaze_1_1IsMatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc6/structblaze_1_1IsMatInvExpr.html">blaze::IsMatInvExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix inversion expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix inversion expression template. In order to qualify as a valid matrix inversion expression template, the given type has to derive publicly from the <a class="el" href="../../d1/d0d/structblaze_1_1MatInvExpr.html" title="Base class for all matrix inversion expression templates.The MatInvExpr class serves as a tag for all...">MatInvExpr</a> base class. In case the given type is a valid matrix inversion expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/dc6/structblaze_1_1IsMatInvExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d62/structblaze_1_1IsMatMapExpr.html">blaze::IsMatMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a unary matrix map expression template.This type trait class tests whether or not the given type <em>Type</em> is a unary matrix map expression template. In order to qualify as a valid unary matrix map expression template, the given type has to derive publicly from the <a class="el" href="../../d4/d02/structblaze_1_1MatMapExpr.html" title="Base class for all unary matrix map expression templates.The MatMapExpr class serves as a tag for all...">MatMapExpr</a> base class. In case the given type is a valid unary matrix map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d62/structblaze_1_1IsMatMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">blaze::IsMatMatAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive publicly from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class. In case the given type is a valid matrix addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5a/structblaze_1_1IsMatMatMapExpr.html">blaze::IsMatMatMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a binary matrix map expression template.This type trait class tests whether or not the given type <em>Type</em> is a binary matrix map expression template. In order to qualify as a valid binary matrix map expression template, the given type has to derive publicly from the <a class="el" href="../../d7/dbb/structblaze_1_1MatMatMapExpr.html" title="Base class for all binary matrix map expression templates.The MatMatMapExpr class serves as a tag for...">MatMatMapExpr</a> base class. In case the given type is a valid binary matrix map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d3/d5a/structblaze_1_1IsMatMatMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">blaze::IsMatMatMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix multiplication expression template. In order to qualify as a valid matrix multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class. In case the given type is a valid matrix multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">blaze::IsMatMatSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix subtraction expression template. In order to qualify as a valid matrix subtraction expression template, the given type has to derive publicly from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class. In case the given type is a valid matrix subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for matrix types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse matrix type. In case the type is a matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d44/structblaze_1_1IsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html">blaze::IsMatScalarDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive publicly from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar division expression templates.The MatScalarDivExpr class serves as a...">MatScalarDivExpr</a> base class. In case the given type is a valid matrix/scalar division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html">blaze::IsMatScalarMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar multiplication expression template. In order to qualify as a valid matrix/scalar multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class. In case the given type is a valid matrix/scalar multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html">blaze::IsMatSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix serial evaluation expression template. In order to qualify as a valid matrix serial evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class. In case the given type is a valid matrix serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html">blaze::IsMatTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive publicly from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class. In case the given type is a valid matrix transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/da5/structblaze_1_1IsMatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">blaze::IsMatVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/vector multiplication expression template. In order to qualify as a valid matrix/vector multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class. In case the given type is a valid matrix/vector multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html">blaze::IsMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class. In case the given type is a valid multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/dd3/structblaze_1_1IsMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d83/structblaze_1_1IsNumericMatrix.html">blaze::IsNumericMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric matrix types.This type trait tests whether or not the given template parameter is a numeric matrix type, i.e. a matrix with numeric element type. In case the type is a numeric matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d83/structblaze_1_1IsNumericMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1f/structblaze_1_1IsNumericVector.html">blaze::IsNumericVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric vector types.This type trait tests whether or not the given template parameter is a numeric vector type, i.e. a vector with numeric element type. In case the type is a numeric vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d1f/structblaze_1_1IsNumericVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db0/structblaze_1_1IsOperation.html">blaze::IsOperation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an operational expression template.This type trait class tests whether or not the given type <em>Type</em> is either a transformation or a computational expression template. In order to qualify as a valid operational expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d9/d53/structblaze_1_1Operation.html" title="Base class for all operational expression templates.The Operation class serves as a tag for all opera...">Operation</a> base class. In case the given type is a valid operational expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/db0/structblaze_1_1IsOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddb/structblaze_1_1IsOpposedView.html">blaze::IsOpposedView&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is an opposed view, i.e. a view that is opposed to the natural storage order of its underlying type. In case the data type is an opposed view, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d8/ddb/structblaze_1_1IsOpposedView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d57/structblaze_1_1IsPadded.html">blaze::IsPadded&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types with padding.This type trait tests whether the given data type employs or simulates padding such that no special treatment of remainder elements is necessary for vectorized operations on the type. In case the data type is padded, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d2/d57/structblaze_1_1IsPadded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d54/structblaze_1_1IsProxy.html">blaze::IsProxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for proxy types.This type trait tests whether or not the given template parameter is a proxy type (i.e. publicly derived from the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">blaze::Proxy</a> class template). In case the type is a proxy, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d54/structblaze_1_1IsProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">blaze::IsResizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is a resizable data type. In case the data type can be resized (via the <a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a> function), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../db/d9b/structblaze_1_1IsResizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">blaze::IsRestricted&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types with restricted data access.This type trait tests whether the given data type has a restricted data access. Examples are the <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a> and <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a> adaptors that don't allow write access to the elements in the upper or lower part of the matrix, respectively. In case the data type has a restricted data access, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/df0/structblaze_1_1IsRestricted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/structblaze_1_1IsRow.html">blaze::IsRow&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for rows.This type trait tests whether or not the given template parameter is a row (i.e. dense or sparse row). In case the type is a row, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/da2/structblaze_1_1IsRow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">blaze::IsRowMajorMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row-major matrix types.This type trait tests whether or not the given template argument is a row-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a row-major matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row vector types.This type trait tests whether or not the given template argument is a row dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a>). In case the type is a row vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1c/structblaze_1_1IsRowVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7c/structblaze_1_1IsSchurExpr.html">blaze::IsSchurExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a Schur product expression template.This type trait class tests whether or not the given type <em>Type</em> is a Schur product expression template. In order to qualify as a valid Schur product expression template, the given type has to derive publicly from the <a class="el" href="../../d0/d24/structblaze_1_1SchurExpr.html" title="Base class for all Schur product expression templates.The SchurExpr class serves as a tag for all exp...">SchurExpr</a> base class. In case the given type is a valid Schur product expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d7c/structblaze_1_1IsSchurExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html">blaze::IsSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class. In case the given type is a valid serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d47/structblaze_1_1IsSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/structblaze_1_1IsShrinkable.html">blaze::IsShrinkable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for shrinkable data types.This type trait tests whether the given data type is a shrinkable data type. In case the data type can be shrunk (via the <a class="el" href="../../dd/d7a/group__matrix.html#gad6adfa525ee4758bcabfc8f8d28fe7ed" title="Requesting the removal of unused capacity. ">shrinkToFit()</a> function), the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../db/d56/structblaze_1_1IsShrinkable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d53/structblaze_1_1IsSIMDCombinable.html">blaze::IsSIMDCombinable&lt; T1, T2, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given types can be combined in the context of SIMD operations. By default, all numeric data types are considered combinable to themselves. Also, different integral types of the same size can be combined. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the types are determined to be SIMD combinable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d53/structblaze_1_1IsSIMDCombinable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html">blaze::IsSIMDEnabled&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given data type <em>T</em> is a SIMD-enabled data type (i.e. provides the according SIMD-related member functions, such as <code>load()</code>, store(), etc). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type is SIMD-enabled, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/ddc/structblaze_1_1IsSIMDEnabled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/structblaze_1_1IsSIMDPack.html">blaze::IsSIMDPack&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for SIMD data types.This type trait tests whether the given data type is a Blaze SIMD packed data type. The following types are considered valid SIMD packed types:  <a href="../../d5/d68/structblaze_1_1IsSIMDPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de3/structblaze_1_1IsSMPAssignable.html">blaze::IsSMPAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is an SMP-assignable data type (i.e. if it is a data type that can possibly and efficiently be assigned by several threads). In this context, built-in data types as well as complex numbers are non-SMP-assignable, whereas several vector and matrix types (as for instance <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">DynamicVector</a> and <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>) can be SMP-assignable. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the type is SMP-assignable, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/de3/structblaze_1_1IsSMPAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html">blaze::IsSparseElement&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a sparse element type.This type trait class tests whether or not the given type <em>Type</em> is a Blaze sparse element type, i.e. if the type implements the sparse element concept by providing a value() and an index() member function. In order to qualify as a valid sparse element type, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class. In case the given type is a valid sparse element, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d39/structblaze_1_1IsSparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">blaze::IsSparseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse matrix types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional matrix type. In case the type is a sparse matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d80/structblaze_1_1IsSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">blaze::IsSparseVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse vector types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional vector type. In case the type is a sparse vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/de1/structblaze_1_1IsSparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3b/structblaze_1_1IsSquare.html">blaze::IsSquare&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for square matrices.This type trait tests whether or not the given template parameter is a square matrix type (i.e. a matrix type that is guaranteed to be square at compile time). In case the type is a square matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d3b/structblaze_1_1IsSquare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/da3/structblaze_1_1IsStatic.html">blaze::IsStatic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for static data types.This type trait tests whether the given data type is a static data type, i.e. a vector or matrix with dimensions fixed at compile time. In case the data type a static data type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../d6/da3/structblaze_1_1IsStatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d49/structblaze_1_1IsStrictlyLower.html">blaze::IsStrictlyLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly lower triangular matrices.This type trait tests whether or not the given template parameter is a strictly lower triangular matrix type (i.e. a matrix type that is guaranteed to be strictly lower triangular at compile time). In case the type is a strictly lower triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d3/d49/structblaze_1_1IsStrictlyLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html">blaze::IsStrictlyTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly triangular matrix types.This type trait tests whether or not the given template parameter is a strictly lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/db5/structblaze_1_1IsStrictlyUpper.html">blaze::IsStrictlyUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly upper triangular matrices.This type trait tests whether or not the given template parameter is a strictly upper triangular matrix type (i.e. a matrix type that is guaranteed to be strictly upper triangular at compile time). In case the type is a strictly upper triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/db5/structblaze_1_1IsStrictlyUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html">blaze::IsSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a subtraction expression template (i.e. an expression representing a vector subtraction or a matrix subtraction). In order to qualify as a valid subtraction expression template, the given type has to derive publicly from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class. In case the given type is a valid subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d3f/structblaze_1_1IsSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html">blaze::IsSubmatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for submatrices.This type trait tests whether or not the given template parameter is a submatrix (i.e. dense or sparse submatrix). In case the type is a submatrix, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d1c/structblaze_1_1IsSubmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html">blaze::IsSubvector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for subvectors.This type trait tests whether or not the given template parameter is a subvector (i.e. dense or sparse subvector). In case the type is a subvector, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d9a/structblaze_1_1IsSubvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">blaze::IsSymmetric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for symmetric matrices.This type trait tests whether or not the given template parameter is a symmetric matrix type (i.e. a matrix type that is guaranteed to be symmetric at compile time). In case the type is a symmetric matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/db5/structblaze_1_1IsSymmetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dca/structblaze_1_1IsTemporary.html">blaze::IsTemporary&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a temporary vector or matrix type.This type trait class tests whether the given type is a temporary vector or matrix type, i.e. can be used for a temporary vector or matrix. In case the given type can be used as temporary, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dca/structblaze_1_1IsTemporary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">blaze::IsTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a transposition expression template (i.e. an expression representing a vector transposition or a matrix transposition). In order to qualify as a valid transposition expression template, the given type has to derive publicly from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class. In case the given type is a valid transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d04/structblaze_1_1IsTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9b/structblaze_1_1IsTransformation.html">blaze::IsTransformation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a transformation expression template.This type trait class tests whether the given type <em>Type</em> is a transformation expression template (e.g. a transpose operation). In order to qualify as a valid transformation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d1/d0a/structblaze_1_1Transformation.html" title="Base class for all transform expression templates.The Transformation class serves as a tag for all tr...">Transformation</a> base class. In case the given type is a valid transformation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d9b/structblaze_1_1IsTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d73/structblaze_1_1IsTriangular.html">blaze::IsTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for triangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d73/structblaze_1_1IsTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">blaze::IsTVecMatMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/matrix multiplication expression template. In order to qualify as a valid vector/matrix multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class. In case the given type is a valid vector/matrix multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d71/structblaze_1_1IsUnaryMapExpr.html">blaze::IsUnaryMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a unary map expression template.This type trait class tests whether or not the given type <em>Type</em> is a unary map expression template. In order to qualify as a valid unary map expression template, the given type has to derive publicly from the <a class="el" href="../../d0/d87/structblaze_1_1UnaryMapExpr.html" title="Base class for all for-each expression templates.The UnaryMapExpr class serves as a tag for all expre...">UnaryMapExpr</a> base class. In case the given type is a valid unary map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d71/structblaze_1_1IsUnaryMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/structblaze_1_1IsUniform.html">blaze::IsUniform&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for uniform vectors and matrices.This type trait tests whether or not the given template parameter is a uniform vector or matrix type (i.e. a data type that is guaranteed to be a uniform vector or matrix at compile time). In case the type is a uniform vector or matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dfc/structblaze_1_1IsUniform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d77/structblaze_1_1IsUniLower.html">blaze::IsUniLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower unitriangular matrices.This type trait tests whether or not the given template parameter is a lower unitriangular matrix type (i.e. a matrix type that is guaranteed to be lower unitriangular at compile time). In case the type is a lower unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d77/structblaze_1_1IsUniLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d70/structblaze_1_1IsUniTriangular.html">blaze::IsUniTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unitriangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper unitriangular matrix type. In case the type is an unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d70/structblaze_1_1IsUniTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddc/structblaze_1_1IsUniUpper.html">blaze::IsUniUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper unitriangular matrices.This type trait tests whether or not the given template parameter is an upper unitriangular matrix type (i.e. a matrix type that is guaranteed to be upper unitriangular at compile time). In case the type is an upper unitriangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/ddc/structblaze_1_1IsUniUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">blaze::IsUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper triangular matrices.This type trait tests whether or not the given template parameter is an upper triangular matrix type (i.e. a matrix type that is guaranteed to be upper triangular at compile time). This also includes upper unitriangular and strictly upper triangular matrices. In case the type is an upper triangular matrix type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d0e/structblaze_1_1IsUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html">blaze::IsVecEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class. In case the given type is a valid vector evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dcd/structblaze_1_1IsVecMapExpr.html">blaze::IsVecMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a unary vector map expression template.This type trait class tests whether or not the given type <em>Type</em> is a unary vector map expression template. In order to qualify as a valid unary vector map expression template, the given type has to derive publicly from the <a class="el" href="../../da/d4d/structblaze_1_1VecMapExpr.html" title="Base class for all unary vector map expression templates.The VecMapExpr class serves as a tag for all...">VecMapExpr</a> base class. In case the given type is a valid unary vector map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/dcd/structblaze_1_1IsVecMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html">blaze::IsVecScalarDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive publicly from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class. In case the given type is a valid vector/scalar division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html">blaze::IsVecScalarMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar multiplication expression template. In order to qualify as a valid vector/scalar multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class. In case the given type is a valid vector/scalar multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html">blaze::IsVecSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector serial evaluation expression template. In order to qualify as a valid vector serial evaluation expression template, the given type has to derive publicly from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class. In case the given type is a valid vector serial evaluation expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vector types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse vector type (i.e. whether <em>T</em> is derived from the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class). In case the type is a vector type, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/de4/structblaze_1_1IsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html">blaze::IsVecTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive publicly from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class. In case the given type is a valid vector transposition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html">blaze::IsVecTVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type <em>Type</em> is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive publicly from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class. In case the given type is a valid outer product expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">blaze::IsVecVecAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive publicly from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class. In case the given type is a valid vector addition expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html">blaze::IsVecVecDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector division expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector division expression template. In order to qualify as a valid vector division expression template, the given type has to derive publicly from the <a class="el" href="../../de/dc6/structblaze_1_1VecVecDivExpr.html" title="Base class for all vector/vector division expression templates.The VecVecDivExpr class serves as a ta...">VecVecDivExpr</a> base class. In case the given type is a valid vector division expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/ddd/structblaze_1_1IsVecVecDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d29/structblaze_1_1IsVecVecMapExpr.html">blaze::IsVecVecMapExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a binary vector map expression template.This type trait class tests whether or not the given type <em>Type</em> is a binary vector map expression template. In order to qualify as a valid binary vector map expression template, the given type has to derive publicly from the <a class="el" href="../../d9/d3c/structblaze_1_1VecVecMapExpr.html" title="Base class for all binary vector map expression templates.The VecVecMapExpr class serves as a tag for...">VecVecMapExpr</a> base class. In case the given type is a valid binary vector map expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d29/structblaze_1_1IsVecVecMapExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">blaze::IsVecVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector multiplication expression template. In order to qualify as a valid vector multiplication expression template, the given type has to derive publicly from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class. In case the given type is a valid vector multiplication expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">blaze::IsVecVecSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector subtraction expression template. In order to qualify as a valid vector subtraction expression template, the given type has to derive publicly from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class. In case the given type is a valid vector subtraction expression template, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structblaze_1_1IsView.html">blaze::IsView&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for views.This type trait tests whether or not the given template parameter is a view (i.e. subvector, submatrix, row, column, ...). In case the type is a view, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/dbb/structblaze_1_1IsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">blaze::RemoveAdaptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level adaptor types.In case the given type is an adaptor type (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a>, <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a>, <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a>, ...), the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved.  <a href="../../d2/d34/structblaze_1_1RemoveAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">blaze::RequiresEvaluation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check to query the requirement to evaluate an expression.Via this type trait it is possible to determine whether a given vector or matrix expression type requires an intermediate evaluation in the context of a compound expression. In case the given type requires an evaluation, the <em>value</em> member constant is set to <em>true</em>, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to <em>false</em>, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/df1/structblaze_1_1RequiresEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of rows of a matrix.The <a class="el" href="../../d2/d38/structblaze_1_1Rows.html" title="Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...">Rows</a> type trait evaluates the number of rows of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of rows (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of rows. In all other cases, <em>value</em> is set to -1.  <a href="../../d2/d38/structblaze_1_1Rows.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the size of a vector.The <a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> type trait evaluates the size of the given vector type at compile time. In case the given type <em>T</em> is a vector type with a fixed size (e.g. <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>), the <em>value</em> member constant is set to the according size. In all other cases, <em>value</em> is set to -1.  <a href="../../df/d5d/structblaze_1_1Size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d34/structblaze_1_1StorageOrder.html">blaze::StorageOrder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the storage order of a given matrix type.Via this type trait it is possible to evaluate the storage order of a given matrix type. In case the given type is a row-major matrix type the nested boolean <em>value</em> is set to <em>rowMajor</em>, in case it is a column-major matrix type it is set to <em>columnMajor</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the given type is not a matrix type a compilation error is created.  <a href="../../d9/d34/structblaze_1_1StorageOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd9/structblaze_1_1TransposeFlag.html">blaze::TransposeFlag&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the transpose flag of a given matrix type.Via this type trait it is possible to evaluate the transpose flag of a given vector type. In case the given type is a row vector type the nested boolean <em>value</em> is set to <em>rowVector</em>, in case it is a column vector type it is set to <em>columnVector</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the given type is not a vector type a compilation error is created.  <a href="../../d5/dd9/structblaze_1_1TransposeFlag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html">blaze::UnderlyingBuiltin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the underlying builtin element type of a given data type.Via this type trait it is possible to evaluate the underlying fundamental element type at the heart of a given data type. Examples:  <a href="../../dd/df8/structblaze_1_1UnderlyingBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/structblaze_1_1UnderlyingElement.html">blaze::UnderlyingElement&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the element type of a given data type.Via this type trait it is possible to evaluate the element type of a given data type. Examples:  <a href="../../d5/d7f/structblaze_1_1UnderlyingElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html">blaze::UnderlyingNumeric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the underlying numeric element type of a given data type.Via this type trait it is possible to evaluate the underlying numeric (fundamental or complex) element type at the heart of a given data type. Examples:  <a href="../../d7/dc0/structblaze_1_1UnderlyingNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae78e84ad2d4754c61849fea6f655bc3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#gae78e84ad2d4754c61849fea6f655bc3c">BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME,  FALLBACK_TYPE)</td></tr>
<tr class="memdesc:gae78e84ad2d4754c61849fea6f655bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait to acquire member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine a specified member type of a given type. The first macro parameter <em>TYPE_TRAIT_NAME</em> specifies the resulting name of the type trait. The second parameter <em>MEMBER_NAME</em> specifies the name of the member type to be acquired and the third parameter <em>FALLBACK_TYPE</em> specifies the type to acquire in case the given type doesn't contain the specified member type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#gae78e84ad2d4754c61849fea6f655bc3c">More...</a><br /></td></tr>
<tr class="separator:gae78e84ad2d4754c61849fea6f655bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d6498ed642ed01877d13b18f0018f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:ga82d6498ed642ed01877d13b18f0018f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for member data and functions.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data or function member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#ga82d6498ed642ed01877d13b18f0018f3">More...</a><br /></td></tr>
<tr class="separator:ga82d6498ed642ed01877d13b18f0018f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fd093b1a136bd309fe16f1131cd696"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:gab7fd093b1a136bd309fe16f1131cd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a type member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#gab7fd093b1a136bd309fe16f1131cd696">More...</a><br /></td></tr>
<tr class="separator:gab7fd093b1a136bd309fe16f1131cd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for members.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data, function, or type member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#ga9becd5ca22b660221bf10e0709f4c5f9">More...</a><br /></td></tr>
<tr class="separator:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae78e84ad2d4754c61849fea6f655bc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae78e84ad2d4754c61849fea6f655bc3c">&#9670;&nbsp;</a></span>BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FALLBACK_TYPE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div><div class="line">template&lt; typename Type1233 &gt;                                                                   \</div><div class="line">struct TYPE_TRAIT_NAME                                                                          \</div><div class="line">{                                                                                               \</div><div class="line"> private:                                                                                       \</div><div class="line">   struct SUCCESS { <span class="keyword">using</span> Type = <span class="keyword">typename</span> Type1233::MEMBER_NAME; };                             \</div><div class="line">   struct FAILURE { <span class="keyword">using</span> Type = FALLBACK_TYPE; };                                              <a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">\</a></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">                                                                                                \</a></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">   BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( LOCAL_TYPE_TRAIT, MEMBER_NAME );                    \</div><div class="line">                                                                                                \</div><div class="line"> public:                                                                                        \</div><div class="line">   using Type = <span class="keyword">typename</span> <a class="code" href="../../d7/d0c/structblaze_1_1If.html">blaze::If&lt; LOCAL_TYPE_TRAIT&lt;Type1233&gt;</a>                                  \</div><div class="line">                                  , SUCCESS                                                     \</div><div class="line">                                  , FAILURE                                                     \</div><div class="line">                                  &gt;::Type::Type;                                                \</div><div class="line">};</div><div class="ttc" id="structblaze_1_1If_html"><div class="ttname"><a href="../../d7/d0c/structblaze_1_1If.html">blaze::If</a></div><div class="ttdoc">Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...</div><div class="ttdef"><b>Definition:</b> If.h:132</div></div>
<div class="ttc" id="group__math__type__traits_html_gab7fd093b1a136bd309fe16f1131cd696"><div class="ttname"><a href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a></div><div class="ttdeci">#define BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT(TYPE_TRAIT_NAME, MEMBER_NAME)</div><div class="ttdoc">Macro for the creation of a type trait for compile time checks for member types.This macro creates th...</div><div class="ttdef"><b>Definition:</b> HasMember.h:182</div></div>
</div><!-- fragment -->
<p>Macro for the creation of a type trait to acquire member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine a specified member type of a given type. The first macro parameter <em>TYPE_TRAIT_NAME</em> specifies the resulting name of the type trait. The second parameter <em>MEMBER_NAME</em> specifies the name of the member type to be acquired and the third parameter <em>FALLBACK_TYPE</em> specifies the type to acquire in case the given type doesn't contain the specified member type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyType1 {</div><div class="line">   <span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#aa1c8d2bfd3e233c5f257e035a87a870f">ElementType</a> = float;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>MyType2 {</div><div class="line">   <span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#aa1c8d2bfd3e233c5f257e035a87a870f">ElementType</a> = double;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>MyType3 {};</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gae78e84ad2d4754c61849fea6f655bc3c">BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</a>( GetElementType, <a class="code" href="../../d2/de9/namespaceblaze.html#aa1c8d2bfd3e233c5f257e035a87a870f">ElementType</a>, <span class="keywordtype">int</span> );</div><div class="line"></div><div class="line">GetElementType&lt;MyType1&gt;::Type  <span class="comment">// Results in &#39;float&#39;</span></div><div class="line">GetElementType&lt;MyType2&gt;::Type  <span class="comment">// Results in &#39;double&#39;</span></div><div class="line">GetElementType&lt;MyType3&gt;::Type  <span class="comment">// Results in &#39;int&#39;</span></div></div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
<a id="ga82d6498ed642ed01877d13b18f0018f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d6498ed642ed01877d13b18f0018f3">&#9670;&nbsp;</a></span>BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the creation of a type trait for compile time checks for member data and functions.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data or function member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyType {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keywordtype">void</span> publicCompute();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">   <span class="keywordtype">void</span> privateCompute();</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span> value_;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasPublicCompute , publicCompute  );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasPrivateCompute, privateCompute );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasValue         , value_         );</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasEvaluate , evalute   );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasDetermine, determine );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( HasData     , data_     );</div><div class="line"></div><div class="line">HasPublicCompute&lt;MyType&gt;::value  <span class="comment">// Evaluates to &#39;true&#39;</span></div><div class="line">HasPrivateCompute&lt;MyType&gt;::Type  <span class="comment">// Results in TrueType</span></div><div class="line">HasValue&lt;MyType&gt;                 <span class="comment">// Is derived from TrueType</span></div><div class="line">HasEvaluate&lt;MyType&gt;::value       <span class="comment">// Evaluates to &#39;false&#39;</span></div><div class="line">HasDetermine&lt;MyType&gt;::Type       <span class="comment">// Results in FalseType</span></div><div class="line">HasData&lt;MyType&gt;                  <span class="comment">// Is derived from FalseType</span></div></div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope. </p>

</div>
</div>
<a id="ga9becd5ca22b660221bf10e0709f4c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9becd5ca22b660221bf10e0709f4c5f9">&#9670;&nbsp;</a></span>BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div><div class="line">template&lt; typename Type1232 &gt;                                                               \</div><div class="line">struct TYPE_TRAIT_NAME##HELPER                                                              \</div><div class="line">{                                                                                           \</div><div class="line"> private:                                                                                   \</div><div class="line">   BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( LOCAL_TYPE_TRAIT_1, MEMBER_NAME );  \</div><div class="line">   BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( LOCAL_TYPE_TRAIT_2, MEMBER_NAME );              \</div><div class="line">                                                                                            \</div><div class="line"> public:                                                                                    \</div><div class="line">   static constexpr <span class="keywordtype">bool</span> value = ( LOCAL_TYPE_TRAIT_1&lt;Type1232&gt;::value ||                   \</div><div class="line">                                   LOCAL_TYPE_TRAIT_2&lt;Type1232&gt;::value );                   \</div><div class="line">};                                                                                          \</div><div class="line">                                                                                            \</div><div class="line">template&lt; typename Type1232 &gt;                                                               \</div><div class="line">struct TYPE_TRAIT_NAME                                                                      \</div><div class="line">   : <span class="keyword">public</span> <a class="code" href="../../de/d59/structblaze_1_1IntegralConstant.html">blaze::BoolConstant&lt; TYPE_TRAIT_NAME##HELPER&lt;Type1232&gt;::value</a> &gt;                 \</div><div class="line">{}</div><div class="ttc" id="structblaze_1_1IntegralConstant_html"><div class="ttname"><a href="../../de/d59/structblaze_1_1IntegralConstant.html">blaze::IntegralConstant</a></div><div class="ttdoc">Generic wrapper for a compile time constant integral value.The IntegralConstant class template repres...</div><div class="ttdef"><b>Definition:</b> IntegralConstant.h:71</div></div>
</div><!-- fragment -->
<p>Macro for the creation of a type trait for compile time checks for members.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data, function, or type member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyType {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keywordtype">void</span> publicCompute();</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">   <span class="keyword">using</span> ProtectedType = float;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">   <span class="keywordtype">int</span> value_;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasCompute      , publicCompute );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasProtectedType, ProtectedType );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasValue        , value_        );</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasPublicType, PublicType );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasDetermine , determine  );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>( HasData      , data_      );</div><div class="line"></div><div class="line">HasCompute&lt;MyType&gt;::value       <span class="comment">// Evaluates to &#39;true&#39;</span></div><div class="line">HasProtectedType&lt;MyType&gt;::Type  <span class="comment">// Results in TrueType</span></div><div class="line">HasValue&lt;MyType&gt;                <span class="comment">// Is derived from TrueType</span></div><div class="line">HasPublicType&lt;MyType&gt;::value    <span class="comment">// Evaluates to &#39;false&#39;</span></div><div class="line">HasDetermine&lt;MyType&gt;::Type      <span class="comment">// Results in FalseType</span></div><div class="line">HasData&lt;MyType&gt;                 <span class="comment">// Is derived from FalseType</span></div></div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
<a id="gab7fd093b1a136bd309fe16f1131cd696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7fd093b1a136bd309fe16f1131cd696">&#9670;&nbsp;</a></span>BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the creation of a type trait for compile time checks for member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a type member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyType {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keyword">using</span> PublicType = int;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">   <span class="keyword">using</span> ProtectedType = float;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">   <span class="keyword">using</span> PrivateType = double;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasPublicType   , PublicType    );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasProtectedType, ProtectedType );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasPrivateType  , PrivateType   );</div><div class="line"></div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasValueType  , ValueType    );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasElementType, ElementTypeType );</div><div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( HasDataType   , DataType   );</div><div class="line"></div><div class="line">HasPublicType&lt;MyType&gt;::value    <span class="comment">// Evaluates to &#39;true&#39;</span></div><div class="line">HasProtectedType&lt;MyType&gt;::Type  <span class="comment">// Results in TrueType</span></div><div class="line">HasPrivateType&lt;MyType&gt;          <span class="comment">// Is derived from TrueType</span></div><div class="line">HasValueType&lt;MyType&gt;::value     <span class="comment">// Evaluates to &#39;false&#39;</span></div><div class="line">HasElementType&lt;MyType&gt;::Type    <span class="comment">// Results in FalseType</span></div><div class="line">HasDataType&lt;MyType&gt;             <span class="comment">// Is derived from FalseType</span></div></div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:25 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
