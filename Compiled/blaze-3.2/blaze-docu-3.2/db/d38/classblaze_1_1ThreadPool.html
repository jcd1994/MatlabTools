<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::ThreadPool&lt; TT, MT, LT, CT &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d8/d0d/classblaze_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::ThreadPool&lt; TT, MT, LT, CT &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a> &raquo; <a class="el" href="../../d2/db9/group__threads.html">Thread parallelization</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a thread pool.  
 <a href="../../db/d38/classblaze_1_1ThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d3/d43/ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">blaze::NonCopyable</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a5fb200ed35908231bba1d72a71c78c17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a5fb200ed35908231bba1d72a71c78c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class.  <a href="#a5fb200ed35908231bba1d72a71c78c17">More...</a><br /></td></tr>
<tr class="separator:a5fb200ed35908231bba1d72a71c78c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a8dd5edaab373a5115f1570d8dcacfc00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a8dd5edaab373a5115f1570d8dcacfc00">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a8dd5edaab373a5115f1570d8dcacfc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class.  <a href="#a8dd5edaab373a5115f1570d8dcacfc00">More...</a><br /></td></tr>
<tr class="separator:a8dd5edaab373a5115f1570d8dcacfc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get functions</div></td></tr>
<tr class="memitem:ab215294158a55a97c053ec3fa666f76f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ab215294158a55a97c053ec3fa666f76f">isEmpty</a> () const</td></tr>
<tr class="memdesc:ab215294158a55a97c053ec3fa666f76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any tasks are scheduled for execution.  <a href="#ab215294158a55a97c053ec3fa666f76f">More...</a><br /></td></tr>
<tr class="separator:ab215294158a55a97c053ec3fa666f76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c78f85e87e3b4e1fa9531ec916a1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ae7c78f85e87e3b4e1fa9531ec916a1d6">size</a> () const</td></tr>
<tr class="memdesc:ae7c78f85e87e3b4e1fa9531ec916a1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the thread pool.  <a href="#ae7c78f85e87e3b4e1fa9531ec916a1d6">More...</a><br /></td></tr>
<tr class="separator:ae7c78f85e87e3b4e1fa9531ec916a1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9355948870ed5c800ffdf26c36ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a6ad9355948870ed5c800ffdf26c36ddb">active</a> () const</td></tr>
<tr class="memdesc:a6ad9355948870ed5c800ffdf26c36ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently active/busy threads.  <a href="#a6ad9355948870ed5c800ffdf26c36ddb">More...</a><br /></td></tr>
<tr class="separator:a6ad9355948870ed5c800ffdf26c36ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041a55fe5b884f6c62154a9e2ed60e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a041a55fe5b884f6c62154a9e2ed60e2a">ready</a> () const</td></tr>
<tr class="memdesc:a041a55fe5b884f6c62154a9e2ed60e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently ready/inactive threads.  <a href="#a041a55fe5b884f6c62154a9e2ed60e2a">More...</a><br /></td></tr>
<tr class="separator:a041a55fe5b884f6c62154a9e2ed60e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Task scheduling</div></td></tr>
<tr class="memitem:a3ba5c75fca752439e2f3211e14501965"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename... Args&gt; </td></tr>
<tr class="memitem:a3ba5c75fca752439e2f3211e14501965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a3ba5c75fca752439e2f3211e14501965">schedule</a> (Callable func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3ba5c75fca752439e2f3211e14501965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given function/functor for execution.  <a href="#a3ba5c75fca752439e2f3211e14501965">More...</a><br /></td></tr>
<tr class="separator:a3ba5c75fca752439e2f3211e14501965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a4d1b06119db318de012cf4c6c14b9a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a4d1b06119db318de012cf4c6c14b9a2c">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool block=false)</td></tr>
<tr class="memdesc:a4d1b06119db318de012cf4c6c14b9a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the total number of threads in the thread pool.  <a href="#a4d1b06119db318de012cf4c6c14b9a2c">More...</a><br /></td></tr>
<tr class="separator:a4d1b06119db318de012cf4c6c14b9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad975aab73f0d27c5589240bd1a4a70c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ad975aab73f0d27c5589240bd1a4a70c1">wait</a> ()</td></tr>
<tr class="memdesc:ad975aab73f0d27c5589240bd1a4a70c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waiting for all scheduled tasks to be completed.  <a href="#ad975aab73f0d27c5589240bd1a4a70c1">More...</a><br /></td></tr>
<tr class="separator:ad975aab73f0d27c5589240bd1a4a70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca70662b512933582f801b0f94a6145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a0ca70662b512933582f801b0f94a6145">clear</a> ()</td></tr>
<tr class="memdesc:a0ca70662b512933582f801b0f94a6145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all scheduled tasks from the thread pool.  <a href="#a0ca70662b512933582f801b0f94a6145">More...</a><br /></td></tr>
<tr class="separator:a0ca70662b512933582f801b0f94a6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a88b627953cc6419b98211d3c46558277"><td class="memItemLeft" align="right" valign="top"><a id="a88b627953cc6419b98211d3c46558277"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a88b627953cc6419b98211d3c46558277">ManagedThread</a> = <a class="el" href="../../de/d7d/classblaze_1_1Thread.html">Thread</a>&lt; TT, MT, LT, CT &gt;</td></tr>
<tr class="memdesc:a88b627953cc6419b98211d3c46558277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the managed threads. <br /></td></tr>
<tr class="separator:a88b627953cc6419b98211d3c46558277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de28af042dc66999d4a6e788fb858f8"><td class="memItemLeft" align="right" valign="top"><a id="a6de28af042dc66999d4a6e788fb858f8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a6de28af042dc66999d4a6e788fb858f8">Threads</a> = std::vector&lt; std::unique_ptr&lt; <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a88b627953cc6419b98211d3c46558277">ManagedThread</a> &gt; &gt;</td></tr>
<tr class="memdesc:a6de28af042dc66999d4a6e788fb858f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the thread container. <br /></td></tr>
<tr class="separator:a6de28af042dc66999d4a6e788fb858f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d341b2758a346bb3c814d266146d7f"><td class="memItemLeft" align="right" valign="top"><a id="a24d341b2758a346bb3c814d266146d7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a24d341b2758a346bb3c814d266146d7f">TaskQueue</a> = <a class="el" href="../../db/dee/classblaze_1_1threadpool_1_1TaskQueue.html">threadpool::TaskQueue</a></td></tr>
<tr class="memdesc:a24d341b2758a346bb3c814d266146d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the task queue. <br /></td></tr>
<tr class="separator:a24d341b2758a346bb3c814d266146d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ec74913f728b610eb57993290299c5"><td class="memItemLeft" align="right" valign="top"><a id="a38ec74913f728b610eb57993290299c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a38ec74913f728b610eb57993290299c5">Mutex</a> = MT</td></tr>
<tr class="memdesc:a38ec74913f728b610eb57993290299c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the mutex. <br /></td></tr>
<tr class="separator:a38ec74913f728b610eb57993290299c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5a1c81350ecf0db7127c335507cc1"><td class="memItemLeft" align="right" valign="top"><a id="a94e5a1c81350ecf0db7127c335507cc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a94e5a1c81350ecf0db7127c335507cc1">Lock</a> = LT</td></tr>
<tr class="memdesc:a94e5a1c81350ecf0db7127c335507cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a locking object. <br /></td></tr>
<tr class="separator:a94e5a1c81350ecf0db7127c335507cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a49e0764d3772bb96074d5da292ce99"><td class="memItemLeft" align="right" valign="top"><a id="a5a49e0764d3772bb96074d5da292ce99"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5a49e0764d3772bb96074d5da292ce99">Condition</a> = CT</td></tr>
<tr class="memdesc:a5a49e0764d3772bb96074d5da292ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable type. <br /></td></tr>
<tr class="separator:a5a49e0764d3772bb96074d5da292ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread functions</div></td></tr>
<tr class="memitem:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a52bdd2b2de4bc83bbab6ec3fc4c4b446">createThread</a> ()</td></tr>
<tr class="memdesc:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a new thread to the thread pool.  <a href="#a52bdd2b2de4bc83bbab6ec3fc4c4b446">More...</a><br /></td></tr>
<tr class="separator:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa419ce260788be0f424c21357ef3a372"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#aa419ce260788be0f424c21357ef3a372">executeTask</a> ()</td></tr>
<tr class="memdesc:aa419ce260788be0f424c21357ef3a372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executing a scheduled task.  <a href="#aa419ce260788be0f424c21357ef3a372">More...</a><br /></td></tr>
<tr class="separator:aa419ce260788be0f424c21357ef3a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a78a01b52bae227450d824155c942f680"><td class="memItemLeft" align="right" valign="top"><a id="a78a01b52bae227450d824155c942f680"></a>
volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a78a01b52bae227450d824155c942f680">total_</a></td></tr>
<tr class="memdesc:a78a01b52bae227450d824155c942f680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of threads in the thread pool. <br /></td></tr>
<tr class="separator:a78a01b52bae227450d824155c942f680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d2457237fa6fc84b3facc75c2fcf06"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a30d2457237fa6fc84b3facc75c2fcf06">expected_</a></td></tr>
<tr class="memdesc:a30d2457237fa6fc84b3facc75c2fcf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected number of threads in the thread pool.  <a href="#a30d2457237fa6fc84b3facc75c2fcf06">More...</a><br /></td></tr>
<tr class="separator:a30d2457237fa6fc84b3facc75c2fcf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9565cb0631f2048ee11dd58d24eb7c2"><td class="memItemLeft" align="right" valign="top"><a id="af9565cb0631f2048ee11dd58d24eb7c2"></a>
volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#af9565cb0631f2048ee11dd58d24eb7c2">active_</a></td></tr>
<tr class="memdesc:af9565cb0631f2048ee11dd58d24eb7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of currently active/busy threads. <br /></td></tr>
<tr class="separator:af9565cb0631f2048ee11dd58d24eb7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b496a652c11d25fdf4ca12353795231"><td class="memItemLeft" align="right" valign="top"><a id="a2b496a652c11d25fdf4ca12353795231"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a6de28af042dc66999d4a6e788fb858f8">Threads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a2b496a652c11d25fdf4ca12353795231">threads_</a></td></tr>
<tr class="memdesc:a2b496a652c11d25fdf4ca12353795231"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threads contained in the thread pool. <br /></td></tr>
<tr class="separator:a2b496a652c11d25fdf4ca12353795231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be88b93495267d9ac83617028a7056f"><td class="memItemLeft" align="right" valign="top"><a id="a9be88b93495267d9ac83617028a7056f"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a24d341b2758a346bb3c814d266146d7f">TaskQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a9be88b93495267d9ac83617028a7056f">taskqueue_</a></td></tr>
<tr class="memdesc:a9be88b93495267d9ac83617028a7056f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task queue for the scheduled tasks. <br /></td></tr>
<tr class="separator:a9be88b93495267d9ac83617028a7056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d23882a696a765b705172e0ac29dfd5"><td class="memItemLeft" align="right" valign="top"><a id="a5d23882a696a765b705172e0ac29dfd5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a38ec74913f728b610eb57993290299c5">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5d23882a696a765b705172e0ac29dfd5">mutex_</a></td></tr>
<tr class="memdesc:a5d23882a696a765b705172e0ac29dfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization mutex. <br /></td></tr>
<tr class="separator:a5d23882a696a765b705172e0ac29dfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8eda15c6f40531ae60b43ed8e346e5"><td class="memItemLeft" align="right" valign="top"><a id="adf8eda15c6f40531ae60b43ed8e346e5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5a49e0764d3772bb96074d5da292ce99">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#adf8eda15c6f40531ae60b43ed8e346e5">waitForTask_</a></td></tr>
<tr class="memdesc:adf8eda15c6f40531ae60b43ed8e346e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait condition for idle threads. <br /></td></tr>
<tr class="separator:adf8eda15c6f40531ae60b43ed8e346e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="memItemLeft" align="right" valign="top"><a id="a3421ba3c7930fdc19fb1c5cff7e5d6e5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5a49e0764d3772bb96074d5da292ce99">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a3421ba3c7930fdc19fb1c5cff7e5d6e5">waitForThread_</a></td></tr>
<tr class="memdesc:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait condition for the thread management. <br /></td></tr>
<tr class="separator:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TT, typename MT, typename LT, typename CT&gt;<br />
class blaze::ThreadPool&lt; TT, MT, LT, CT &gt;</h3>

<p>Implementation of a thread pool. </p>
<h1><a class="anchor" id="threadpool_general"></a>
General</h1>
<p>The <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template represents a thread pool according to the thread pool pattern (see for example <a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">http://en.wikipedia.org/wiki/Thread_pool_pattern</a>). It manages a certain number of threads in order to process a larger number of independent tasks.</p>
<div class="image">
<img src="../../threadpool.png" alt="threadpool.png"/>
</div>
 <p>The primary purpose of a thread pool is the reuse of system resources: instead of creating a single thread for every individual task, threads are reused to handle several tasks. This increases the performance in comparison to different threading strategies, as illustrated in the graph below. The first bar indicates the sequential performance of 1000 matrix-matrix multiplications of arbitrarily sized square matrices. The second bar shows the performance of the same work performed by 1000 distinct threads (i.e. one thread for each matrix-matrix multiplication) on a quad-core system. In this case, all cores of the system can be used, but the additional overhead of creating and managing new threads prevents the expected performance increase by a factor of four. The third bar illustrates the performance of four threads distributing the work between them (i.e. 250 matrix-matrix multiplications per thread), again using the same quad-core system. This approach nearly achieves four times the performance of the sequential execution. The fourth bar represents the performance of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class using fourth threads for the execution of the 1000 individual multiplications.</p>
<div class="image">
<img src="../../threadpool2.png" alt="threadpool2.png"/>
</div>
 <p>Additionally, the thread pool approach simplifies load balancing and increases the stability of the system.</p>
<h1><a class="anchor" id="threadpool_definition"></a>
Class Definition</h1>
<p>The implementation of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template is based on the implementation of standard thread functionality as provided by the C++11 standard or the Boost library. Via the four template parameters it is possible to configure a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance as either a C++11 thread pool or as Boost thread pool:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TT, <span class="keyword">typename</span> MT, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> CT &gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a>;</div></div><!-- fragment --><ul>
<li>TT: specifies the type of the encapsulated thread. This can either be <code>std::thread</code>, <code>boost::thread</code>, or any other standard conforming thread type.</li>
<li>MT: specifies the type of the used synchronization mutex. This can for instance be <code>std::mutex</code>, <code>boost::mutex</code>, or any other standard conforming mutex type.</li>
<li>LT: specifies the type of lock used in combination with the given mutex type. This can be any standard conforming lock type, as for instance <code>std::unique_lock</code>, <code>boost::unique_lock</code>.</li>
<li>CT: specifies the type of the used condition variable. This can for instance be <code>std::condition_variable</code>, <code>boost::condition_variable</code>, or any other standard conforming condition variable type.</li>
</ul>
<p>The following example demonstrates how to configure the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template as either C++11 standard thread pool or as Boost thread pool:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> BoostThreadPool = <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; boost::thread</div><div class="line">                                         , boost::mutex</div><div class="line">                                         , boost::unique_lock&lt;boost::mutex&gt;</div><div class="line">                                         , boost::condition_variable &gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> StdThreadPool = <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; std::thread</div><div class="line">                                       , std::mutex</div><div class="line">                                       , std::unique_lock&lt;std::mutex&gt;</div><div class="line">                                       , std::condition_variable &gt;;</div></div><!-- fragment --><p>For more information about the standard thread functionality, see [1] or [2] or the current documentation at the Boost homepage: www.boost.org.</p>
<h1><a class="anchor" id="threadpool_setup"></a>
Using the ThreadPool class</h1>
<p>The following example demonstrates the use of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. In contrast to the setup of individual threads (see the <a class="el" href="../../de/d7d/classblaze_1_1Thread.html" title="Implementation of a single thread of execution. ">Thread</a> class description for more details), it is not necessary to create and manage individual threads, but only to schedules tasks for the accordingly sized thread pool.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of a function with no arguments that returns void</span></div><div class="line"><span class="keywordtype">void</span> function0() { ... }</div><div class="line"></div><div class="line"><span class="comment">// Definition of a functor (function object) taking two arguments and returning void</span></div><div class="line"><span class="keyword">struct </span>Functor2</div><div class="line">{</div><div class="line">   <span class="keywordtype">void</span> operator()( <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b ) { ... }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">   <span class="comment">// Creating a thread pool with initially two working threads</span></div><div class="line">   StdThreadPool threadpool( 2 );</div><div class="line"></div><div class="line">   <span class="comment">// Scheduling two concurrent tasks</span></div><div class="line">   threadpool.schedule( function0 );</div><div class="line">   threadpool.schedule( Functor2(), 4, 6 );</div><div class="line"></div><div class="line">   <span class="comment">// Waiting for the thread pool to complete both tasks</span></div><div class="line">   threadpool.wait();</div><div class="line"></div><div class="line">   <span class="comment">// Resizing the thread pool to four working threads</span></div><div class="line">   threadpool.resize( 4 );</div><div class="line"></div><div class="line">   <span class="comment">// Scheduling other concurrent tasks</span></div><div class="line">   ...</div><div class="line">   threadpool.schedule( function0 );</div><div class="line">   ...</div><div class="line"></div><div class="line">   <span class="comment">// At the end of the thread pool scope, all tasks remaining in the task queue are removed</span></div><div class="line">   <span class="comment">// and all currently running tasks are completed. Additionally, all acquired resources are</span></div><div class="line">   <span class="comment">// safely released.</span></div><div class="line">}</div></div><!-- fragment --><p>Note that the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a3ba5c75fca752439e2f3211e14501965" title="Scheduling the given function/functor for execution. ">schedule()</a> function allows for up to five arguments for the given functions/functors.</p>
<h1><a class="anchor" id="threadpool_exception"></a>
Throwing exceptions in a thread parallel environment</h1>
<p>It can happen that during the execution of a given task a thread encounters an erroneous situation and has to throw an exception. However, exceptions thrown in the usual way cannot be caught by a try-catch-block in the main thread of execution:</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of a function throwing a std::runtime_error during its execution</span></div><div class="line"><span class="keywordtype">void</span> task()</div><div class="line">{</div><div class="line">   ...</div><div class="line">   <span class="keywordflow">throw</span> std::runtime_error( ... );</div><div class="line">   ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Creating a thread pool executing the throwing function. Although the setup, the scheduling</span></div><div class="line"><span class="comment">// of the task, the wait() function and the destruction of the thread pool are encapsuled</span></div><div class="line"><span class="comment">// inside a try-catch-block, the exception cannot be caught and results in an abortion of the</span></div><div class="line"><span class="comment">// program.</span></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">   StdThreadpool threadpool( 2 );</div><div class="line">   thread.schedule( task );</div><div class="line">   threadpool.wait();</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>( ... )</div><div class="line">{</div><div class="line">   ...</div><div class="line">}</div></div><!-- fragment --><p>For a detailed explanation how to portably transport exceptions between threads, see [1] or [2]. In case of the Boost library, the according Boost functionality as demonstrated in the following example has to be used. Note that any function/functor scheduled for execution is responsible to handle exceptions in this way!</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/exception_ptr.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Definition of a function that happens to throw an exception. In order to throw the</span></div><div class="line"><span class="comment">// exception, boost::enable_current_exception() is used in combination with throw.</span></div><div class="line"><span class="keywordtype">void</span> throwException()</div><div class="line">{</div><div class="line">   ...</div><div class="line">   <span class="keywordflow">throw</span> boost::enable_current_exception( std::runtime_error( ... ) );</div><div class="line">   ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Definition of a thread function. The try-catch-block catches the exception and uses the</span></div><div class="line"><span class="comment">// boost::current_exception() function to get a boost::exception_ptr object.</span></div><div class="line"><span class="keywordtype">void</span> task( boost::exception_ptr&amp; error )</div><div class="line">{</div><div class="line">   <span class="keywordflow">try</span> {</div><div class="line">      throwException();</div><div class="line">      error = boost::exception_ptr();</div><div class="line">   }</div><div class="line">   <span class="keywordflow">catch</span>( ... ) {</div><div class="line">      error = boost::current_exception();</div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The function that start a thread of execution can pass along a boost::exception_ptr object</span></div><div class="line"><span class="comment">// that is set in case of an exception. Note that boost::current_exception() captures the</span></div><div class="line"><span class="comment">// original type of the exception object. The exception can be thrown again using the</span></div><div class="line"><span class="comment">// boost::rethrow_exception() function.</span></div><div class="line"><span class="keywordtype">void</span> work()</div><div class="line">{</div><div class="line">   boost::exception_ptr error;</div><div class="line"></div><div class="line">   StdThreadPool threadpool( 2 );</div><div class="line">   threadpool.schedule( boost::bind( task, boost::ref(error) ) );</div><div class="line">   threadpool.wait();</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span>( error ) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot; Exception during thread execution!\n\n&quot;</span>;</div><div class="line">      boost::rethrow_exception( error );</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="threadpool_known_issues"></a>
Known issues</h1>
<p>There is a known issue in Visual Studio 2012 and 2013 that may cause C++11 threads to hang if their destructor is executed after the <code>main()</code> function:</p>
<p><a href="http://connect.microsoft.com/VisualStudio/feedback/details/747145">http://connect.microsoft.com/VisualStudio/feedback/details/747145</a></p>
<p>In order to circumvent this problem, for Visual Studio compilers only, it is possible to explicitly resize a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance to 0 threads and to block until all threads have been destroyed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">   <span class="keyword">static</span> StdThreadPool threadpool( 4 );</div><div class="line"></div><div class="line">   <span class="comment">// ... Using the thread pool</span></div><div class="line"></div><div class="line">   threadpool( 0, <span class="keyword">true</span> );</div><div class="line">}</div></div><!-- fragment --><p>Note that this should ONLY be used before the end of the <code>main()</code> function and ONLY if the threadpool will not be used anymore.</p>
<h1><a class="anchor" id="threadpool_references"></a>
References</h1>
<p>[1] A. Williams: C++ Concurrency in Action, Manning, 2012, ISBN: 978-1933988771<br />
[2] B. Stroustrup: The C++ Programming Language, Addison-Wesley, 2013, ISBN: 978-0321563842<br />
</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fb200ed35908231bba1d72a71c78c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb200ed35908231bba1d72a71c78c17">&#9670;&nbsp;</a></span>ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Initial number of threads <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a thread pool with initially <em>n</em> new threads. <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> threads are initially idle until a task is scheduled. </p>

</div>
</div>
<a id="a8dd5edaab373a5115f1570d8dcacfc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd5edaab373a5115f1570d8dcacfc00">&#9670;&nbsp;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::~<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. </p>
<p>The destructor clears all remaining tasks from the task queue and waits for the currently active threads to complete their tasks. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ad9355948870ed5c800ffdf26c36ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad9355948870ed5c800ffdf26c36ddb">&#9670;&nbsp;</a></span>active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of currently active/busy threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of currently active threads. </dd></dl>

</div>
</div>
<a id="a0ca70662b512933582f801b0f94a6145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca70662b512933582f801b0f94a6145">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removing all scheduled tasks from the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function removes all currently scheduled tasks from the thread pool. The total number of threads remains unchanged and all active threads continue completing their tasks. </p>

</div>
</div>
<a id="a52bdd2b2de4bc83bbab6ec3fc4c4b446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bdd2b2de4bc83bbab6ec3fc4c4b446">&#9670;&nbsp;</a></span>createThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::createThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adding a new thread to the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aa419ce260788be0f424c21357ef3a372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa419ce260788be0f424c21357ef3a372">&#9670;&nbsp;</a></span>executeTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::executeTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executing a scheduled task. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case a task was successfully finished, <em>false</em> if not.</dd></dl>
<p>This function is repeatedly called by every thread to execute one of the scheduled tasks. In case there is no task available, the thread blocks and waits for a new task to be scheduled. </p>

</div>
</div>
<a id="ab215294158a55a97c053ec3fa666f76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab215294158a55a97c053ec3fa666f76f">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether any tasks are scheduled for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case task are scheduled, <em>false</em> otherwise. </dd></dl>

</div>
</div>
<a id="a041a55fe5b884f6c62154a9e2ed60e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041a55fe5b884f6c62154a9e2ed60e2a">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of currently ready/inactive threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of currently ready threads. </dd></dl>

</div>
</div>
<a id="a4d1b06119db318de012cf4c6c14b9a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1b06119db318de012cf4c6c14b9a2c">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the total number of threads in the thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new number of threads <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
    <tr><td class="paramname">block</td><td><em>true</em> if the function shall block, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid number of threads.</td></tr>
  </table>
  </dd>
</dl>
<p>This function changes the size of the thread pool, i.e. changes the total number of threads contained in the pool. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> <em>n</em> is smaller than the current size of the thread pool, the according number of threads is removed from the pool, otherwise new threads are added to the pool. Via the <em>block</em> flag it is possible to block the function until the desired number of threads is available.</p>
<p>Note that there is a known issue in Visual Studio 2012 and 2013 that may cause C++11 threads to hang if their destructor is executed after the <code>main()</code> function:</p>
<p><a href="http://connect.microsoft.com/VisualStudio/feedback/details/747145">http://connect.microsoft.com/VisualStudio/feedback/details/747145</a></p>
<p>In order to circumvent this problem, for Visual Studio compilers only, it is possible to explicitly resize a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance to 0 threads and to block until all threads have been destroyed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">   <span class="keyword">static</span> <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a>&lt; std::thread</div><div class="line">                    , std::mutex</div><div class="line">                    , std::unique_lock&lt; std::mutex &gt;</div><div class="line">                    , std::condition_variable &gt; threadpool( 4 );</div><div class="line"></div><div class="line">   <span class="comment">// ... Using the thread pool</span></div><div class="line"></div><div class="line">   threadpool( 0, <span class="keyword">true</span> );</div><div class="line">}</div></div><!-- fragment --><p>Note that this should ONLY be used before the end of the <code>main()</code> function and ONLY if the threadpool will not be used anymore. </p>

</div>
</div>
<a id="a3ba5c75fca752439e2f3211e14501965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba5c75fca752439e2f3211e14501965">&#9670;&nbsp;</a></span>schedule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments for the function/functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with the given type and number of arguments and must return <code>void</code>. </p>

</div>
</div>
<a id="ae7c78f85e87e3b4e1fa9531ec916a1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c78f85e87e3b4e1fa9531ec916a1d6">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size of the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of threads in the thread pool. </dd></dl>

</div>
</div>
<a id="ad975aab73f0d27c5589240bd1a4a70c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad975aab73f0d27c5589240bd1a4a70c1">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waiting for all scheduled tasks to be completed. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function blocks until all scheduled tasks have been completed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a30d2457237fa6fc84b3facc75c2fcf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d2457237fa6fc84b3facc75c2fcf06">&#9670;&nbsp;</a></span>expected_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::expected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected number of threads in the thread pool. </p>
<p>This number may differ from the total number of threads during a resize of the thread pool. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/util/<a class="el" href="../../d0/d80/Thread_8h_source.html">Thread.h</a></li>
<li>blaze/util/<a class="el" href="../../d3/d43/ThreadPool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:34 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
