<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dense Matrices</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dense Matrices<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d2/d77/group__custom__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d77/group__custom__matrix.html">CustomMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/dfc/group__dynamic__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html">DynamicMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d0f/group__hybrid__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/group__hybrid__matrix.html">HybridMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/def/group__static__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html">StaticMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d7c/group__dense__matrix__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d7c/group__dense__matrix__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; MT, SO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense matrices.The <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html" title="Base class for dense matrices.The DenseMatrix class is a base class for all dense matrix classes...">DenseMatrix</a> class is a base class for all dense matrix classes. It provides an abstraction from the actual type of the dense matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d0/d89/structblaze_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">blaze::operator==</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga25855a1d3c48eb1cb6f3f5a66842a85e">More...</a><br /></td></tr>
<tr class="separator:ga25855a1d3c48eb1cb6f3f5a66842a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">blaze::operator!=</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8ab1683cf0ef1f675329a4d27d45751c">More...</a><br /></td></tr>
<tr class="separator:ga8ab1683cf0ef1f675329a4d27d45751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7187096e39dd93ef22367044b3600fe7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7187096e39dd93ef22367044b3600fe7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">blaze::decldiag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7187096e39dd93ef22367044b3600fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given dense matrix expression <em>dm</em> as diagonal.  <a href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">More...</a><br /></td></tr>
<tr class="separator:ga7187096e39dd93ef22367044b3600fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0ab0b8ff7fd8a57ada423a50011679"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gada0ab0b8ff7fd8a57ada423a50011679"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">blaze::declherm</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gada0ab0b8ff7fd8a57ada423a50011679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given dense matrix expression <em>dm</em> as Hermitian.  <a href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">More...</a><br /></td></tr>
<tr class="separator:gada0ab0b8ff7fd8a57ada423a50011679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34f841b05e0aa88e561d312168e6429"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad34f841b05e0aa88e561d312168e6429"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">blaze::decllow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad34f841b05e0aa88e561d312168e6429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given dense matrix expression <em>dm</em> as lower.  <a href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">More...</a><br /></td></tr>
<tr class="separator:gad34f841b05e0aa88e561d312168e6429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf429fe0aac934e266ffef8aa0a284ba"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadf429fe0aac934e266ffef8aa0a284ba"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">blaze::declsym</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gadf429fe0aac934e266ffef8aa0a284ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given dense matrix expression <em>dm</em> as symmetric.  <a href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">More...</a><br /></td></tr>
<tr class="separator:gadf429fe0aac934e266ffef8aa0a284ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb58b929e36557ec199ba79cbccd247"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaceb58b929e36557ec199ba79cbccd247"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">blaze::declupp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaceb58b929e36557ec199ba79cbccd247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given dense matrix expression <em>dm</em> as upper.  <a href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">More...</a><br /></td></tr>
<tr class="separator:gaceb58b929e36557ec199ba79cbccd247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d2bd49b16ccde7bfff7d45dc49d54d"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:ga04d2bd49b16ccde7bfff7d45dc49d54d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga04d2bd49b16ccde7bfff7d45dc49d54d">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga04d2bd49b16ccde7bfff7d45dc49d54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga04d2bd49b16ccde7bfff7d45dc49d54d">More...</a><br /></td></tr>
<tr class="separator:ga04d2bd49b16ccde7bfff7d45dc49d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeacb52db2d3b774340603c1cb32916b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:gaaeacb52db2d3b774340603c1cb32916b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">blaze::map</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs, OP op)</td></tr>
<tr class="memdesc:gaaeacb52db2d3b774340603c1cb32916b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given binary operation on each single element of the dense matrices <em>lhs</em> and <em>rhs</em>.  <a href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">More...</a><br /></td></tr>
<tr class="separator:gaaeacb52db2d3b774340603c1cb32916b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199758e48efa146deeb0f8c7ec70a41e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga199758e48efa146deeb0f8c7ec70a41e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga199758e48efa146deeb0f8c7ec70a41e">blaze::min</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga199758e48efa146deeb0f8c7ec70a41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the componentwise minimum of the dense matrices <em>lhs</em> and <em>rhs</em>.  <a href="../../db/df0/group__dense__matrix.html#ga199758e48efa146deeb0f8c7ec70a41e">More...</a><br /></td></tr>
<tr class="separator:ga199758e48efa146deeb0f8c7ec70a41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1875344775bac54b6b519240a70249"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga1e1875344775bac54b6b519240a70249"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1e1875344775bac54b6b519240a70249">blaze::max</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1e1875344775bac54b6b519240a70249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the componentwise maximum of the dense matrices <em>lhs</em> and <em>rhs</em>.  <a href="../../db/df0/group__dense__matrix.html#ga1e1875344775bac54b6b519240a70249">More...</a><br /></td></tr>
<tr class="separator:ga1e1875344775bac54b6b519240a70249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a8dd3b5e883329b16a6ae2bbef003e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gad7a8dd3b5e883329b16a6ae2bbef003e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad7a8dd3b5e883329b16a6ae2bbef003e">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad7a8dd3b5e883329b16a6ae2bbef003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad7a8dd3b5e883329b16a6ae2bbef003e">More...</a><br /></td></tr>
<tr class="separator:gad7a8dd3b5e883329b16a6ae2bbef003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813d50acb276268ae73d318d26ec7589"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:ga813d50acb276268ae73d318d26ec7589"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga813d50acb276268ae73d318d26ec7589">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga813d50acb276268ae73d318d26ec7589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga813d50acb276268ae73d318d26ec7589">More...</a><br /></td></tr>
<tr class="separator:ga813d50acb276268ae73d318d26ec7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab727f40b4fd08c2c054646d21bbde630"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:gab727f40b4fd08c2c054646d21bbde630"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab727f40b4fd08c2c054646d21bbde630">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab727f40b4fd08c2c054646d21bbde630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gab727f40b4fd08c2c054646d21bbde630">More...</a><br /></td></tr>
<tr class="separator:gab727f40b4fd08c2c054646d21bbde630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b5ef8a28958146c85a18ef72886b82"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga19b5ef8a28958146c85a18ef72886b82"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">blaze::eval</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga19b5ef8a28958146c85a18ef72886b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">More...</a><br /></td></tr>
<tr class="separator:ga19b5ef8a28958146c85a18ef72886b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1340e62509cbdcd565c028bf42842e4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad1340e62509cbdcd565c028bf42842e4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">blaze::inv</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad1340e62509cbdcd565c028bf42842e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the inverse of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">More...</a><br /></td></tr>
<tr class="separator:gad1340e62509cbdcd565c028bf42842e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96504530f58ab9c0c14d43db5062941"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:gac96504530f58ab9c0c14d43db5062941"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac96504530f58ab9c0c14d43db5062941">blaze::map</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, OP op)</td></tr>
<tr class="memdesc:gac96504530f58ab9c0c14d43db5062941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gac96504530f58ab9c0c14d43db5062941">More...</a><br /></td></tr>
<tr class="separator:gac96504530f58ab9c0c14d43db5062941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae0b42de3d71f8c56366bd9564f6cea"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:ga7ae0b42de3d71f8c56366bd9564f6cea"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">blaze::forEach</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, OP op)</td></tr>
<tr class="memdesc:ga7ae0b42de3d71f8c56366bd9564f6cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">More...</a><br /></td></tr>
<tr class="separator:ga7ae0b42de3d71f8c56366bd9564f6cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c7ab005f0a5070705195db86e7bae4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga82c7ab005f0a5070705195db86e7bae4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">blaze::abs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga82c7ab005f0a5070705195db86e7bae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">More...</a><br /></td></tr>
<tr class="separator:ga82c7ab005f0a5070705195db86e7bae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17215f7077a9cacabf3d29ffb85cdd30"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga17215f7077a9cacabf3d29ffb85cdd30"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">blaze::floor</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga17215f7077a9cacabf3d29ffb85cdd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">More...</a><br /></td></tr>
<tr class="separator:ga17215f7077a9cacabf3d29ffb85cdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bec4639063b9b7cf5856973008a307"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga86bec4639063b9b7cf5856973008a307"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">blaze::ceil</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga86bec4639063b9b7cf5856973008a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">More...</a><br /></td></tr>
<tr class="separator:ga86bec4639063b9b7cf5856973008a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bab7da7e169af5159b553cd0b7d895"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga05bab7da7e169af5159b553cd0b7d895"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">blaze::trunc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga05bab7da7e169af5159b553cd0b7d895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">More...</a><br /></td></tr>
<tr class="separator:ga05bab7da7e169af5159b553cd0b7d895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c035640c6ebfe1669dbe275009de90"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac9c035640c6ebfe1669dbe275009de90"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">blaze::round</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac9c035640c6ebfe1669dbe275009de90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">More...</a><br /></td></tr>
<tr class="separator:gac9c035640c6ebfe1669dbe275009de90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3ba99bdcc46aaef2b7285a5054cacf"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4c3ba99bdcc46aaef2b7285a5054cacf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">blaze::conj</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4c3ba99bdcc46aaef2b7285a5054cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">More...</a><br /></td></tr>
<tr class="separator:ga4c3ba99bdcc46aaef2b7285a5054cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654aa9bc341896a531363e297b65107e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga654aa9bc341896a531363e297b65107e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">blaze::ctrans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga654aa9bc341896a531363e297b65107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">More...</a><br /></td></tr>
<tr class="separator:ga654aa9bc341896a531363e297b65107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3efb8c5066fb6ae23b0ab8d3408e1b9b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3efb8c5066fb6ae23b0ab8d3408e1b9b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">blaze::real</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3efb8c5066fb6ae23b0ab8d3408e1b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">More...</a><br /></td></tr>
<tr class="separator:ga3efb8c5066fb6ae23b0ab8d3408e1b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec095b59eb71bbc86cce1fda1e5d2947"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaec095b59eb71bbc86cce1fda1e5d2947"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">blaze::imag</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaec095b59eb71bbc86cce1fda1e5d2947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary part of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">More...</a><br /></td></tr>
<tr class="separator:gaec095b59eb71bbc86cce1fda1e5d2947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8993c014d97629a4db3bd9a61dcd8da"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf8993c014d97629a4db3bd9a61dcd8da"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">blaze::sqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaf8993c014d97629a4db3bd9a61dcd8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">More...</a><br /></td></tr>
<tr class="separator:gaf8993c014d97629a4db3bd9a61dcd8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a5afb293f1b00e1e9fedbc9eeb830f"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga25a5afb293f1b00e1e9fedbc9eeb830f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">blaze::invsqrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga25a5afb293f1b00e1e9fedbc9eeb830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">More...</a><br /></td></tr>
<tr class="separator:ga25a5afb293f1b00e1e9fedbc9eeb830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208aae7dbc991f038bf8ec1d84afa989"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga208aae7dbc991f038bf8ec1d84afa989"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">blaze::cbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga208aae7dbc991f038bf8ec1d84afa989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">More...</a><br /></td></tr>
<tr class="separator:ga208aae7dbc991f038bf8ec1d84afa989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac8a6a6b4610343c75aa2e3a537692e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3ac8a6a6b4610343c75aa2e3a537692e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">blaze::invcbrt</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga3ac8a6a6b4610343c75aa2e3a537692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">More...</a><br /></td></tr>
<tr class="separator:ga3ac8a6a6b4610343c75aa2e3a537692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b09502be6a6aee96c90a0bc7fa47ed"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:ga88b09502be6a6aee96c90a0bc7fa47ed"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">blaze::clamp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga88b09502be6a6aee96c90a0bc7fa47ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the dense matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>.  <a href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">More...</a><br /></td></tr>
<tr class="separator:ga88b09502be6a6aee96c90a0bc7fa47ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f9950dc0a14952d77cb22307cee5bb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:ga50f9950dc0a14952d77cb22307cee5bb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">blaze::pow</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>)</td></tr>
<tr class="memdesc:ga50f9950dc0a14952d77cb22307cee5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">More...</a><br /></td></tr>
<tr class="separator:ga50f9950dc0a14952d77cb22307cee5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d9361c0ee99c282d650adca58fc817"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga01d9361c0ee99c282d650adca58fc817"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">blaze::exp</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga01d9361c0ee99c282d650adca58fc817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">More...</a><br /></td></tr>
<tr class="separator:ga01d9361c0ee99c282d650adca58fc817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1842bcb4ac9e245fdd079dc469499d32"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1842bcb4ac9e245fdd079dc469499d32"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">blaze::exp2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1842bcb4ac9e245fdd079dc469499d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">More...</a><br /></td></tr>
<tr class="separator:ga1842bcb4ac9e245fdd079dc469499d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5384d15bbb975be8c0c72b8a2193cd81"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5384d15bbb975be8c0c72b8a2193cd81"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">blaze::exp10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga5384d15bbb975be8c0c72b8a2193cd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">More...</a><br /></td></tr>
<tr class="separator:ga5384d15bbb975be8c0c72b8a2193cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c9b9a39f0e7c6637b6af4f5e252e7a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga33c9b9a39f0e7c6637b6af4f5e252e7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">blaze::log</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga33c9b9a39f0e7c6637b6af4f5e252e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">More...</a><br /></td></tr>
<tr class="separator:ga33c9b9a39f0e7c6637b6af4f5e252e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e400cfca815316f564e56795cb7208"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga75e400cfca815316f564e56795cb7208"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">blaze::log2</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga75e400cfca815316f564e56795cb7208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">More...</a><br /></td></tr>
<tr class="separator:ga75e400cfca815316f564e56795cb7208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5b7d6556dffdfa9fb311d5ce5dd7de"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaac5b7d6556dffdfa9fb311d5ce5dd7de"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">blaze::log10</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaac5b7d6556dffdfa9fb311d5ce5dd7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">More...</a><br /></td></tr>
<tr class="separator:gaac5b7d6556dffdfa9fb311d5ce5dd7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184756a753db8cd2f780d88c3a652315"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga184756a753db8cd2f780d88c3a652315"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">blaze::sin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga184756a753db8cd2f780d88c3a652315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">More...</a><br /></td></tr>
<tr class="separator:ga184756a753db8cd2f780d88c3a652315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e862dd7e670667e8520d80e2d4ba87"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga88e862dd7e670667e8520d80e2d4ba87"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">blaze::asin</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga88e862dd7e670667e8520d80e2d4ba87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">More...</a><br /></td></tr>
<tr class="separator:ga88e862dd7e670667e8520d80e2d4ba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga517339bd44004f0029c0e399cdea98b7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga517339bd44004f0029c0e399cdea98b7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">blaze::sinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga517339bd44004f0029c0e399cdea98b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">More...</a><br /></td></tr>
<tr class="separator:ga517339bd44004f0029c0e399cdea98b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcf55ee4728e81c09d9c6ab90d7c734"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga2fcf55ee4728e81c09d9c6ab90d7c734"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">blaze::asinh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga2fcf55ee4728e81c09d9c6ab90d7c734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">More...</a><br /></td></tr>
<tr class="separator:ga2fcf55ee4728e81c09d9c6ab90d7c734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ddccb3f7678e3c7a79c31af3af2b43"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae3ddccb3f7678e3c7a79c31af3af2b43"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">blaze::cos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gae3ddccb3f7678e3c7a79c31af3af2b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">More...</a><br /></td></tr>
<tr class="separator:gae3ddccb3f7678e3c7a79c31af3af2b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c819795e3845b35ba6344a19a50b90"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga51c819795e3845b35ba6344a19a50b90"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">blaze::acos</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga51c819795e3845b35ba6344a19a50b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">More...</a><br /></td></tr>
<tr class="separator:ga51c819795e3845b35ba6344a19a50b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a875b7f5942c159fb7dd5401fdcb88b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6a875b7f5942c159fb7dd5401fdcb88b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">blaze::cosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6a875b7f5942c159fb7dd5401fdcb88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">More...</a><br /></td></tr>
<tr class="separator:ga6a875b7f5942c159fb7dd5401fdcb88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328df782acd85cc3d5e3458eac531ace"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga328df782acd85cc3d5e3458eac531ace"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">blaze::acosh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga328df782acd85cc3d5e3458eac531ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">More...</a><br /></td></tr>
<tr class="separator:ga328df782acd85cc3d5e3458eac531ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd02a415ad4981909556655496f5606"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaedd02a415ad4981909556655496f5606"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">blaze::tan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaedd02a415ad4981909556655496f5606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">More...</a><br /></td></tr>
<tr class="separator:gaedd02a415ad4981909556655496f5606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6887fb234d4aa28bf896f8e684fbe1e0"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6887fb234d4aa28bf896f8e684fbe1e0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">blaze::atan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6887fb234d4aa28bf896f8e684fbe1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">More...</a><br /></td></tr>
<tr class="separator:ga6887fb234d4aa28bf896f8e684fbe1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68dd72087a3e8104e3a089e5c481efd2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga68dd72087a3e8104e3a089e5c481efd2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">blaze::tanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga68dd72087a3e8104e3a089e5c481efd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">More...</a><br /></td></tr>
<tr class="separator:ga68dd72087a3e8104e3a089e5c481efd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0632a5d595720be50b96079f29cdd55"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae0632a5d595720be50b96079f29cdd55"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">blaze::atanh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gae0632a5d595720be50b96079f29cdd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">More...</a><br /></td></tr>
<tr class="separator:gae0632a5d595720be50b96079f29cdd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d14e06526209c8debb6b384e145608"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae8d14e06526209c8debb6b384e145608"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">blaze::erf</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gae8d14e06526209c8debb6b384e145608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">More...</a><br /></td></tr>
<tr class="separator:gae8d14e06526209c8debb6b384e145608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64b4501c6c359d0fc9955de26f1e0ca"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa64b4501c6c359d0fc9955de26f1e0ca"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">blaze::erfc</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa64b4501c6c359d0fc9955de26f1e0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each single element of the dense matrix <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">More...</a><br /></td></tr>
<tr class="separator:gaa64b4501c6c359d0fc9955de26f1e0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f7cce19ada0cda6d89630d8e4c7211"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga03f7cce19ada0cda6d89630d8e4c7211"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga03f7cce19ada0cda6d89630d8e4c7211">blaze::operator/</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;mat, ST scalar)</td></tr>
<tr class="memdesc:ga03f7cce19ada0cda6d89630d8e4c7211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_94.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga03f7cce19ada0cda6d89630d8e4c7211">More...</a><br /></td></tr>
<tr class="separator:ga03f7cce19ada0cda6d89630d8e4c7211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e08d35ce1bef6f878ba98e7bedf891"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac8e08d35ce1bef6f878ba98e7bedf891"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac8e08d35ce1bef6f878ba98e7bedf891">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac8e08d35ce1bef6f878ba98e7bedf891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_95.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gac8e08d35ce1bef6f878ba98e7bedf891">More...</a><br /></td></tr>
<tr class="separator:gac8e08d35ce1bef6f878ba98e7bedf891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca591785e5e6274c21f0419dc66b8ae"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaaca591785e5e6274c21f0419dc66b8ae"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaca591785e5e6274c21f0419dc66b8ae">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;mat, ST scalar)</td></tr>
<tr class="memdesc:gaaca591785e5e6274c21f0419dc66b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaaca591785e5e6274c21f0419dc66b8ae">More...</a><br /></td></tr>
<tr class="separator:gaaca591785e5e6274c21f0419dc66b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42e7c97f0fce4001aae83fb66342cf1"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename MT , bool SO, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:gaa42e7c97f0fce4001aae83fb66342cf1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa42e7c97f0fce4001aae83fb66342cf1">blaze::operator*</a> (ST scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaa42e7c97f0fce4001aae83fb66342cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_96.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa42e7c97f0fce4001aae83fb66342cf1">More...</a><br /></td></tr>
<tr class="separator:gaa42e7c97f0fce4001aae83fb66342cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac775fabaa100b5d7367998d1ea31e5fb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac775fabaa100b5d7367998d1ea31e5fb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">blaze::serial</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac775fabaa100b5d7367998d1ea31e5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">More...</a><br /></td></tr>
<tr class="separator:gac775fabaa100b5d7367998d1ea31e5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e62c0bb707ea6b842d0410e0d40b76"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:ga30e62c0bb707ea6b842d0410e0d40b76"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga30e62c0bb707ea6b842d0410e0d40b76">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga30e62c0bb707ea6b842d0410e0d40b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga30e62c0bb707ea6b842d0410e0d40b76">More...</a><br /></td></tr>
<tr class="separator:ga30e62c0bb707ea6b842d0410e0d40b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6953c59b2870d26f0b02abafc81aba8f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:ga6953c59b2870d26f0b02abafc81aba8f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6953c59b2870d26f0b02abafc81aba8f">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6953c59b2870d26f0b02abafc81aba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga6953c59b2870d26f0b02abafc81aba8f">More...</a><br /></td></tr>
<tr class="separator:ga6953c59b2870d26f0b02abafc81aba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26de0fe326c4fd2d78e12f94911d2c8e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga26de0fe326c4fd2d78e12f94911d2c8e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga26de0fe326c4fd2d78e12f94911d2c8e">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga26de0fe326c4fd2d78e12f94911d2c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga26de0fe326c4fd2d78e12f94911d2c8e">More...</a><br /></td></tr>
<tr class="separator:ga26de0fe326c4fd2d78e12f94911d2c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f24ddb3b90d7b260b3699abecdd3c86"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8f24ddb3b90d7b260b3699abecdd3c86"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8f24ddb3b90d7b260b3699abecdd3c86">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8f24ddb3b90d7b260b3699abecdd3c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga8f24ddb3b90d7b260b3699abecdd3c86">More...</a><br /></td></tr>
<tr class="separator:ga8f24ddb3b90d7b260b3699abecdd3c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7839b98910e4512ab833ee634a76611c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7839b98910e4512ab833ee634a76611c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7839b98910e4512ab833ee634a76611c">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7839b98910e4512ab833ee634a76611c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7839b98910e4512ab833ee634a76611c">More...</a><br /></td></tr>
<tr class="separator:ga7839b98910e4512ab833ee634a76611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf12017816dec6bbde0dc13e34dd59be"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gacf12017816dec6bbde0dc13e34dd59be"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacf12017816dec6bbde0dc13e34dd59be">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacf12017816dec6bbde0dc13e34dd59be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gacf12017816dec6bbde0dc13e34dd59be">More...</a><br /></td></tr>
<tr class="separator:gacf12017816dec6bbde0dc13e34dd59be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cd81a56f3eba22cad93ecdac1f6e3f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , typename OP &gt; </td></tr>
<tr class="memitem:gaa8cd81a56f3eba22cad93ecdac1f6e3f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa8cd81a56f3eba22cad93ecdac1f6e3f">blaze::map</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs, OP op)</td></tr>
<tr class="memdesc:gaa8cd81a56f3eba22cad93ecdac1f6e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given binary operation on each single element of the row-major dense matrix <em>lhs</em> and the column-major dense matrix <em>rhs</em>.  <a href="../../db/df0/group__dense__matrix.html#gaa8cd81a56f3eba22cad93ecdac1f6e3f">More...</a><br /></td></tr>
<tr class="separator:gaa8cd81a56f3eba22cad93ecdac1f6e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e285167479738f19015c046c43d4f20"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , typename OP &gt; </td></tr>
<tr class="memitem:ga0e285167479738f19015c046c43d4f20"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0e285167479738f19015c046c43d4f20">blaze::map</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs, OP op)</td></tr>
<tr class="memdesc:ga0e285167479738f19015c046c43d4f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given binary operation on each single element of the column-major dense matrix <em>lhs</em> and the row-major dense matrix <em>rhs</em>.  <a href="../../db/df0/group__dense__matrix.html#ga0e285167479738f19015c046c43d4f20">More...</a><br /></td></tr>
<tr class="separator:ga0e285167479738f19015c046c43d4f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04b26cff3f714e53d6dd46349edb38d"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa04b26cff3f714e53d6dd46349edb38d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa04b26cff3f714e53d6dd46349edb38d">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa04b26cff3f714e53d6dd46349edb38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa04b26cff3f714e53d6dd46349edb38d">More...</a><br /></td></tr>
<tr class="separator:gaa04b26cff3f714e53d6dd46349edb38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa6e70850e82b26b1bc1a8ec96c8928b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaaa6e70850e82b26b1bc1a8ec96c8928b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaa6e70850e82b26b1bc1a8ec96c8928b">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaa6e70850e82b26b1bc1a8ec96c8928b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaaa6e70850e82b26b1bc1a8ec96c8928b">More...</a><br /></td></tr>
<tr class="separator:gaaa6e70850e82b26b1bc1a8ec96c8928b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d11c54cf49e9e36a28619e3cdd6497"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga85d11c54cf49e9e36a28619e3cdd6497"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga85d11c54cf49e9e36a28619e3cdd6497">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga85d11c54cf49e9e36a28619e3cdd6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga85d11c54cf49e9e36a28619e3cdd6497">More...</a><br /></td></tr>
<tr class="separator:ga85d11c54cf49e9e36a28619e3cdd6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4540d43d7359634146e2b2f744a72fba"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga4540d43d7359634146e2b2f744a72fba"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4540d43d7359634146e2b2f744a72fba">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4540d43d7359634146e2b2f744a72fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4540d43d7359634146e2b2f744a72fba">More...</a><br /></td></tr>
<tr class="separator:ga4540d43d7359634146e2b2f744a72fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcc6f2b30ad8c4697ef1d1f16ba102e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7fcc6f2b30ad8c4697ef1d1f16ba102e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7fcc6f2b30ad8c4697ef1d1f16ba102e">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7fcc6f2b30ad8c4697ef1d1f16ba102e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7fcc6f2b30ad8c4697ef1d1f16ba102e">More...</a><br /></td></tr>
<tr class="separator:ga7fcc6f2b30ad8c4697ef1d1f16ba102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e370b7fc394ce8cbb51b0114509b08"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga89e370b7fc394ce8cbb51b0114509b08"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">blaze::trans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga89e370b7fc394ce8cbb51b0114509b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">More...</a><br /></td></tr>
<tr class="separator:ga89e370b7fc394ce8cbb51b0114509b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107f1d1fbdf21570e52814b4075956e9"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga107f1d1fbdf21570e52814b4075956e9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga107f1d1fbdf21570e52814b4075956e9">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga107f1d1fbdf21570e52814b4075956e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga107f1d1fbdf21570e52814b4075956e9">More...</a><br /></td></tr>
<tr class="separator:ga107f1d1fbdf21570e52814b4075956e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989eee6872d32ecad706d81823e425b1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga989eee6872d32ecad706d81823e425b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga989eee6872d32ecad706d81823e425b1">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga989eee6872d32ecad706d81823e425b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga989eee6872d32ecad706d81823e425b1">More...</a><br /></td></tr>
<tr class="separator:ga989eee6872d32ecad706d81823e425b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40079d5f49f4df43ff74d4ba223203d6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga40079d5f49f4df43ff74d4ba223203d6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga40079d5f49f4df43ff74d4ba223203d6">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga40079d5f49f4df43ff74d4ba223203d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga40079d5f49f4df43ff74d4ba223203d6">More...</a><br /></td></tr>
<tr class="separator:ga40079d5f49f4df43ff74d4ba223203d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756f1d83d0ed56e42610cd8e15691824"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga756f1d83d0ed56e42610cd8e15691824"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga756f1d83d0ed56e42610cd8e15691824">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga756f1d83d0ed56e42610cd8e15691824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga756f1d83d0ed56e42610cd8e15691824">More...</a><br /></td></tr>
<tr class="separator:ga756f1d83d0ed56e42610cd8e15691824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea907a979f0cec455ac5149366838dc7"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gaea907a979f0cec455ac5149366838dc7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaea907a979f0cec455ac5149366838dc7">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaea907a979f0cec455ac5149366838dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaea907a979f0cec455ac5149366838dc7">More...</a><br /></td></tr>
<tr class="separator:gaea907a979f0cec455ac5149366838dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf85cb4e827a302abce5c26093cfc545"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaaf85cb4e827a302abce5c26093cfc545"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaf85cb4e827a302abce5c26093cfc545">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaf85cb4e827a302abce5c26093cfc545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaaf85cb4e827a302abce5c26093cfc545">More...</a><br /></td></tr>
<tr class="separator:gaaf85cb4e827a302abce5c26093cfc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e9ec85dcae52e8cae48000d83b8cda"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , bool SO&gt; </td></tr>
<tr class="memitem:gaf6e9ec85dcae52e8cae48000d83b8cda"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf6e9ec85dcae52e8cae48000d83b8cda">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6e9ec85dcae52e8cae48000d83b8cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaf6e9ec85dcae52e8cae48000d83b8cda">More...</a><br /></td></tr>
<tr class="separator:gaf6e9ec85dcae52e8cae48000d83b8cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d945707e20439dba85a43ae35426b77"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga4d945707e20439dba85a43ae35426b77"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4d945707e20439dba85a43ae35426b77">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4d945707e20439dba85a43ae35426b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4d945707e20439dba85a43ae35426b77">More...</a><br /></td></tr>
<tr class="separator:ga4d945707e20439dba85a43ae35426b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f30ec1191442c02f58e7f43b7944b7"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae1f30ec1191442c02f58e7f43b7944b7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae1f30ec1191442c02f58e7f43b7944b7">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae1f30ec1191442c02f58e7f43b7944b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gae1f30ec1191442c02f58e7f43b7944b7">More...</a><br /></td></tr>
<tr class="separator:gae1f30ec1191442c02f58e7f43b7944b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8328fedcc976aeb84fefef81a2bd37"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga8d8328fedcc976aeb84fefef81a2bd37"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8d8328fedcc976aeb84fefef81a2bd37">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8d8328fedcc976aeb84fefef81a2bd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga8d8328fedcc976aeb84fefef81a2bd37">More...</a><br /></td></tr>
<tr class="separator:ga8d8328fedcc976aeb84fefef81a2bd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8ec1bf94f953318e60e59fa96a1725"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gadb8ec1bf94f953318e60e59fa96a1725"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gadb8ec1bf94f953318e60e59fa96a1725">blaze::operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadb8ec1bf94f953318e60e59fa96a1725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gadb8ec1bf94f953318e60e59fa96a1725">More...</a><br /></td></tr>
<tr class="separator:gadb8ec1bf94f953318e60e59fa96a1725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006a4acb3dc87708db2565de4a2fb91c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga006a4acb3dc87708db2565de4a2fb91c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga006a4acb3dc87708db2565de4a2fb91c">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga006a4acb3dc87708db2565de4a2fb91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga006a4acb3dc87708db2565de4a2fb91c">More...</a><br /></td></tr>
<tr class="separator:ga006a4acb3dc87708db2565de4a2fb91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae140ed6f1bb88fb30d862b48472b63c5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae140ed6f1bb88fb30d862b48472b63c5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae140ed6f1bb88fb30d862b48472b63c5">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae140ed6f1bb88fb30d862b48472b63c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gae140ed6f1bb88fb30d862b48472b63c5">More...</a><br /></td></tr>
<tr class="separator:gae140ed6f1bb88fb30d862b48472b63c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367f085a8b3f9d720d3f90a99cc241a7"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga367f085a8b3f9d720d3f90a99cc241a7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga367f085a8b3f9d720d3f90a99cc241a7">blaze::operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga367f085a8b3f9d720d3f90a99cc241a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga367f085a8b3f9d720d3f90a99cc241a7">More...</a><br /></td></tr>
<tr class="separator:ga367f085a8b3f9d720d3f90a99cc241a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4401eab4b2c0286f85f99ca3678231f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gad4401eab4b2c0286f85f99ca3678231f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad4401eab4b2c0286f85f99ca3678231f">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad4401eab4b2c0286f85f99ca3678231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad4401eab4b2c0286f85f99ca3678231f">More...</a><br /></td></tr>
<tr class="separator:gad4401eab4b2c0286f85f99ca3678231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21bcbebe0da44b063db887054059b0c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa21bcbebe0da44b063db887054059b0c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa21bcbebe0da44b063db887054059b0c">blaze::operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa21bcbebe0da44b063db887054059b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa21bcbebe0da44b063db887054059b0c">More...</a><br /></td></tr>
<tr class="separator:gaa21bcbebe0da44b063db887054059b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773550f06605b4dc62861b9f91f1d58a"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga773550f06605b4dc62861b9f91f1d58a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga773550f06605b4dc62861b9f91f1d58a">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga773550f06605b4dc62861b9f91f1d58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga773550f06605b4dc62861b9f91f1d58a">More...</a><br /></td></tr>
<tr class="separator:ga773550f06605b4dc62861b9f91f1d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538517469f8425113b673d9905a20e51"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga538517469f8425113b673d9905a20e51"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga538517469f8425113b673d9905a20e51">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga538517469f8425113b673d9905a20e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga538517469f8425113b673d9905a20e51">More...</a><br /></td></tr>
<tr class="separator:ga538517469f8425113b673d9905a20e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e862d2cafa1c47b4b9c2003670afc6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaf9e862d2cafa1c47b4b9c2003670afc6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf9e862d2cafa1c47b4b9c2003670afc6">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf9e862d2cafa1c47b4b9c2003670afc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaf9e862d2cafa1c47b4b9c2003670afc6">More...</a><br /></td></tr>
<tr class="separator:gaf9e862d2cafa1c47b4b9c2003670afc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28bba35fd831df2c7fa62f2919ff265"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab28bba35fd831df2c7fa62f2919ff265"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab28bba35fd831df2c7fa62f2919ff265">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab28bba35fd831df2c7fa62f2919ff265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gab28bba35fd831df2c7fa62f2919ff265">More...</a><br /></td></tr>
<tr class="separator:gab28bba35fd831df2c7fa62f2919ff265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669526d3b6e258be4c307105e35e84f8"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:ga669526d3b6e258be4c307105e35e84f8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga669526d3b6e258be4c307105e35e84f8">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga669526d3b6e258be4c307105e35e84f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga669526d3b6e258be4c307105e35e84f8">More...</a><br /></td></tr>
<tr class="separator:ga669526d3b6e258be4c307105e35e84f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrix operators</h2></td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7120542028164e84f57b2bd0daf1ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two rwo-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">More...</a><br /></td></tr>
<tr class="separator:ga7120542028164e84f57b2bd0daf1ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3e85fa1492d985e034b7ca152d69dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">More...</a><br /></td></tr>
<tr class="separator:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense matrices with different storage order.  <a href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">More...</a><br /></td></tr>
<tr class="separator:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a row-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">More...</a><br /></td></tr>
<tr class="separator:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a column-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">More...</a><br /></td></tr>
<tr class="separator:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga242470c706af7ba3a96eb35a1816b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">More...</a><br /></td></tr>
<tr class="separator:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga11775fe4d60690cbdc76e71ccb71c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a row-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga11775fe4d60690cbdc76e71ccb71c545">More...</a><br /></td></tr>
<tr class="separator:ga11775fe4d60690cbdc76e71ccb71c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab3947c9d43314d45fb4e000ff4a08859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">blaze::operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gab3947c9d43314d45fb4e000ff4a08859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a column-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#gab3947c9d43314d45fb4e000ff4a08859">More...</a><br /></td></tr>
<tr class="separator:gab3947c9d43314d45fb4e000ff4a08859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">More...</a><br /></td></tr>
<tr class="separator:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga174d0a369968b438ed23725b3361283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">More...</a><br /></td></tr>
<tr class="separator:ga174d0a369968b438ed23725b3361283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">blaze::operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">More...</a><br /></td></tr>
<tr class="separator:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">blaze::operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga5bb8b9fb92ead32a2907a21c4bd81a91">More...</a><br /></td></tr>
<tr class="separator:ga5bb8b9fb92ead32a2907a21c4bd81a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrix functions</h2></td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">blaze::isnan</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga99ba6a5b32152077ba7d013be1add4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense matrix for not-a-number elements.  <a href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">More...</a><br /></td></tr>
<tr class="separator:ga99ba6a5b32152077ba7d013be1add4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6f1a7ad7504c911e99f6e84a57ec73"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacc6f1a7ad7504c911e99f6e84a57ec73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">blaze::isSymmetric</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gacc6f1a7ad7504c911e99f6e84a57ec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is symmetric.  <a href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">More...</a><br /></td></tr>
<tr class="separator:gacc6f1a7ad7504c911e99f6e84a57ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac019dffc6f1692e1554eb4ec3c6359a8"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac019dffc6f1692e1554eb4ec3c6359a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">blaze::isHermitian</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gac019dffc6f1692e1554eb4ec3c6359a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is Hermitian.  <a href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">More...</a><br /></td></tr>
<tr class="separator:gac019dffc6f1692e1554eb4ec3c6359a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd6724c4c75998517110808090ad74c"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7cd6724c4c75998517110808090ad74c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">blaze::isUniform</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga7cd6724c4c75998517110808090ad74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a uniform matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">More...</a><br /></td></tr>
<tr class="separator:ga7cd6724c4c75998517110808090ad74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e4cc18360144e03649b843b3e71d5d"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga76e4cc18360144e03649b843b3e71d5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">blaze::isLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga76e4cc18360144e03649b843b3e71d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">More...</a><br /></td></tr>
<tr class="separator:ga76e4cc18360144e03649b843b3e71d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21ed126177b5c18bff85c2665e2bfa9"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa21ed126177b5c18bff85c2665e2bfa9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">blaze::isUniLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaa21ed126177b5c18bff85c2665e2bfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a lower unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">More...</a><br /></td></tr>
<tr class="separator:gaa21ed126177b5c18bff85c2665e2bfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119bf55e86f4c944024cda1117c11de7"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga119bf55e86f4c944024cda1117c11de7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">blaze::isStrictlyLower</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga119bf55e86f4c944024cda1117c11de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly lower triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">More...</a><br /></td></tr>
<tr class="separator:ga119bf55e86f4c944024cda1117c11de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3bafc9d47a1c4c6ff26d0997c1218be"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae3bafc9d47a1c4c6ff26d0997c1218be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">blaze::isUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gae3bafc9d47a1c4c6ff26d0997c1218be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">More...</a><br /></td></tr>
<tr class="separator:gae3bafc9d47a1c4c6ff26d0997c1218be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fb30f7100507698da7138a291adc68"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad7fb30f7100507698da7138a291adc68"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">blaze::isUniUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gad7fb30f7100507698da7138a291adc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is an upper unitriangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">More...</a><br /></td></tr>
<tr class="separator:gad7fb30f7100507698da7138a291adc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4088222c02c754e9b3a7306f133fbf"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabe4088222c02c754e9b3a7306f133fbf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">blaze::isStrictlyUpper</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gabe4088222c02c754e9b3a7306f133fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense matrix is a strictly upper triangular matrix.  <a href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">More...</a><br /></td></tr>
<tr class="separator:gabe4088222c02c754e9b3a7306f133fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26e04b0050c0d9ec960e21184d063ee"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae26e04b0050c0d9ec960e21184d063ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">blaze::isDiagonal</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gae26e04b0050c0d9ec960e21184d063ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is diagonal.  <a href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">More...</a><br /></td></tr>
<tr class="separator:gae26e04b0050c0d9ec960e21184d063ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4377bd3eea37726b161b1224c2d1604"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf4377bd3eea37726b161b1224c2d1604"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">blaze::isIdentity</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaf4377bd3eea37726b161b1224c2d1604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give dense matrix is an identity matrix.  <a href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">More...</a><br /></td></tr>
<tr class="separator:gaf4377bd3eea37726b161b1224c2d1604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">blaze::min</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1147d0f93d7cc6fad33935048f2b058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">More...</a><br /></td></tr>
<tr class="separator:ga1147d0f93d7cc6fad33935048f2b058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">blaze::max</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">More...</a><br /></td></tr>
<tr class="separator:ga6ae2749f3a298c7927a4f7f85407e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Eigenvalue functions</h2></td></tr>
<tr class="memitem:ga1591984e463b7e778e7cd348b2952992"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1591984e463b7e778e7cd348b2952992"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">blaze::eigen</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;w)</td></tr>
<tr class="memdesc:ga1591984e463b7e778e7cd348b2952992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue computation of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">More...</a><br /></td></tr>
<tr class="separator:ga1591984e463b7e778e7cd348b2952992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc6e2692030c8f1411607ac8159b274"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename VT , bool TF, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga4fc6e2692030c8f1411607ac8159b274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4fc6e2692030c8f1411607ac8159b274">blaze::eigen</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;w, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;V)</td></tr>
<tr class="memdesc:ga4fc6e2692030c8f1411607ac8159b274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue computation of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga4fc6e2692030c8f1411607ac8159b274">More...</a><br /></td></tr>
<tr class="separator:ga4fc6e2692030c8f1411607ac8159b274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Inversion functions</h2></td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">blaze::invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga1703390e63b9cb5b805ab5b4718ddda3">More...</a><br /></td></tr>
<tr class="separator:ga1703390e63b9cb5b805ab5b4718ddda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplParams" colspan="2">template&lt;InversionFlag IF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">blaze::invert</a> (<a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inversion of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga4c0fd934e9c1b84cc2588cfe142c55a4">More...</a><br /></td></tr>
<tr class="separator:ga4c0fd934e9c1b84cc2588cfe142c55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LLH decomposition functions</h2></td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga63e7f6efe504ec8f7416decef5446662"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">blaze::llh</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L)</td></tr>
<tr class="memdesc:ga63e7f6efe504ec8f7416decef5446662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky (LLH) decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">More...</a><br /></td></tr>
<tr class="separator:ga63e7f6efe504ec8f7416decef5446662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LQ decomposition functions</h2></td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga797f2c71d569b9abf5784ff118a308f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">blaze::lq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga797f2c71d569b9abf5784ff118a308f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">More...</a><br /></td></tr>
<tr class="separator:ga797f2c71d569b9abf5784ff118a308f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LU decomposition functions</h2></td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , typename MT3 , typename MT4 , bool SO2&gt; </td></tr>
<tr class="memitem:ga10d699031e948b83afcc0ffc68853d65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">blaze::lu</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO1 &gt; &amp;L, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO1 &gt; &amp;U, <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT4, SO2 &gt; &amp;P)</td></tr>
<tr class="memdesc:ga10d699031e948b83afcc0ffc68853d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">More...</a><br /></td></tr>
<tr class="separator:ga10d699031e948b83afcc0ffc68853d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
QL decomposition functions</h2></td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">blaze::ql</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;L)</td></tr>
<tr class="memdesc:gab7c1c25d32e228f167f4544cc950bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">QL decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">More...</a><br /></td></tr>
<tr class="separator:gab7c1c25d32e228f167f4544cc950bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
QR decomposition functions</h2></td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga92d7e3366b2e5020229aba1e123235d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">blaze::qr</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;Q, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;R)</td></tr>
<tr class="memdesc:ga92d7e3366b2e5020229aba1e123235d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">More...</a><br /></td></tr>
<tr class="separator:ga92d7e3366b2e5020229aba1e123235d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RQ decomposition functions</h2></td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:ga28d8769f4cf3189184544ab620949dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">blaze::rq</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;R, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;Q)</td></tr>
<tr class="memdesc:ga28d8769f4cf3189184544ab620949dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">RQ decomposition of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">More...</a><br /></td></tr>
<tr class="separator:ga28d8769f4cf3189184544ab620949dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Singular value decomposition functions</h2></td></tr>
<tr class="memitem:gaa1447bfde8e69e7c222e3a5da9b51272"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa1447bfde8e69e7c222e3a5da9b51272"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">blaze::svd</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;s)</td></tr>
<tr class="memdesc:gaa1447bfde8e69e7c222e3a5da9b51272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition (SVD) of the given dense general matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">More...</a><br /></td></tr>
<tr class="separator:gaa1447bfde8e69e7c222e3a5da9b51272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfe8f2447a5be2574ad15f2c01a203a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename VT , bool TF, typename MT2 , typename MT3 &gt; </td></tr>
<tr class="memitem:ga7bfe8f2447a5be2574ad15f2c01a203a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7bfe8f2447a5be2574ad15f2c01a203a">blaze::svd</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;U, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;s, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO &gt; &amp;V)</td></tr>
<tr class="memdesc:ga7bfe8f2447a5be2574ad15f2c01a203a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition (SVD) of the given dense general matrix.  <a href="../../db/df0/group__dense__matrix.html#ga7bfe8f2447a5be2574ad15f2c01a203a">More...</a><br /></td></tr>
<tr class="separator:ga7bfe8f2447a5be2574ad15f2c01a203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64a2d3b815fd6b0b7e394d946641a7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename VT , bool TF, typename ST &gt; </td></tr>
<tr class="memitem:gaeb64a2d3b815fd6b0b7e394d946641a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaeb64a2d3b815fd6b0b7e394d946641a7">blaze::svd</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;A, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;s, ST low, ST upp)</td></tr>
<tr class="memdesc:gaeb64a2d3b815fd6b0b7e394d946641a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition (SVD) of the given dense general matrix.  <a href="../../db/df0/group__dense__matrix.html#gaeb64a2d3b815fd6b0b7e394d946641a7">More...</a><br /></td></tr>
<tr class="separator:gaeb64a2d3b815fd6b0b7e394d946641a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa789d8d574f11a23e77f416398f69a7a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO, typename VT , bool TF, typename MT2 , typename MT3 , typename ST &gt; </td></tr>
<tr class="memitem:gaa789d8d574f11a23e77f416398f69a7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa789d8d574f11a23e77f416398f69a7a">blaze::svd</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;A, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;U, <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;s, <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO &gt; &amp;V, ST low, ST upp)</td></tr>
<tr class="memdesc:gaa789d8d574f11a23e77f416398f69a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition (SVD) of the given dense general matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa789d8d574f11a23e77f416398f69a7a">More...</a><br /></td></tr>
<tr class="separator:gaa789d8d574f11a23e77f416398f69a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrix global functions</h2></td></tr>
<tr class="memitem:gac8e3e0bc541793c506746cb254bc6bfd"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac8e3e0bc541793c506746cb254bc6bfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac8e3e0bc541793c506746cb254bc6bfd">blaze::spacing</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm) noexcept</td></tr>
<tr class="memdesc:gac8e3e0bc541793c506746cb254bc6bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing between the beginning of two rows/columns.  <a href="../../db/df0/group__dense__matrix.html#gac8e3e0bc541793c506746cb254bc6bfd">More...</a><br /></td></tr>
<tr class="separator:gac8e3e0bc541793c506746cb254bc6bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Determinant functions</h2></td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga152576fa391bcb9a2892063bdf3953f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">blaze::det</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga152576fa391bcb9a2892063bdf3953f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> of the determinant of the given dense square matrix.  <a href="../../db/df0/group__dense__matrix.html#ga152576fa391bcb9a2892063bdf3953f7">More...</a><br /></td></tr>
<tr class="separator:ga152576fa391bcb9a2892063bdf3953f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga82c7ab005f0a5070705195db86e7bae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c7ab005f0a5070705195db86e7bae4">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">abs</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga51c819795e3845b35ba6344a19a50b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c819795e3845b35ba6344a19a50b90">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">acos</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga328df782acd85cc3d5e3458eac531ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga328df782acd85cc3d5e3458eac531ace">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">acosh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga88e862dd7e670667e8520d80e2d4ba87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e862dd7e670667e8520d80e2d4ba87">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">asin</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga2fcf55ee4728e81c09d9c6ab90d7c734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fcf55ee4728e81c09d9c6ab90d7c734">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">asinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6887fb234d4aa28bf896f8e684fbe1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6887fb234d4aa28bf896f8e684fbe1e0">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">atan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae0632a5d595720be50b96079f29cdd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0632a5d595720be50b96079f29cdd55">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">atanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga208aae7dbc991f038bf8ec1d84afa989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208aae7dbc991f038bf8ec1d84afa989">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">cbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga86bec4639063b9b7cf5856973008a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86bec4639063b9b7cf5856973008a307">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">ceil</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga88b09502be6a6aee96c90a0bc7fa47ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b09502be6a6aee96c90a0bc7fa47ed">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the dense matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function restricts each element of the input matrix <em>dm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">clamp</a>( A, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4c3ba99bdcc46aaef2b7285a5054cacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3ba99bdcc46aaef2b7285a5054cacf">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the complex conjugate of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate complex of each single element of <em>dm</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae3ddccb3f7678e3c7a79c31af3af2b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ddccb3f7678e3c7a79c31af3af2b43">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">cos</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6a875b7f5942c159fb7dd5401fdcb88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a875b7f5942c159fb7dd5401fdcb88b">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">cosh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga654aa9bc341896a531363e297b65107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga654aa9bc341896a531363e297b65107e">&#9670;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose matrix of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>dm</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input matrix <em>dm</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( A );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga7187096e39dd93ef22367044b3600fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7187096e39dd93ef22367044b3600fe7">&#9670;&nbsp;</a></span>decldiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::decldiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given dense matrix expression <em>dm</em> as diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid diagonal matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decldiag</em> function declares the given dense matrix expression <em>dm</em> as diagonal. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decldiag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gada0ab0b8ff7fd8a57ada423a50011679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0ab0b8ff7fd8a57ada423a50011679">&#9670;&nbsp;</a></span>declherm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declherm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given dense matrix expression <em>dm</em> as Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid Hermitian matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declherm</em> function declares the given dense matrix expression <em>dm</em> as Hermitian. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declherm</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad34f841b05e0aa88e561d312168e6429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34f841b05e0aa88e561d312168e6429">&#9670;&nbsp;</a></span>decllow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::decllow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given dense matrix expression <em>dm</em> as lower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid lower matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decllow</em> function declares the given dense matrix expression <em>dm</em> as lower. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decllow</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gadf429fe0aac934e266ffef8aa0a284ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf429fe0aac934e266ffef8aa0a284ba">&#9670;&nbsp;</a></span>declsym()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declsym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given dense matrix expression <em>dm</em> as symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid symmetric matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declsym</em> function declares the given dense matrix expression <em>dm</em> as symmetric. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declsym</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaceb58b929e36557ec199ba79cbccd247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb58b929e36557ec199ba79cbccd247">&#9670;&nbsp;</a></span>declupp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declupp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given dense matrix expression <em>dm</em> as upper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared dense matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid upper matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declupp</em> function declares the given dense matrix expression <em>dm</em> as upper. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declupp</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga152576fa391bcb9a2892063bdf3953f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152576fa391bcb9a2892063bdf3953f7">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> of the determinant of the given dense square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the given matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the determinant of the given dense square matrix. The computation fails if the given matrix is not a square matrix. In this case either a compilation error is created (if possible) or a <em>std::invalid_argument</em> exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The computation of the determinant is numerically unreliable since especially for large matrices the value can overflow during the computation. Please note that this function does not guarantee that it is possible to compute the determinant with the given matrix!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created. </dd></dl>

</div>
</div>
<a id="ga1591984e463b7e778e7cd348b2952992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1591984e463b7e778e7cd348b2952992">&#9670;&nbsp;</a></span>eigen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eigenvalue computation of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">w</td><td>The resulting vector of eigenvalues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> cannot be resized. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Eigenvalue computation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the eigenvalues of the given <em>n-by-<em>n</em> matrix</em>. The eigenvalues are returned in the given vector <em>w</em>, which is resized to the correct size (if possible and necessary).</p>
<p>Please note that in case the given matrix is either a compile time symmetric matrix with floating point elements or an Hermitian matrix with complex elements, the resulting eigenvalues will be of floating point type and therefore the elements of the given eigenvalue vector are expected to be of floating point type. In all other cases they are expected to be of complex type. Also please note that for complex eigenvalues no order of eigenvalues can be assumed, except that complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>The function fails if ...</p>
<ul>
<li>... the given matrix <em>A</em> is not a square matrix;</li>
<li>... the given vector <em>w</em> is a fixed size vector and the size doesn't match;</li>
<li>... the eigenvalue computation fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt; A( 5UL, 5UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a>&gt; w( 5UL );  <span class="comment">// The vector for the complex eigenvalues</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">SymmetricMatrix&lt; DynamicMatrix&lt;double,rowMajor&gt; &gt; A( 5UL, 5UL );  <span class="comment">// The symmetric matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; w( 5UL );  <span class="comment">// The vector for the real eigenvalues</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; A( 5UL, 5UL );  <span class="comment">// The Hermitian matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; w( 5UL );  <span class="comment">// The vector for the real eigenvalues</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing eigenvalues and eigenvectors are available via the <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga2dcc3e1ac6a94822401b9557fc690abc" title="LAPACK kernel for computing the eigenvalues of the given dense general single precision column-major ...">geev()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga051495b2ab389057d587bbbc95f16253" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syev()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#gaff2466c93f4a7d488784f2e09d811cf8" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syevd()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga6f34e29a21060c84b33b981f0e122c48" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syevx()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#gad5b2259bbb7aa80aa671cd827770195f" title="LAPACK kernel for computing the eigenvalues of the given dense Hermitian single precision column-majo...">heev()</a>, heevd(), and <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga67c04ede59e883e66094977c6de50ae1" title="LAPACK kernel for computing the eigenvalues of the given dense Hermitian single precision complex col...">heevx()</a> functions. </dd></dl>

</div>
</div>
<a id="ga4fc6e2692030c8f1411607ac8159b274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fc6e2692030c8f1411607ac8159b274">&#9670;&nbsp;</a></span>eigen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename VT , bool TF, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eigenvalue computation of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">w</td><td>The resulting vector of eigenvalues. </td></tr>
    <tr><td class="paramname">V</td><td>The resulting matrix of eigenvectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> cannot be resized. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> cannot be resized. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Eigenvalue computation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the eigenvalues and eigenvectors of the given <em>n-by-<em>n</em> matrix</em>. The eigenvalues are returned in the given vector <em>w</em> and the eigenvectors are returned in the given matrix <em>V</em>, which are both resized to the correct dimensions (if possible and necessary).</p>
<p>Please note that in case the given matrix is either a compile time symmetric matrix with floating point elements or an Hermitian matrix with complex elements, the resulting eigenvalues will be of floating point type and therefore the elements of the given eigenvalue vector are expected to be of floating point type. In all other cases they are expected to be of complex type. Also please note that for complex eigenvalues no order of eigenvalues can be assumed, except that complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having the positive imaginary part first.</p>
<p>In case <em>A</em> is a row-major matrix, the left eigenvectors are returned in the rows of <em>V</em>, in case <em>A</em> is a column-major matrix, the right eigenvectors are returned in the columns of <em>V</em>. In case the given matrix is a compile time symmetric matrix with floating point elements, the resulting eigenvectors will be of floating point type and therefore the elements of the given eigenvector matrix are expected to be of floating point type. In all other cases they are expected to be of complex type.</p>
<p>The function fails if ...</p>
<ul>
<li>... the given matrix <em>A</em> is not a square matrix;</li>
<li>... the given vector <em>w</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given matrix <em>V</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the eigenvalue computation fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt; A( 5UL, 5UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a>&gt; w( 5UL );   <span class="comment">// The vector for the complex eigenvalues</span></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">SymmetricMatrix&lt; DynamicMatrix&lt;double,rowMajor&gt; &gt; A( 5UL, 5UL );  <span class="comment">// The symmetric matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; w( 5UL );       <span class="comment">// The vector for the real eigenvalues</span></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../dd/df4/classblaze_1_1HermitianMatrix.html">blaze::HermitianMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">HermitianMatrix&lt; DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; &gt; A( 5UL, 5UL );  <span class="comment">// The Hermitian matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt;      w( 5UL );       <span class="comment">// The vector for the real eigenvalues</span></div><div class="line">DynamicMatrix&lt;complex&lt;double&gt;,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; V( 5UL, 5UL );  <span class="comment">// The matrix for the left eigenvectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga1591984e463b7e778e7cd348b2952992">eigen</a>( A, w, V );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing eigenvalues and eigenvectors are available via the <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga2dcc3e1ac6a94822401b9557fc690abc" title="LAPACK kernel for computing the eigenvalues of the given dense general single precision column-major ...">geev()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga051495b2ab389057d587bbbc95f16253" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syev()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#gaff2466c93f4a7d488784f2e09d811cf8" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syevd()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga6f34e29a21060c84b33b981f0e122c48" title="LAPACK kernel for computing the eigenvalues of the given dense symmetric single precision column-majo...">syevx()</a>, <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#gad5b2259bbb7aa80aa671cd827770195f" title="LAPACK kernel for computing the eigenvalues of the given dense Hermitian single precision column-majo...">heev()</a>, heevd(), and <a class="el" href="../../d7/d1c/group__lapack__eigenvalue.html#ga67c04ede59e883e66094977c6de50ae1" title="LAPACK kernel for computing the eigenvalues of the given dense Hermitian single precision complex col...">heevx()</a> functions. </dd></dl>

</div>
</div>
<a id="gae8d14e06526209c8debb6b384e145608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d14e06526209c8debb6b384e145608">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">erf</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa64b4501c6c359d0fc9955de26f1e0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64b4501c6c359d0fc9955de26f1e0ca">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">erfc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga19b5ef8a28958146c85a18ef72886b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19b5ef8a28958146c85a18ef72886b82">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given dense matrix expression <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense matrix.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given dense matrix expression <em>dm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">eval</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga01d9361c0ee99c282d650adca58fc817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01d9361c0ee99c282d650adca58fc817">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga5384d15bbb975be8c0c72b8a2193cd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5384d15bbb975be8c0c72b8a2193cd81">&#9670;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">exp10</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1842bcb4ac9e245fdd079dc469499d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1842bcb4ac9e245fdd079dc469499d32">&#9670;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">exp2</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga17215f7077a9cacabf3d29ffb85cdd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17215f7077a9cacabf3d29ffb85cdd30">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">floor</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7ae0b42de3d71f8c56366bd9564f6cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae0b42de3d71f8c56366bd9564f6cea">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">forEach</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaec095b59eb71bbc86cce1fda1e5d2947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec095b59eb71bbc86cce1fda1e5d2947">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the imaginary part of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>dm</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad1340e62509cbdcd565c028bf42842e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1340e62509cbdcd565c028bf42842e4">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the inverse of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the matrix.</dd></dl>
<p>This function returns an expression representing the inverse of the given dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
It is not possible to use any kind of view on the expression object returned by the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4" title="Calculation of the inverse of the given dense matrix. ">inv()</a></code> function. Also, it is not possible to access individual elements via the function call operator on the expression object:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d0/d48/group__views.html#ga062bf148d887c56afde41f4649897dbe">row</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A ), 2UL );  <span class="comment">// Compilation error: Views cannot be used on an inv() expression!</span></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gad1340e62509cbdcd565c028bf42842e4">inv</a>( A )(1,2);         <span class="comment">// Compilation error: It is not possible to access individual elements!</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga3ac8a6a6b4610343c75aa2e3a537692e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ac8a6a6b4610343c75aa2e3a537692e">&#9670;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">invcbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga1703390e63b9cb5b805ab5b4718ddda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1703390e63b9cb5b805ab5b4718ddda3">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Inversion of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the given dense square matrix. The matrix inversion fails if ...</p>
<ul>
<li>... the given matrix is not a square matrix;</li>
<li>... the given matrix is singular and not invertible.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>dm</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga4c0fd934e9c1b84cc2588cfe142c55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0fd934e9c1b84cc2588cfe142c55a4">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;InversionFlag IF, typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place inversion of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Inversion of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inverts the given dense matrix by means of the specified matrix type or matrix inversion algorithm <code>IF</code> (see the InversionFlag documentation):</p>
<div class="fragment"><div class="line">invert&lt;asLower&gt;( A );     <span class="comment">// Inversion of a lower triangular matrix</span></div><div class="line">invert&lt;asUniUpper&gt;( A );  <span class="comment">// Inversion of an upper unitriangular matrix</span></div><div class="line">invert&lt;byLU&gt;( A );        <span class="comment">// Inversion by means of an LU decomposition</span></div><div class="line">invert&lt;byLLH&gt;( A );       <span class="comment">// Inversion by means of a Cholesky decomposition</span></div><div class="line">...</div></div><!-- fragment --><p>The matrix inversion fails if ...</p>
<ul>
<li>... the given matrix is not a square matrix;</li>
<li>... the given matrix is singular and not invertible.</li>
</ul>
<p>In all failure cases either a compilation error is created if the failure can be predicted at compile time or an exception is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix inversion can only be used for dense matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code> or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a linker error will be created.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>dm</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga25a5afb293f1b00e1e9fedbc9eeb830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25a5afb293f1b00e1e9fedbc9eeb830f">&#9670;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">invsqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gae26e04b0050c0d9ec960e21184d063ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26e04b0050c0d9ec960e21184d063ee">&#9670;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give dense matrix is diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is diagonal, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is diagonal, i.e. if the non-diagonal elements are default elements. In case of integral or floating point data types, a diagonal matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} aa &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; bb &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; cc &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; xx \\ \end{array}\right)\]" src="../../form_55.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_48.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_49.png"/> matrices are considered as trivially diagonal. The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isDiagonal&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a diagonal matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gac019dffc6f1692e1554eb4ec3c6359a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac019dffc6f1692e1554eb4ec3c6359a8">&#9670;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isHermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is Hermitian, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an Hermitian matrix. The matrix is considered to be an Hermitian matrix if it is a square matrix whose conjugate transpose is equal to itself ( <img class="formulaInl" alt="$ A = \overline{A^T} $" src="../../form_22.png"/>), i.e. each matrix element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> is equal to the complex conjugate of the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">isHermitian</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isHermitian&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an Hermitian matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">isHermitian</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gaf4377bd3eea37726b161b1224c2d1604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4377bd3eea37726b161b1224c2d1604">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give dense matrix is an identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an identity matrix, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is an identity matrix, i.e. if the diagonal elements are 1 and the non-diagonal elements are 0. In case of integral or floating point data types, an identity matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array}\right)\]" src="../../form_56.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isIdentity&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an identity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga76e4cc18360144e03649b843b3e71d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e4cc18360144e03649b843b3e71d5d">&#9670;&nbsp;</a></span>isLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a lower triangular matrix. The matrix is considered to be lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} l_{0,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; l_{1,1} &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; l_{2,2} &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; l_{N,N} \\ \end{array}\right).\]" src="../../form_47.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_48.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_49.png"/> matrices are considered as trivially lower triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga99ba6a5b32152077ba7d013be1add4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ba6a5b32152077ba7d013be1add4dc">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given dense matrix for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The matrix to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the dense matrix for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> at least one element of the matrix is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for matrices with floating point elements. The attempt to use it for a matrix with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga119bf55e86f4c944024cda1117c11de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119bf55e86f4c944024cda1117c11de7">&#9670;&nbsp;</a></span>isStrictlyLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a strictly lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a strictly lower triangular matrix. The matrix is considered to be strictly lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_51.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">isStrictlyLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isStrictlyLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">isStrictlyLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gabe4088222c02c754e9b3a7306f133fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4088222c02c754e9b3a7306f133fbf">&#9670;&nbsp;</a></span>isStrictlyUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a strictly upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a strictly upper triangular matrix. The matrix is considered to be strictly upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 0 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_54.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">isStrictlyUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isStrictlyUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">isStrictlyUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gacc6f1a7ad7504c911e99f6e84a57ec73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc6f1a7ad7504c911e99f6e84a57ec73">&#9670;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is symmetric, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is symmetric. The matrix is considered to be symmetric if it is a square matrix whose transpose is equal to itself ( <img class="formulaInl" alt="$ A = A^T $" src="../../form_23.png"/>). The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isSymmetric&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a symmetric matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga7cd6724c4c75998517110808090ad74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd6724c4c75998517110808090ad74c">&#9670;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a uniform matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a uniform matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a uniform matrix. The matrix is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniform&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a uniform matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gaa21ed126177b5c18bff85c2665e2bfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21ed126177b5c18bff85c2665e2bfa9">&#9670;&nbsp;</a></span>isUniLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is a lower unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is a lower unitriangular matrix. The matrix is considered to be lower unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_50.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">isUniLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">isUniLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gad7fb30f7100507698da7138a291adc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7fb30f7100507698da7138a291adc68">&#9670;&nbsp;</a></span>isUniUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is an upper unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an upper unitriangular matrix. The matrix is considered to be upper unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 1 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_53.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">isUniUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">isUniUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gae3bafc9d47a1c4c6ff26d0997c1218be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bafc9d47a1c4c6ff26d0997c1218be">&#9670;&nbsp;</a></span>isUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense matrix is an upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense matrix is an upper triangular matrix. The matrix is considered to be upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} u_{0,0} &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; u_{1,1} &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; u_{2,2} &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{N,N} \\ \end{array}\right).\]" src="../../form_52.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_48.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_49.png"/> matrices are considered as trivially upper triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga63e7f6efe504ec8f7416decef5446662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e7f6efe504ec8f7416decef5446662">&#9670;&nbsp;</a></span>llh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::llh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cholesky (LLH) decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting lower triangular matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid non-square matrix provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Decomposition of singular matrix failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix Cholesky (LLH) decomposition of a positive definite n-by-n matrix. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot L^{H}, \]" src="../../form_67.png"/>
</p>
<p>where <code>L</code> is a lower triangular n-by-n matrix. The decomposition is written to the matrix <code>L</code>, which is resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... <em>A</em> is not a square matrix;</li>
<li>... <em>L</em> is a fixed size matrix and the dimensions don't match <em>A</em>.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 32 );</div><div class="line"><span class="comment">// ... Initialization of A as positive definite matrix</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 32, 32 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga63e7f6efe504ec8f7416decef5446662">llh</a>( A, L );</div><div class="line"></div><div class="line">assert( A == L * <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( L ) );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
This function does only provide the basic exception safety guarantee, i.e. in case of an exception <em>L</em> may already have been modified. </dd></dl>

</div>
</div>
<a id="ga33c9b9a39f0e7c6637b6af4f5e252e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33c9b9a39f0e7c6637b6af4f5e252e7a">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes natural logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">log</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaac5b7d6556dffdfa9fb311d5ce5dd7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5b7d6556dffdfa9fb311d5ce5dd7de">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes common logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">log10</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga75e400cfca815316f564e56795cb7208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e400cfca815316f564e56795cb7208">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes binary logarithm for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">log2</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga797f2c71d569b9abf5784ff118a308f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga797f2c71d569b9abf5784ff118a308f2">&#9670;&nbsp;</a></span>lq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::lq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LQ decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting <code>L</code> matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix LQ decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot Q, \]" src="../../form_68.png"/>
</p>
<p>where <code>L</code> is a lower trapezoidal <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>Q</code> is a general min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>L</code> and <code>Q</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>L</em> or <em>Q</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>L</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga797f2c71d569b9abf5784ff118a308f2">lq</a>( A, L, Q );</div><div class="line"></div><div class="line">assert( A == L * Q );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga10d699031e948b83afcc0ffc68853d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d699031e948b83afcc0ffc68853d65">&#9670;&nbsp;</a></span>lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , typename MT3 , typename MT4 , bool SO2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::lu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT4, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting lower triangular matrix. </td></tr>
    <tr><td class="paramname">U</td><td>The resulting upper triangular matrix. </td></tr>
    <tr><td class="paramname">P</td><td>The resulting permutation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix (P)LU decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition is written to the three distinct matrices <code>L</code>, <code>U</code>, and <code>P</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>In case of a column-major matrix the algorithm performs the decomposition using partial pivoting with row interchanges. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = P \cdot L \cdot U, \]" src="../../form_69.png"/>
</p>
<p>where <code>P</code> is an m-by-m permutation matrix, which represents the pivoting indices for the applied row interchanges, <code>L</code> is a lower triangular matrix (lower trapezoidal if <em>m</em> &gt; <em>n</em>), and <code>U</code> is an upper triangular matrix (upper trapezoidal if <em>m</em> &lt; <em>n</em>).</p>
<p>In case of a row-major matrix the algorithm performs the decomposition using partial pivoting with column interchanges. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = L \cdot U \cdot P, \]" src="../../form_70.png"/>
</p>
<p>where <code>L</code> is a lower triangular matrix (lower trapezoidal if <em>m</em> &gt; <em>n</em>), <code>U</code> is an upper triangular matrix (upper trapezoidal if <em>m</em> &lt; <em>n</em>), and <code>P</code> is an n-by-n permutation matrix, which represents the pivoting indices for the applied column interchanges.</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>L</em>, <em>U</em>, and <em>P</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>A</em> is a non-square m-by-n matrix, but <em>L</em> or <em>U</em> is a compile time square matrix.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a row-major matrix</span></div><div class="line"></div><div class="line">assert( A == L * U * P );</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L, U, P;</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga10d699031e948b83afcc0ffc68853d65">lu</a>( A, L, U, P );  <span class="comment">// LU decomposition of a column-major matrix</span></div><div class="line"></div><div class="line">assert( A == P * L * U );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
The LU decomposition will never fail, even for singular matrices. However, in case of a singular matrix the resulting decomposition cannot be used for a matrix inversion or solving a linear system of equations. </dd></dl>

</div>
</div>
<a id="gaa8cd81a56f3eba22cad93ecdac1f6e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8cd81a56f3eba22cad93ecdac1f6e3f">&#9670;&nbsp;</a></span>map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given binary operation on each single element of the row-major dense matrix <em>lhs</em> and the column-major dense matrix <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">op</td><td>The custom, binary operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary operation applied to each single element of <em>lhs</em> and <em>rhs</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given binary operation on each element of the input matrices <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, B, []( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">std::min</a>( x, y ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac96504530f58ab9c0c14d43db5062941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac96504530f58ab9c0c14d43db5062941">&#9670;&nbsp;</a></span>map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given custom operation on each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaaeacb52db2d3b774340603c1cb32916b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeacb52db2d3b774340603c1cb32916b">&#9670;&nbsp;</a></span>map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given binary operation on each single element of the dense matrices <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">op</td><td>The custom, binary operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary operation applied to each single element of <em>lhs</em> and <em>rhs</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given binary operation on each element of the input matrices <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, B, []( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">std::min</a>( x, y ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga0e285167479738f19015c046c43d4f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e285167479738f19015c046c43d4f20">&#9670;&nbsp;</a></span>map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given binary operation on each single element of the column-major dense matrix <em>lhs</em> and the row-major dense matrix <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">op</td><td>The custom, binary operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary operation applied to each single element of <em>lhs</em> and <em>rhs</em>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given binary operation on each element of the input matrices <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, B, []( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">std::min</a>( x, y ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6ae2749f3a298c7927a4f7f85407e2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae2749f3a298c7927a4f7f85407e2c4">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest dense matrix element.</dd></dl>
<p>This function returns the largest element of the given dense matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga1e1875344775bac54b6b519240a70249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e1875344775bac54b6b519240a70249">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the componentwise maximum of the dense matrices <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function computes the componentwise maximum of the two dense matrix <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4" title="Returns the largest element of the dense matrix. ">max()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>( A, B );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1147d0f93d7cc6fad33935048f2b058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1147d0f93d7cc6fad33935048f2b058e">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest dense matrix element.</dd></dl>
<p>This function returns the smallest element of the given dense matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga199758e48efa146deeb0f8c7ec70a41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199758e48efa146deeb0f8c7ec70a41e">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the componentwise minimum of the dense matrices <em>lhs</em> and <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function computes the componentwise minimum of the two dense matrices <em>lhs</em> and <em>rhs</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( A, B );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga52848b40fa0e5a7f72bdcdd92d68f032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52848b40fa0e5a7f72bdcdd92d68f032">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga174d0a369968b438ed23725b3361283c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174d0a369968b438ed23725b3361283c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense matrix and a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="gaa83dce66f3d82b99bb0dd83aa3efb7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83dce66f3d82b99bb0dd83aa3efb7a4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a sparse matrix and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga5bb8b9fb92ead32a2907a21c4bd81a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bb8b9fb92ead32a2907a21c4bd81a91">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> one value of the matrix is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga8ab1683cf0ef1f675329a4d27d45751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab1683cf0ef1f675329a4d27d45751c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, bool &gt; blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a scalar value and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the matrix is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> one value of the matrix is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="gaaa6e70850e82b26b1bc1a8ec96c8928b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa6e70850e82b26b1bc1a8ec96c8928b">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga813d50acb276268ae73d318d26ec7589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813d50acb276268ae73d318d26ec7589">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of two dense matrices with identical storage order:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga85d11c54cf49e9e36a28619e3cdd6497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d11c54cf49e9e36a28619e3cdd6497">&#9670;&nbsp;</a></span>operator%() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga773550f06605b4dc62861b9f91f1d58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga773550f06605b4dc62861b9f91f1d58a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the dense matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga669526d3b6e258be4c307105e35e84f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga669526d3b6e258be4c307105e35e84f8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the dense matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga8d8328fedcc976aeb84fefef81a2bd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8328fedcc976aeb84fefef81a2bd37">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major dense matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gad4401eab4b2c0286f85f99ca3678231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4401eab4b2c0286f85f99ca3678231f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two column-major dense matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gae140ed6f1bb88fb30d862b48472b63c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae140ed6f1bb88fb30d862b48472b63c5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa21bcbebe0da44b063db887054059b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21bcbebe0da44b063db887054059b0c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaaf85cb4e827a302abce5c26093cfc545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf85cb4e827a302abce5c26093cfc545">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4d945707e20439dba85a43ae35426b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d945707e20439dba85a43ae35426b77">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga538517469f8425113b673d9905a20e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga538517469f8425113b673d9905a20e51">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab28bba35fd831df2c7fa62f2919ff265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28bba35fd831df2c7fa62f2919ff265">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaaca591785e5e6274c21f0419dc66b8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca591785e5e6274c21f0419dc66b8ae">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a dense matrix and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A * 1.25;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>MT::ElementType</em> and <em>ST</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="gaa42e7c97f0fce4001aae83fb66342cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42e7c97f0fce4001aae83fb66342cf1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST , typename MT , bool SO, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = 1.25 * A;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>ST</em> and <em>MT::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga26de0fe326c4fd2d78e12f94911d2c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26de0fe326c4fd2d78e12f94911d2c8e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga40079d5f49f4df43ff74d4ba223203d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40079d5f49f4df43ff74d4ba223203d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaea907a979f0cec455ac5149366838dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea907a979f0cec455ac5149366838dc7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose dense vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This operator represents the outer product between a dense vector and a transpose dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>(b);</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both dense vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="gaa04b26cff3f714e53d6dd46349edb38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04b26cff3f714e53d6dd46349edb38d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major dense matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gad7a8dd3b5e883329b16a6ae2bbef003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a8dd3b5e883329b16a6ae2bbef003e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two row-major dense matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of columns of <em>lhs</em> and the current number of rows of <em>rhs</em> don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gadb8ec1bf94f953318e60e59fa96a1725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8ec1bf94f953318e60e59fa96a1725">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga006a4acb3dc87708db2565de4a2fb91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga006a4acb3dc87708db2565de4a2fb91c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga30e62c0bb707ea6b842d0410e0d40b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e62c0bb707ea6b842d0410e0d40b76">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a dense matrix and a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga107f1d1fbdf21570e52814b4075956e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga107f1d1fbdf21570e52814b4075956e9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga6953c59b2870d26f0b02abafc81aba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6953c59b2870d26f0b02abafc81aba8f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a sparse matrix and a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga989eee6872d32ecad706d81823e425b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989eee6872d32ecad706d81823e425b1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7839b98910e4512ab833ee634a76611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7839b98910e4512ab833ee634a76611c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga04d2bd49b16ccde7bfff7d45dc49d54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04d2bd49b16ccde7bfff7d45dc49d54d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two dense matrices with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gacf12017816dec6bbde0dc13e34dd59be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf12017816dec6bbde0dc13e34dd59be">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga367f085a8b3f9d720d3f90a99cc241a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367f085a8b3f9d720d3f90a99cc241a7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf6e9ec85dcae52e8cae48000d83b8cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e9ec85dcae52e8cae48000d83b8cda">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a sparse matrix and a dense matrix with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gae1f30ec1191442c02f58e7f43b7944b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f30ec1191442c02f58e7f43b7944b7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf9e862d2cafa1c47b4b9c2003670afc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e862d2cafa1c47b4b9c2003670afc6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga8f24ddb3b90d7b260b3699abecdd3c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f24ddb3b90d7b260b3699abecdd3c86">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a dense matrix and a sparse matrix with identical storage order:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga756f1d83d0ed56e42610cd8e15691824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756f1d83d0ed56e42610cd8e15691824">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4540d43d7359634146e2b2f744a72fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4540d43d7359634146e2b2f744a72fba">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac8e08d35ce1bef6f878ba98e7bedf891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8e08d35ce1bef6f878ba98e7bedf891">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_95.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the matrix.</dd></dl>
<p>This operator represents the negation of a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = -A;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given dense matrix. </p>

</div>
</div>
<a id="gab727f40b4fd08c2c054646d21bbde630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab727f40b4fd08c2c054646d21bbde630">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two dense matrices with identical storage order:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7fcc6f2b30ad8c4697ef1d1f16ba102e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcc6f2b30ad8c4697ef1d1f16ba102e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga03f7cce19ada0cda6d89630d8e4c7211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f7cce19ada0cda6d89630d8e4c7211">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_94.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the division of a dense matrix by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A / 0.24;</div></div><!-- fragment --><p>The operator returns an expression representing a dense matrix of the higher-order element type of the involved data types <em>MT::ElementType</em> and <em>ST</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="ga7120542028164e84f57b2bd0daf1ed07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7120542028164e84f57b2bd0daf1ed07">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two rwo-major dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga3e85fa1492d985e034b7ca152d69dac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e85fa1492d985e034b7ca152d69dac2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major dense matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gacff1ea4c8128a09b47db0c324da5c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff1ea4c8128a09b47db0c324da5c2f0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two dense matrices with different storage order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga192685ae7dfdfa74ee94a9d6c51d1809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192685ae7dfdfa74ee94a9d6c51d1809">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense matrix and a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side row-major sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga8212c8f46b5a2e31e355922f8fc2e3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8212c8f46b5a2e31e355922f8fc2e3fc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense matrix and a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side column-major sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga242470c706af7ba3a96eb35a1816b4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242470c706af7ba3a96eb35a1816b4cf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a sparse matrix and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga11775fe4d60690cbdc76e71ccb71c545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11775fe4d60690cbdc76e71ccb71c545">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a row-major dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="gab3947c9d43314d45fb4e000ff4a08859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3947c9d43314d45fb4e000ff4a08859">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a column-major dense matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga25855a1d3c48eb1cb6f3f5a66842a85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25855a1d3c48eb1cb6f3f5a66842a85e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt;<a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;T1&gt;, bool &gt; blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a scalar value and a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the matrix are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> all values of the matrix are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a id="ga50f9950dc0a14952d77cb22307cee5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f9950dc0a14952d77cb22307cee5bb">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab7c1c25d32e228f167f4544cc950bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c1c25d32e228f167f4544cc950bf1f">&#9670;&nbsp;</a></span>ql()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::ql </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QL decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
    <tr><td class="paramname">L</td><td>The resulting <code>L</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix QL decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = Q \cdot L, \]" src="../../form_71.png"/>
</p>
<p>where <code>Q</code> is a general <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>L</code> is a lower trapezoidal <em>min</em>(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>Q</code> and <code>L</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>Q</em> or <em>L</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>L</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> L( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gab7c1c25d32e228f167f4544cc950bf1f">ql</a>( A, Q, L );</div><div class="line"></div><div class="line">assert( A == Q * L );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga92d7e3366b2e5020229aba1e123235d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d7e3366b2e5020229aba1e123235d6">&#9670;&nbsp;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::qr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QR decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
    <tr><td class="paramname">R</td><td>The resulting <code>R</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to m-by-n.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix QR decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = Q \cdot R, \]" src="../../form_72.png"/>
</p>
<p>where <code>Q</code> is a general <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>R</code> is an upper trapezoidal min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>Q</code> and <code>R</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>Q</em> or <em>R</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>R</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> R( 16, 16 );</div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga92d7e3366b2e5020229aba1e123235d6">qr</a>( A, Q, R );</div><div class="line"></div><div class="line">assert( A == Q * R );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="ga3efb8c5066fb6ae23b0ab8d3408e1b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the real part of each single element of <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>dm</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac9c035640c6ebfe1669dbe275009de90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9c035640c6ebfe1669dbe275009de90">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">round</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga28d8769f4cf3189184544ab620949dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d8769f4cf3189184544ab620949dba">&#9670;&nbsp;</a></span>rq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::rq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RQ decomposition of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed. </td></tr>
    <tr><td class="paramname">R</td><td>The resulting <code>R</code> matrix. </td></tr>
    <tr><td class="paramname">Q</td><td>The resulting <code>Q</code> matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Square matrix cannot be resized to <em>m-by-<em>n</em>.</em> </td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the dense matrix RQ decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting decomposition has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = R \cdot Q, \]" src="../../form_73.png"/>
</p>
<p>where <code>R</code> is an upper trapezoidal <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix and <code>Q</code> is a general min(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix. The decomposition is written to the two distinct matrices <code>R</code> and <code>Q</code>, which are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... either <em>R</em> or <em>Q</em> are fixed size matrices and the dimensions don't match;</li>
<li>... <em>R</em> is a compile time square matrix, but is required to be non-square.</li>
</ul>
<p>In all failure cases a <em>std::invalid_argument</em> exception is thrown.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> A( 32, 16 );</div><div class="line"><span class="comment">// ... Initialization of A</span></div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> R( 32, 16 );</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a> Q( 16, 16 );</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#ga28d8769f4cf3189184544ab620949dba">rq</a>( A, R, Q );</div><div class="line"></div><div class="line">assert( A == R * Q );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error. </dd></dl>

</div>
</div>
<a id="gac775fabaa100b5d7367998d1ea31e5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac775fabaa100b5d7367998d1ea31e5fb">&#9670;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given dense matrix expression <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense matrix.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given dense matrix expression <em>dm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">serial</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga184756a753db8cd2f780d88c3a652315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184756a753db8cd2f780d88c3a652315">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">sin</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga517339bd44004f0029c0e399cdea98b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga517339bd44004f0029c0e399cdea98b7">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">sinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac8e3e0bc541793c506746cb254bc6bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8e3e0bc541793c506746cb254bc6bfd">&#9670;&nbsp;</a></span>spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::spacing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the spacing between the beginning of two rows/columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The given matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The spacing between the beginning of two rows/columns. </dd></dl>

</div>
</div>
<a id="gaf8993c014d97629a4db3bd9a61dcd8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8993c014d97629a4db3bd9a61dcd8da">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaa1447bfde8e69e7c222e3a5da9b51272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1447bfde8e69e7c222e3a5da9b51272">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singular value decomposition (SVD) of the given dense general matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">s</td><td>The resulting vector of singular values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> of fixed size vector does not match. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Singular value decomposition failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the singular value decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting min(<em>m</em>,<em>n</em>) singular values are stored in the given vector <em>s</em>, which is resized to the correct size (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... the given vector <em>s</em> is a fixed size vector and the size doesn't match;</li>
<li>... the singular value decomposition fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; s;  <span class="comment">// The vector for the singular values</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, s );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing singular values and singular vectors are available via the <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gafbb3d58eeec03d6fc771d257bab4d815" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvd()</a>, <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gaa7079d1b681b609a8f46211a217c45a5" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesdd()</a>, and <a class="el" href="../../d4/d92/group__lapack__singular__value.html#ga51a570feb0abe1165bd44891ab33d0b1" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvdx()</a> functions. </dd></dl>

</div>
</div>
<a id="ga7bfe8f2447a5be2574ad15f2c01a203a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bfe8f2447a5be2574ad15f2c01a203a">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO, typename VT , bool TF, typename MT2 , typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singular value decomposition (SVD) of the given dense general matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">U</td><td>The resulting matrix of left singular vectors. </td></tr>
    <tr><td class="paramname">s</td><td>The resulting vector of singular values. </td></tr>
    <tr><td class="paramname">V</td><td>The resulting matrix of right singular vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix U do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> of fixed size vector does not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix V do not match. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Singular value decomposition failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs the singular value decomposition of a general <em>m-by-<em>n</em> matrix</em>. The resulting min(<em>m</em>,<em>n</em>) singular values are stored in the given vector <em>s</em>, the resulting left singular vectors are stored in the given matrix <em>U</em>, and the resulting right singular vectors are stored in the given matrix <em>V</em>. <em>s</em>, <em>U</em> and <em>V</em> are resized to the correct dimensions (if possible and necessary).</p>
<p>The function fails if ...</p>
<ul>
<li>... the given matrix <em>U</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the given vector <em>s</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given matrix <em>V</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the singular value decomposition fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     U;  <span class="comment">// The matrix for the left singular vectors</span></div><div class="line">DynamicVector&lt;double,columnVector&gt; s;  <span class="comment">// The vector for the singular values</span></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     V;  <span class="comment">// The matrix for the right singular vectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, U, s, V );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing singular values and singular vectors are available via the <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gafbb3d58eeec03d6fc771d257bab4d815" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvd()</a>, <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gaa7079d1b681b609a8f46211a217c45a5" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesdd()</a>, and <a class="el" href="../../d4/d92/group__lapack__singular__value.html#ga51a570feb0abe1165bd44891ab33d0b1" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvdx()</a> functions. </dd></dl>

</div>
</div>
<a id="gaeb64a2d3b815fd6b0b7e394d946641a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb64a2d3b815fd6b0b7e394d946641a7">&#9670;&nbsp;</a></span>svd() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename VT , bool TF, typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>upp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singular value decomposition (SVD) of the given dense general matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">s</td><td>The resulting vector of singular values. </td></tr>
    <tr><td class="paramname">low</td><td>The lower bound of the interval to be searched for singular values. </td></tr>
    <tr><td class="paramname">upp</td><td>The upper bound of the interval to be searched for singular values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of singular values found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> of fixed size vector does not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid value range provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid index range provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Singular value decomposition failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes a specified number of singular values of the given general <em>m-by-<em>n</em> matrix</em>. The number of singular values to be computed is specified by the lower bound <em>low</em> and the upper bound <em>upp</em>, which either form an integral or a floating point range.</p>
<p>In case <em>low</em> and <em>upp</em> are of integral type, the function computes all singular values in the index range <img class="formulaInl" alt="$[low..upp]$" src="../../form_79.png"/>. The <em>num</em> resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a <em>num-dimensional</em> vector.</p>
<p>In case <em>low</em> and <em>upp</em> are of floating point type, the function computes all singular values in the half-open interval <img class="formulaInl" alt="$(low..upp]$" src="../../form_80.png"/>. The resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a min(<em>m</em>,<em>n</em>)-dimensional vector.</p>
<p>The function fails if ...</p>
<ul>
<li>... the given vector <em>s</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given scalar values don't form a proper range;</li>
<li>... the singular value decomposition fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicVector&lt;double,columnVector&gt; s;  <span class="comment">// The vector for the singular values</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, s, 0, 2 );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing singular values and singular vectors are available via the <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gafbb3d58eeec03d6fc771d257bab4d815" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvd()</a>, <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gaa7079d1b681b609a8f46211a217c45a5" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesdd()</a>, and <a class="el" href="../../d4/d92/group__lapack__singular__value.html#ga51a570feb0abe1165bd44891ab33d0b1" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvdx()</a> functions. </dd></dl>

</div>
</div>
<a id="gaa789d8d574f11a23e77f416398f69a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa789d8d574f11a23e77f416398f69a7a">&#9670;&nbsp;</a></span>svd() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , bool SO, typename VT , bool TF, typename MT2 , typename MT3 , typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>upp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singular value decomposition (SVD) of the given dense general matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The given general matrix. </td></tr>
    <tr><td class="paramname">U</td><td>The resulting matrix of left singular vectors. </td></tr>
    <tr><td class="paramname">s</td><td>The resulting vector of singular values. </td></tr>
    <tr><td class="paramname">V</td><td>The resulting matrix of right singular vectors. </td></tr>
    <tr><td class="paramname">low</td><td>The lower bound of the interval to be searched for singular values. </td></tr>
    <tr><td class="paramname">upp</td><td>The upper bound of the interval to be searched for singular values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of singular values found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix U do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> of fixed size vector does not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Dimensions of fixed size matrix V do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid value range provided. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid index range provided. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Singular value decomposition failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes a specified number of singular values and singular vectors of the given general <em>m-by-<em>n</em> matrix</em>. The number of singular values and vectors to be computed is specified by the lower bound <em>low</em> and the upper bound <em>upp</em>, which either form an integral or a floating point range.</p>
<p>In case <em>low</em> and <em>upp</em> form are of integral type, the function computes all singular values in the index range <img class="formulaInl" alt="$[low..upp]$" src="../../form_79.png"/>. The <em>num</em> resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a <em>num-dimensional</em> vector. The resulting left singular vectors are stored in the given matrix <em>U</em>, which is either resized (if possible) or expected to be a <em>m-by-<em>num</em> matrix</em>. The resulting right singular vectors are stored in the given matrix <em>V</em>, which is either resized (if possible) or expected to be a <em>num-by-<em>n</em> matrix</em>.</p>
<p>In case <em>low</em> and <em>upp</em> are of floating point type, the function computes all singular values in the half-open interval <img class="formulaInl" alt="$(low..upp]$" src="../../form_80.png"/>. The resulting real and non-negative singular values are stored in descending order in the given vector <em>s</em>, which is either resized (if possible) or expected to be a min(<em>m</em>,<em>n</em>)-dimensional vector. The resulting left singular vectors are stored in the given matrix <em>U</em>, which is either resized (if possible) or expected to be a <em>m-by-min</em>(<em>m</em>,<em>n</em>) matrix. The resulting right singular vectors are stored in the given matrix <em>V</em>, which is either resized (if possible) or expected to be a <em>min</em>(<em>m</em>,<em>n</em>)-by-<em>n</em> matrix.</p>
<p>The function fails if ...</p>
<ul>
<li>... the given matrix <em>U</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the given vector <em>s</em> is a fixed size vector and the size doesn't match;</li>
<li>... the given matrix <em>V</em> is a fixed size matrix and the dimensions don't match;</li>
<li>... the given scalar values don't form a proper range;</li>
<li>... the singular value decomposition fails.</li>
</ul>
<p>In all failure cases an exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;  A( 5UL, 8UL );  <span class="comment">// The general matrix A</span></div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     U;  <span class="comment">// The matrix for the left singular vectors</span></div><div class="line">DynamicVector&lt;double,columnVector&gt; s;  <span class="comment">// The vector for the singular values</span></div><div class="line">DynamicMatrix&lt;double,rowMajor&gt;     V;  <span class="comment">// The matrix for the right singular vectors</span></div><div class="line"></div><div class="line"><a class="code" href="../../db/df0/group__dense__matrix.html#gaa1447bfde8e69e7c222e3a5da9b51272">svd</a>( A, U, s, V, 0, 2 );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function only works for matrices with <code>float</code>, <code>double</code>, <code>complex&lt;float&gt;</code>, or <code>complex&lt;double&gt;</code> element type. The attempt to call the function with matrices of any other element type results in a compile time error!</dd>
<dd>
This function can only be used if a fitting LAPACK library is available and linked to the executable. Otherwise a call to this function will result in a linker error.</dd>
<dd>
Further options for computing singular values and singular vectors are available via the <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gafbb3d58eeec03d6fc771d257bab4d815" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvd()</a>, <a class="el" href="../../d4/d92/group__lapack__singular__value.html#gaa7079d1b681b609a8f46211a217c45a5" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesdd()</a>, and <a class="el" href="../../d4/d92/group__lapack__singular__value.html#ga51a570feb0abe1165bd44891ab33d0b1" title="LAPACK kernel for the singular value decomposition (SVD) of the given dense general single precision ...">gesvdx()</a> functions. </dd></dl>

</div>
</div>
<a id="gaedd02a415ad4981909556655496f5606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd02a415ad4981909556655496f5606">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">tan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga68dd72087a3e8104e3a089e5c481efd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68dd72087a3e8104e3a089e5c481efd2">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent for each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix; all elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each single element of <em>dm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">tanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga89e370b7fc394ce8cbb51b0114509b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89e370b7fc394ce8cbb51b0114509b08">&#9670;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The dense matrix to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the matrix.</dd></dl>
<p>This function returns an expression representing the transpose of the given dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga05bab7da7e169af5159b553cd0b7d895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bab7da7e169af5159b553cd0b7d895">&#9670;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each single element of the dense matrix <em>dm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting dense matrix.</dd></dl>
<p>This function applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each element of the input matrix <em>dm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">trunc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
