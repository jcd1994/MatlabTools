<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::SparseMatrixProxy&lt; PT, MT &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d3/d05/classblaze_1_1SparseMatrixProxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::SparseMatrixProxy&lt; PT, MT &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse matrix types.The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html" title="Proxy backend for sparse matrix types.The SparseMatrixProxy class serves as a backend for the Proxy c...">SparseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse matrices.  
 <a href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/de6/SparseMatrixProxy_8h_source.html">SparseMatrixProxy.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">blaze::SparseMatrix&lt; PT, IsColumnMajorMatrix&lt; MT &gt;::value &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a94b078258ae81de2b12fd93a9ad2b541"><td class="memItemLeft" align="right" valign="top"><a id="a94b078258ae81de2b12fd93a9ad2b541"></a>enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = MT::smpAssignable
 }<tr class="memdesc:a94b078258ae81de2b12fd93a9ad2b541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments. <br /></td></tr>
</td></tr>
<tr class="separator:a94b078258ae81de2b12fd93a9ad2b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06fdab17db13f9b94a53289be75f5b5"><td class="memItemLeft" align="right" valign="top"><a id="ac06fdab17db13f9b94a53289be75f5b5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ac06fdab17db13f9b94a53289be75f5b5">ResultType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a5a86db58851c76c3500769d8afdc759e">ResultType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:ac06fdab17db13f9b94a53289be75f5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:ac06fdab17db13f9b94a53289be75f5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef4cd50bc3cc7194210c98c08912d3f"><td class="memItemLeft" align="right" valign="top"><a id="a5ef4cd50bc3cc7194210c98c08912d3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a5ef4cd50bc3cc7194210c98c08912d3f">OppositeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#ad282ad15aa380c05ce262000a81e6d81">OppositeType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a5ef4cd50bc3cc7194210c98c08912d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:a5ef4cd50bc3cc7194210c98c08912d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ef61550b2b5e16f85a711993d0f476"><td class="memItemLeft" align="right" valign="top"><a id="ae8ef61550b2b5e16f85a711993d0f476"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ae8ef61550b2b5e16f85a711993d0f476">TransposeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aca0f2ff41fa8f2a1a6ff10fe09817cd8">TransposeType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:ae8ef61550b2b5e16f85a711993d0f476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:ae8ef61550b2b5e16f85a711993d0f476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a599735534047c557a228e1acd67ab"><td class="memItemLeft" align="right" valign="top"><a id="ad0a599735534047c557a228e1acd67ab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:ad0a599735534047c557a228e1acd67ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse matrix elements. <br /></td></tr>
<tr class="separator:ad0a599735534047c557a228e1acd67ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e7f6ec03cc76124c7a64ff07cfa4a"><td class="memItemLeft" align="right" valign="top"><a id="a2b6e7f6ec03cc76124c7a64ff07cfa4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2b6e7f6ec03cc76124c7a64ff07cfa4a">ReturnType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa2e2edcdde49d73a7ca7d2515046b088">ReturnType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a2b6e7f6ec03cc76124c7a64ff07cfa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a2b6e7f6ec03cc76124c7a64ff07cfa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73174a17cbaf6092db0348e8c2cf8e66"><td class="memItemLeft" align="right" valign="top"><a id="a73174a17cbaf6092db0348e8c2cf8e66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a73174a17cbaf6092db0348e8c2cf8e66">CompositeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#acf0851f216dd228db447fbf55718e18c">CompositeType_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a73174a17cbaf6092db0348e8c2cf8e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a73174a17cbaf6092db0348e8c2cf8e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ffd30d195e407e25eddb548221e00b"><td class="memItemLeft" align="right" valign="top"><a id="af5ffd30d195e407e25eddb548221e00b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af5ffd30d195e407e25eddb548221e00b">Reference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a1285adb17e7a11f3dee9b2b0f03f8a89">Reference_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:af5ffd30d195e407e25eddb548221e00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant matrix value. <br /></td></tr>
<tr class="separator:af5ffd30d195e407e25eddb548221e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c509ba4d155391229937ba6d8c58071"><td class="memItemLeft" align="right" valign="top"><a id="a9c509ba4d155391229937ba6d8c58071"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a9c509ba4d155391229937ba6d8c58071">ConstReference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a7428fec1f7754658bd4d765ed6e87841">ConstReference_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a9c509ba4d155391229937ba6d8c58071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant matrix value. <br /></td></tr>
<tr class="separator:a9c509ba4d155391229937ba6d8c58071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09407dd63916f8ce9204f7129d78c2b4"><td class="memItemLeft" align="right" valign="top"><a id="a09407dd63916f8ce9204f7129d78c2b4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a55cefc4108da9a311933047654da11b1">Iterator_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a09407dd63916f8ce9204f7129d78c2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a09407dd63916f8ce9204f7129d78c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d35e0182b2e4ce8d04cec22d59169"><td class="memItemLeft" align="right" valign="top"><a id="a628d35e0182b2e4ce8d04cec22d59169"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a628d35e0182b2e4ce8d04cec22d59169">ConstIterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa1d864b56dde1649490ccd585cb20508">ConstIterator_</a>&lt; MT &gt;</td></tr>
<tr class="memdesc:a628d35e0182b2e4ce8d04cec22d59169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a628d35e0182b2e4ce8d04cec22d59169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853a0280da9279c350e964e661e0acd0"><td class="memItemLeft" align="right" valign="top"><a id="a853a0280da9279c350e964e661e0acd0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> = PT</td></tr>
<tr class="memdesc:a853a0280da9279c350e964e661e0acd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br /></td></tr>
<tr class="separator:a853a0280da9279c350e964e661e0acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a99fddd4e06d7ef0aaa9960c12089c4e5">operator~</a> () noexcept</td></tr>
<tr class="memdesc:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#a99fddd4e06d7ef0aaa9960c12089c4e5">More...</a><br /></td></tr>
<tr class="separator:a99fddd4e06d7ef0aaa9960c12089c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00af660c25d47d64c2beb7511329a3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a00af660c25d47d64c2beb7511329a3e5">operator~</a> () const noexcept</td></tr>
<tr class="memdesc:a00af660c25d47d64c2beb7511329a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a00af660c25d47d64c2beb7511329a3e5">More...</a><br /></td></tr>
<tr class="separator:a00af660c25d47d64c2beb7511329a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:acb36727af57c5ee269e9a30122c117d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af5ffd30d195e407e25eddb548221e00b">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#acb36727af57c5ee269e9a30122c117d1">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:acb36727af57c5ee269e9a30122c117d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function call operator for the direct access to matrix elements.  <a href="#acb36727af57c5ee269e9a30122c117d1">More...</a><br /></td></tr>
<tr class="separator:acb36727af57c5ee269e9a30122c117d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaebd7f4ee38833c8b727edf76fa1a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af5ffd30d195e407e25eddb548221e00b">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aaaebd7f4ee38833c8b727edf76fa1a58">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:aaaebd7f4ee38833c8b727edf76fa1a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the matrix elements.  <a href="#aaaebd7f4ee38833c8b727edf76fa1a58">More...</a><br /></td></tr>
<tr class="separator:aaaebd7f4ee38833c8b727edf76fa1a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a989fe252382366e2fd5d40b525eba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a6a989fe252382366e2fd5d40b525eba3">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:a6a989fe252382366e2fd5d40b525eba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#a6a989fe252382366e2fd5d40b525eba3">More...</a><br /></td></tr>
<tr class="separator:a6a989fe252382366e2fd5d40b525eba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acd873b0d79ef3e66a13d05c7082aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a628d35e0182b2e4ce8d04cec22d59169">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2acd873b0d79ef3e66a13d05c7082aa2">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:a2acd873b0d79ef3e66a13d05c7082aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#a2acd873b0d79ef3e66a13d05c7082aa2">More...</a><br /></td></tr>
<tr class="separator:a2acd873b0d79ef3e66a13d05c7082aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee00ff06b130c761b0d9daaf38f581dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:aee00ff06b130c761b0d9daaf38f581dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#aee00ff06b130c761b0d9daaf38f581dc">More...</a><br /></td></tr>
<tr class="separator:aee00ff06b130c761b0d9daaf38f581dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74177dce27e6c334dff6e371f6ed316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a628d35e0182b2e4ce8d04cec22d59169">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aa74177dce27e6c334dff6e371f6ed316">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:aa74177dce27e6c334dff6e371f6ed316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#aa74177dce27e6c334dff6e371f6ed316">More...</a><br /></td></tr>
<tr class="separator:aa74177dce27e6c334dff6e371f6ed316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a229908a9123a46d80b2b59336620e746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a229908a9123a46d80b2b59336620e746">rows</a> () const</td></tr>
<tr class="memdesc:a229908a9123a46d80b2b59336620e746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="#a229908a9123a46d80b2b59336620e746">More...</a><br /></td></tr>
<tr class="separator:a229908a9123a46d80b2b59336620e746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84b33d45e1e2475363fe1ee59b0be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af84b33d45e1e2475363fe1ee59b0be2b">columns</a> () const</td></tr>
<tr class="memdesc:af84b33d45e1e2475363fe1ee59b0be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="#af84b33d45e1e2475363fe1ee59b0be2b">More...</a><br /></td></tr>
<tr class="separator:af84b33d45e1e2475363fe1ee59b0be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c54485c07f31cae2c785eeacf16f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a01c54485c07f31cae2c785eeacf16f12">capacity</a> () const</td></tr>
<tr class="memdesc:a01c54485c07f31cae2c785eeacf16f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="#a01c54485c07f31cae2c785eeacf16f12">More...</a><br /></td></tr>
<tr class="separator:a01c54485c07f31cae2c785eeacf16f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad797ca619071260d514af27b6d353dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad797ca619071260d514af27b6d353dcd">capacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:ad797ca619071260d514af27b6d353dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="#ad797ca619071260d514af27b6d353dcd">More...</a><br /></td></tr>
<tr class="separator:ad797ca619071260d514af27b6d353dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b75c9722efa9166edaecf4c3892b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ac2b75c9722efa9166edaecf4c3892b5e">nonZeros</a> () const</td></tr>
<tr class="memdesc:ac2b75c9722efa9166edaecf4c3892b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="#ac2b75c9722efa9166edaecf4c3892b5e">More...</a><br /></td></tr>
<tr class="separator:ac2b75c9722efa9166edaecf4c3892b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786c1a80e929e3db9fd5a05f2476e798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a786c1a80e929e3db9fd5a05f2476e798">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:a786c1a80e929e3db9fd5a05f2476e798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="#a786c1a80e929e3db9fd5a05f2476e798">More...</a><br /></td></tr>
<tr class="separator:a786c1a80e929e3db9fd5a05f2476e798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47905531357ba935d5e1ce5cf90d8d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a47905531357ba935d5e1ce5cf90d8d66">reset</a> () const</td></tr>
<tr class="memdesc:a47905531357ba935d5e1ce5cf90d8d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial value.  <a href="#a47905531357ba935d5e1ce5cf90d8d66">More...</a><br /></td></tr>
<tr class="separator:a47905531357ba935d5e1ce5cf90d8d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecbfb3f94464d11b6d0d7f75dada169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#afecbfb3f94464d11b6d0d7f75dada169">reset</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:afecbfb3f94464d11b6d0d7f75dada169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column to the default initial values.  <a href="#afecbfb3f94464d11b6d0d7f75dada169">More...</a><br /></td></tr>
<tr class="separator:afecbfb3f94464d11b6d0d7f75dada169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b4640a6313e4b1c4a5de442c80e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af57b4640a6313e4b1c4a5de442c80e06">clear</a> () const</td></tr>
<tr class="memdesc:af57b4640a6313e4b1c4a5de442c80e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented vector.  <a href="#af57b4640a6313e4b1c4a5de442c80e06">More...</a><br /></td></tr>
<tr class="separator:af57b4640a6313e4b1c4a5de442c80e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cea49e806edc745e5f854c8d33b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#acc3cea49e806edc745e5f854c8d33b75">finalize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:acc3cea49e806edc745e5f854c8d33b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizing the element insertion of a row/column.  <a href="#acc3cea49e806edc745e5f854c8d33b75">More...</a><br /></td></tr>
<tr class="separator:acc3cea49e806edc745e5f854c8d33b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad347a7251b1df6dd6dff5654978fe0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad347a7251b1df6dd6dff5654978fe0fd">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true) const</td></tr>
<tr class="memdesc:ad347a7251b1df6dd6dff5654978fe0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the represented matrix.  <a href="#ad347a7251b1df6dd6dff5654978fe0fd">More...</a><br /></td></tr>
<tr class="separator:ad347a7251b1df6dd6dff5654978fe0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177b35b626bbd6d5b761679f7e49ca92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a177b35b626bbd6d5b761679f7e49ca92">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n) const</td></tr>
<tr class="memdesc:a177b35b626bbd6d5b761679f7e49ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the represented matrix.  <a href="#a177b35b626bbd6d5b761679f7e49ca92">More...</a><br /></td></tr>
<tr class="separator:a177b35b626bbd6d5b761679f7e49ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d3cf0318293217b7dd28ecc5a8975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#abc6d3cf0318293217b7dd28ecc5a8975">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n) const</td></tr>
<tr class="memdesc:abc6d3cf0318293217b7dd28ecc5a8975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of a specific row/column of the sparse matrix.  <a href="#abc6d3cf0318293217b7dd28ecc5a8975">More...</a><br /></td></tr>
<tr class="separator:abc6d3cf0318293217b7dd28ecc5a8975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e51456d7efd4b1c4b780e20edea1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a81e51456d7efd4b1c4b780e20edea1db">trim</a> () const</td></tr>
<tr class="memdesc:a81e51456d7efd4b1c4b780e20edea1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all excessive capacity from all rows/columns.  <a href="#a81e51456d7efd4b1c4b780e20edea1db">More...</a><br /></td></tr>
<tr class="separator:a81e51456d7efd4b1c4b780e20edea1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094c9a9e1e8604007a3385a6bb724cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a1094c9a9e1e8604007a3385a6bb724cc">trim</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const</td></tr>
<tr class="memdesc:a1094c9a9e1e8604007a3385a6bb724cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all excessive capacity of a specific row/column of the sparse matrix.  <a href="#a1094c9a9e1e8604007a3385a6bb724cc">More...</a><br /></td></tr>
<tr class="separator:a1094c9a9e1e8604007a3385a6bb724cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion functions</div></td></tr>
<tr class="memitem:a7910113f0495fff385bcb9fa3757d41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a7910113f0495fff385bcb9fa3757d41f">set</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;value) const</td></tr>
<tr class="memdesc:a7910113f0495fff385bcb9fa3757d41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an element of the represented sparse matrix.  <a href="#a7910113f0495fff385bcb9fa3757d41f">More...</a><br /></td></tr>
<tr class="separator:a7910113f0495fff385bcb9fa3757d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d178732dbff40a8de872fabb9ae6c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a6d178732dbff40a8de872fabb9ae6c7b">insert</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;value) const</td></tr>
<tr class="memdesc:a6d178732dbff40a8de872fabb9ae6c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the represented sparse matrix.  <a href="#a6d178732dbff40a8de872fabb9ae6c7b">More...</a><br /></td></tr>
<tr class="separator:a6d178732dbff40a8de872fabb9ae6c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf523da2ba86d44572f5bf9005e6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2ddf523da2ba86d44572f5bf9005e6d6">append</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;value, bool check=false) const</td></tr>
<tr class="memdesc:a2ddf523da2ba86d44572f5bf9005e6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending an element to the specified row/column of the sparse matrix.  <a href="#a2ddf523da2ba86d44572f5bf9005e6d6">More...</a><br /></td></tr>
<tr class="separator:a2ddf523da2ba86d44572f5bf9005e6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Erase functions</div></td></tr>
<tr class="memitem:a0eebb951e0e84e2831e4d6907a5bdb4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a0eebb951e0e84e2831e4d6907a5bdb4f">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:a0eebb951e0e84e2831e4d6907a5bdb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse matrix.  <a href="#a0eebb951e0e84e2831e4d6907a5bdb4f">More...</a><br /></td></tr>
<tr class="separator:a0eebb951e0e84e2831e4d6907a5bdb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6345c057f65d2e3fbbdab730798b76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af6345c057f65d2e3fbbdab730798b76c">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> pos) const</td></tr>
<tr class="memdesc:af6345c057f65d2e3fbbdab730798b76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse matrix.  <a href="#af6345c057f65d2e3fbbdab730798b76c">More...</a><br /></td></tr>
<tr class="separator:af6345c057f65d2e3fbbdab730798b76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a1266af2e267cc5015935a8312f1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ab0a1266af2e267cc5015935a8312f1a7">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> first, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> last) const</td></tr>
<tr class="memdesc:ab0a1266af2e267cc5015935a8312f1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing a range of elements from the sparse matrix.  <a href="#ab0a1266af2e267cc5015935a8312f1a7">More...</a><br /></td></tr>
<tr class="separator:ab0a1266af2e267cc5015935a8312f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebeebc2bc8d9dddbb8cc82c92be9890"><td class="memTemplParams" colspan="2">template&lt;typename Pred &gt; </td></tr>
<tr class="memitem:aaebeebc2bc8d9dddbb8cc82c92be9890"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aaebeebc2bc8d9dddbb8cc82c92be9890">erase</a> (Pred predicate)</td></tr>
<tr class="memdesc:aaebeebc2bc8d9dddbb8cc82c92be9890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing specific elements from the sparse matrix.  <a href="#aaebeebc2bc8d9dddbb8cc82c92be9890">More...</a><br /></td></tr>
<tr class="separator:aaebeebc2bc8d9dddbb8cc82c92be9890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a2fb60f8c96edc2a928a85a574c880"><td class="memTemplParams" colspan="2">template&lt;typename Pred &gt; </td></tr>
<tr class="memitem:a15a2fb60f8c96edc2a928a85a574c880"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a15a2fb60f8c96edc2a928a85a574c880">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> first, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> last, Pred predicate)</td></tr>
<tr class="memdesc:a15a2fb60f8c96edc2a928a85a574c880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing specific elements from a range of the sparse matrix.  <a href="#a15a2fb60f8c96edc2a928a85a574c880">More...</a><br /></td></tr>
<tr class="separator:a15a2fb60f8c96edc2a928a85a574c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:ac39dfa191f1fbb9c8f339a8babce35f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ac39dfa191f1fbb9c8f339a8babce35f6">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:ac39dfa191f1fbb9c8f339a8babce35f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific matrix element.  <a href="#ac39dfa191f1fbb9c8f339a8babce35f6">More...</a><br /></td></tr>
<tr class="separator:ac39dfa191f1fbb9c8f339a8babce35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2334a51e474f4e3dfceac0e2301559b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ae2334a51e474f4e3dfceac0e2301559b">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:ae2334a51e474f4e3dfceac0e2301559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#ae2334a51e474f4e3dfceac0e2301559b">More...</a><br /></td></tr>
<tr class="separator:ae2334a51e474f4e3dfceac0e2301559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4544614cf2a131a80fec0f8981d19f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ab4544614cf2a131a80fec0f8981d19f8">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const</td></tr>
<tr class="memdesc:ab4544614cf2a131a80fec0f8981d19f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#ab4544614cf2a131a80fec0f8981d19f8">More...</a><br /></td></tr>
<tr class="separator:ab4544614cf2a131a80fec0f8981d19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numeric functions</div></td></tr>
<tr class="memitem:a843abb7bff3155a96ab107546f0e1037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a843abb7bff3155a96ab107546f0e1037">transpose</a> () const</td></tr>
<tr class="memdesc:a843abb7bff3155a96ab107546f0e1037"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place transpose of the represented matrix.  <a href="#a843abb7bff3155a96ab107546f0e1037">More...</a><br /></td></tr>
<tr class="separator:a843abb7bff3155a96ab107546f0e1037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504482cd2e66c29c83db81541ed09245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a504482cd2e66c29c83db81541ed09245">ctranspose</a> () const</td></tr>
<tr class="memdesc:a504482cd2e66c29c83db81541ed09245"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place conjugate transpose of the represented matrix.  <a href="#a504482cd2e66c29c83db81541ed09245">More...</a><br /></td></tr>
<tr class="separator:a504482cd2e66c29c83db81541ed09245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265aa4a4539dd8bcce58ca22fd68f208"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a265aa4a4539dd8bcce58ca22fd68f208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a265aa4a4539dd8bcce58ca22fd68f208">scale</a> (const Other &amp;scalar) const</td></tr>
<tr class="memdesc:a265aa4a4539dd8bcce58ca22fd68f208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the sparse matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>).  <a href="#a265aa4a4539dd8bcce58ca22fd68f208">More...</a><br /></td></tr>
<tr class="separator:a265aa4a4539dd8bcce58ca22fd68f208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PT, typename MT&gt;<br />
class blaze::SparseMatrixProxy&lt; PT, MT &gt;</h3>

<p><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse matrix types.</p>
<p>The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html" title="Proxy backend for sparse matrix types.The SparseMatrixProxy class serves as a backend for the Proxy c...">SparseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse matrices. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ddf523da2ba86d44572f5bf9005e6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddf523da2ba86d44572f5bf9005e6d6">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appending an element to the specified row/column of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be appended. </td></tr>
    <tr><td class="paramname">check</td><td><em>true</em> if the new value should be checked for default values, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides a very efficient way to fill a sparse matrix with elements. It appends a new element to the end of the specified row/column without any additional memory allocation. Therefore it is strictly necessary to keep the following preconditions in mind:</p>
<ul>
<li>the index of the new element must be strictly larger than the largest index of non-zero elements in the specified row/column of the sparse matrix</li>
<li>the current number of non-zero elements in the matrix must be smaller than the capacity of the matrix</li>
</ul>
<p>Ignoring these preconditions might result in undefined behavior! The optional <em>check</em> parameter specifies whether the new value should be tested for a default value. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> the new value is a default value (for instance 0 in case of an integral element type) the value is not appended. Per default the values are not tested.</p>
<dl class="section note"><dt>Note</dt><dd>Although <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2ddf523da2ba86d44572f5bf9005e6d6" title="Appending an element to the specified row/column of the sparse matrix. ">append()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> functions! </dd></dl>

</div>
</div>
<a id="aaaebd7f4ee38833c8b727edf76fa1a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaebd7f4ee38833c8b727edf76fa1a58">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af5ffd30d195e407e25eddb548221e00b">Reference</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>Invalid matrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a reference to the accessed value at position (<em>i</em>,<em>j</em>). In case the sparse matrix does not yet store an element at position (<em>i</em>,<em>j</em>) , a new element is inserted into the sparse matrix. In contrast to the subscript operator this function always performs a check of the given access indices. </p>

</div>
</div>
<a id="a6a989fe252382366e2fd5d40b525eba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a989fe252382366e2fd5d40b525eba3">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a id="a01c54485c07f31cae2c785eeacf16f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c54485c07f31cae2c785eeacf16f12">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a id="ad797ca619071260d514af27b6d353dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad797ca619071260d514af27b6d353dcd">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a id="a2acd873b0d79ef3e66a13d05c7082aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acd873b0d79ef3e66a13d05c7082aa2">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a628d35e0182b2e4ce8d04cec22d59169">ConstIterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a id="aa74177dce27e6c334dff6e371f6ed316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74177dce27e6c334dff6e371f6ed316">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a628d35e0182b2e4ce8d04cec22d59169">ConstIterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a id="af57b4640a6313e4b1c4a5de442c80e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57b4640a6313e4b1c4a5de442c80e06">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the matrix to its default initial state. </p>

</div>
</div>
<a id="af84b33d45e1e2475363fe1ee59b0be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84b33d45e1e2475363fe1ee59b0be2b">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of columns of the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a id="a504482cd2e66c29c83db81541ed09245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504482cd2e66c29c83db81541ed09245">&#9670;&nbsp;</a></span>ctranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::ctranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place conjugate transpose of the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee00ff06b130c761b0d9daaf38f581dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee00ff06b130c761b0d9daaf38f581dc">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a id="a0eebb951e0e84e2831e4d6907a5bdb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eebb951e0e84e2831e4d6907a5bdb4f">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases an element from the sparse matrix. </p>

</div>
</div>
<a id="af6345c057f65d2e3fbbdab730798b76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6345c057f65d2e3fbbdab730798b76c">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases an element from the sparse matrix. In case the storage order is set to <em>rowMajor</em> the function erases an element from row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function erases an element from column <em>i</em>. </p>

</div>
</div>
<a id="ab0a1266af2e267cc5015935a8312f1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a1266af2e267cc5015935a8312f1a7">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing a range of elements from the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a range of elements from the sparse matrix. In case the storage order is set to <em>rowMajor</em> the function erases a range of elements from row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function erases a range of elements from column <em>i</em>. </p>

</div>
</div>
<a id="aaebeebc2bc8d9dddbb8cc82c92be9890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebeebc2bc8d9dddbb8cc82c92be9890">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing specific elements from the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The unary predicate for the element selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void.</dd></dl>
<p>This function erases specific elements from the sparse matrix. The elements are selected by the given unary predicate <em>predicate</em>, which is expected to accept a single argument of the type of the elements and to be pure.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate is required to be pure, i.e. to produce deterministic results for elements with the same value. The attempt to use an impure predicate leads to undefined behavior! </dd></dl>

</div>
</div>
<a id="a15a2fb60f8c96edc2a928a85a574c880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a2fb60f8c96edc2a928a85a574c880">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing specific elements from a range of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the elements to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to first element of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element of the range. </td></tr>
    <tr><td class="paramname">predicate</td><td>The unary predicate for the element selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases specific elements from a range of elements of the sparse matrix. The elements are selected by the given unary predicate <em>predicate</em>, which is expected to accept a single argument of the type of the elements and to be pure. In case the storage order is set to <em>rowMajor</em> the function erases a range of elements from row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function erases a range of elements from column <em>i</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate is required to be pure, i.e. to produce deterministic results for elements with the same value. The attempt to use an impure predicate leads to undefined behavior! </dd></dl>

</div>
</div>
<a id="acc3cea49e806edc745e5f854c8d33b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cea49e806edc745e5f854c8d33b75">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizing the element insertion of a row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column to be finalized <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is part of the low-level interface to efficiently fill a matrix with elements. After completion of row/column <em>i</em> via the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2ddf523da2ba86d44572f5bf9005e6d6" title="Appending an element to the specified row/column of the sparse matrix. ">append()</a> function, this function can be called to finalize row/column <em>i</em> and prepare the next row/column for insertion process via <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a2ddf523da2ba86d44572f5bf9005e6d6" title="Appending an element to the specified row/column of the sparse matrix. ">append()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Although <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#acc3cea49e806edc745e5f854c8d33b75" title="Finalizing the element insertion of a row/column. ">finalize()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> functions! </dd></dl>

</div>
</div>
<a id="ac39dfa191f1fbb9c8f339a8babce35f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39dfa191f1fbb9c8f339a8babce35f6">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse matrix. It specifically searches for the element with row index <em>i</em> and column index <em>j</em>. In case the element is found, the function returns an row/column iterator to the element. Otherwise an iterator just past the last non-zero element of row <em>i</em> or column <em>j</em> (the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> iterator) is returned. Note that the returned sparse matrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a6d178732dbff40a8de872fabb9ae6c7b" title="Inserting an element into the represented sparse matrix. ">insert()</a> function! </p>

</div>
</div>
<a id="a6d178732dbff40a8de872fabb9ae6c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d178732dbff40a8de872fabb9ae6c7b">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the represented sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the newly inserted element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse matrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inserts a new element into the sparse matrix. However, duplicate elements are not allowed. In case the sparse matrix already contains an element with row index <em>i</em> and column index <em>j</em>, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a id="ae2334a51e474f4e3dfceac0e2301559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2334a51e474f4e3dfceac0e2301559b">&#9670;&nbsp;</a></span>lowerBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major matrix, this function returns a row iterator to the first element with an index not less then the given column index. In case of a column-major matrix, the function returns a column iterator to the first element with an index not less then the given row index. In combination with the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ab4544614cf2a131a80fec0f8981d19f8" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse matrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a6d178732dbff40a8de872fabb9ae6c7b" title="Inserting an element into the represented sparse matrix. ">insert()</a> function! </p>

</div>
</div>
<a id="ac2b75c9722efa9166edaecf4c3892b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b75c9722efa9166edaecf4c3892b5e">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a id="a786c1a80e929e3db9fd5a05f2476e798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786c1a80e929e3db9fd5a05f2476e798">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a id="acb36727af57c5ee269e9a30122c117d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb36727af57c5ee269e9a30122c117d1">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#af5ffd30d195e407e25eddb548221e00b">Reference</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function call operator for the direct access to matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a reference to the accessed value at position (<em>i</em>,<em>j</em>). In case the sparse matrix does not yet store an element at position (<em>i</em>,<em>j</em>) , a new element is inserted into the sparse matrix. Note that this function only performs an index check in case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active. In contrast, the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aaaebd7f4ee38833c8b727edf76fa1a58" title="Checked access to the matrix elements. ">at()</a> function is guaranteed to perform a check of the given access indices. </p>

</div>
</div>
<a id="a99fddd4e06d7ef0aaa9960c12089c4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fddd4e06d7ef0aaa9960c12089c4e5">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; PT , SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a id="a00af660c25d47d64c2beb7511329a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00af660c25d47d64c2beb7511329a3e5">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a853a0280da9279c350e964e661e0acd0">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; PT , SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a id="a177b35b626bbd6d5b761679f7e49ca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177b35b626bbd6d5b761679f7e49ca92">&#9670;&nbsp;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new minimum capacity of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function increases the capacity of the sparse matrix to at least <em>nonzeros</em> elements. The current values of the matrix elements and the individual capacities of the matrix rows are preserved. </p>

</div>
</div>
<a id="abc6d3cf0318293217b7dd28ecc5a8975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d3cf0318293217b7dd28ecc5a8975">&#9670;&nbsp;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of a specific row/column of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the new element <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/> or <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">n</td><td>The new minimum capacity of the specified row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function increases the capacity of row/column <em>i</em> of the sparse matrix to at least <em>nonzeros</em> elements. The current values of the sparse matrix and all other individual row/column capacities are preserved. In case the storage order is set to <em>rowMajor</em>, the function reserves capacity for row <em>i</em> and the index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. In case the storage order is set to <em>columnMajor</em>, the function reserves capacity for column <em>i</em> and the index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </p>

</div>
</div>
<a id="a47905531357ba935d5e1ce5cf90d8d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47905531357ba935d5e1ce5cf90d8d66">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial value. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the matrix to the default initial values. </p>

</div>
</div>
<a id="afecbfb3f94464d11b6d0d7f75dada169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecbfb3f94464d11b6d0d7f75dada169">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the specified row/column to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the values in the specified row/column to their default value. In case the storage order is set to <em>rowMajor</em> the function resets the values in row <em>i</em>, in case the storage order is set to <em>columnMajor</em> the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a id="ad347a7251b1df6dd6dff5654978fe0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad347a7251b1df6dd6dff5654978fe0fd">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changing the size of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The new number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The new number of columns of the matrix. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the matrix should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resizes the matrix using the given size to <img class="formulaInl" alt="$ m \times n $" src="../../form_26.png"/>. Depending on the type of the matrix, during this operation new dynamic memory may be allocated in case the capacity of the matrix is too small. Note that this function may invalidate all existing views (submatrices, rows, columns, ...) on the matrix if it is used to shrink the matrix. Additionally, the resize operation potentially changes all matrix elements. In order to preserve the old matrix values, the <em>preserve</em> flag can be set to <em>true</em>. </p>

</div>
</div>
<a id="a229908a9123a46d80b2b59336620e746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229908a9123a46d80b2b59336620e746">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of rows of the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a id="a265aa4a4539dd8bcce58ca22fd68f208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265aa4a4539dd8bcce58ca22fd68f208">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the sparse matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the matrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function scales the matrix by applying the given scalar value <em>scalar</em> to each element of the matrix. For built-in and <code>complex</code> data types it has the same effect as using the multiplication assignment operator. </p>

</div>
</div>
<a id="a7910113f0495fff385bcb9fa3757d41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7910113f0495fff385bcb9fa3757d41f">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ad0a599735534047c557a228e1acd67ab">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting an element of the represented sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the set element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse matrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value of an element of the sparse matrix. In case the sparse matrix already contains an element with row index <em>i</em> and column index <em>j</em> its value is modified, else a new element with the given <em>value</em> is inserted. </p>

</div>
</div>
<a id="a843abb7bff3155a96ab107546f0e1037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843abb7bff3155a96ab107546f0e1037">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place transpose of the represented matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81e51456d7efd4b1c4b780e20edea1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e51456d7efd4b1c4b780e20edea1db">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing all excessive capacity from all rows/columns. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a81e51456d7efd4b1c4b780e20edea1db" title="Removing all excessive capacity from all rows/columns. ">trim()</a> function can be used to reverse the effect of all row/column-specific <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a177b35b626bbd6d5b761679f7e49ca92" title="Setting the minimum capacity of the represented matrix. ">reserve()</a> calls. The function removes all excessive capacity from all rows (in case of a rowMajor matrix) or columns (in case of a columnMajor matrix). Note that this function does not remove the overall capacity but only reduces the capacity per row/column. </p>

</div>
</div>
<a id="a1094c9a9e1e8604007a3385a6bb724cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094c9a9e1e8604007a3385a6bb724cc">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing all excessive capacity of a specific row/column of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column to be trimmed ( <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/> or <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid access to restricted element.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to reverse the effect of a row/column-specific <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a177b35b626bbd6d5b761679f7e49ca92" title="Setting the minimum capacity of the represented matrix. ">reserve()</a> call. It removes all excessive capacity from the specified row (in case of a rowMajor matrix) or column (in case of a columnMajor matrix). The excessive capacity is assigned to the subsequent row/column. </p>

</div>
</div>
<a id="ab4544614cf2a131a80fec0f8981d19f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4544614cf2a131a80fec0f8981d19f8">&#9670;&nbsp;</a></span>upperBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt;::<a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a09407dd63916f8ce9204f7129d78c2b4">Iterator</a> <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy</a>&lt; PT, MT &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_27.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#aee00ff06b130c761b0d9daaf38f581dc" title="Returns an iterator just past the last element of row/column i of the represented matrix...">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major matrix, this function returns a row iterator to the first element with an index greater then the given column index. In case of a column-major matrix, the function returns a column iterator to the first element with an index greater then the given row index. In combination with the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#ab4544614cf2a131a80fec0f8981d19f8" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse matrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#a6d178732dbff40a8de872fabb9ae6c7b" title="Inserting an element into the represented sparse matrix. ">insert()</a> function! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/proxy/<a class="el" href="../../df/d8b/proxy_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/proxy/<a class="el" href="../../d5/de6/SparseMatrixProxy_8h_source.html">SparseMatrixProxy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:33 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
