<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sparse Matrices</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Matrices<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:da/d08/group__sparse__matrix__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d08/group__sparse__matrix__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d6e/group__compressed__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html">CompressedMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/d18/group__identity__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d18/group__identity__matrix.html">IdentityMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">blaze::SparseMatrix&lt; MT, SO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse matrices.The <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html" title="Base class for sparse matrices.The SparseMatrix class is a base class for all sparse matrix classes...">SparseMatrix</a> class is a base class for all sparse matrix classes. It provides an abstraction from the actual type of the sparse matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d7/d5d/structblaze_1_1SparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">blaze::MatrixAccessProxy&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_29.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br />
The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc13c77920f97b72180fcf7c07f4b373"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gafc13c77920f97b72180fcf7c07f4b373"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gafc13c77920f97b72180fcf7c07f4b373">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafc13c77920f97b72180fcf7c07f4b373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gafc13c77920f97b72180fcf7c07f4b373">More...</a><br /></td></tr>
<tr class="separator:gafc13c77920f97b72180fcf7c07f4b373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4612fad107f743fa8ac8735a6c8f03c1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga4612fad107f743fa8ac8735a6c8f03c1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4612fad107f743fa8ac8735a6c8f03c1">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4612fad107f743fa8ac8735a6c8f03c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga4612fad107f743fa8ac8735a6c8f03c1">More...</a><br /></td></tr>
<tr class="separator:ga4612fad107f743fa8ac8735a6c8f03c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d90c00940662e27260afdc38ecd0f5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaf7d90c00940662e27260afdc38ecd0f5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf7d90c00940662e27260afdc38ecd0f5">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf7d90c00940662e27260afdc38ecd0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaf7d90c00940662e27260afdc38ecd0f5">More...</a><br /></td></tr>
<tr class="separator:gaf7d90c00940662e27260afdc38ecd0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62069bfe75e612d20989547be4d85b2a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga62069bfe75e612d20989547be4d85b2a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga62069bfe75e612d20989547be4d85b2a">blaze::operator%</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62069bfe75e612d20989547be4d85b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga62069bfe75e612d20989547be4d85b2a">More...</a><br /></td></tr>
<tr class="separator:ga62069bfe75e612d20989547be4d85b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebae18946fa942ef27ff069f2760b6a"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gadebae18946fa942ef27ff069f2760b6a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadebae18946fa942ef27ff069f2760b6a">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadebae18946fa942ef27ff069f2760b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gadebae18946fa942ef27ff069f2760b6a">More...</a><br /></td></tr>
<tr class="separator:gadebae18946fa942ef27ff069f2760b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d22dbcb5d0acb071e59d7aa41547001"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3d22dbcb5d0acb071e59d7aa41547001"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3d22dbcb5d0acb071e59d7aa41547001">blaze::decldiag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga3d22dbcb5d0acb071e59d7aa41547001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given sparse matrix expression <em>sm</em> as diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga3d22dbcb5d0acb071e59d7aa41547001">More...</a><br /></td></tr>
<tr class="separator:ga3d22dbcb5d0acb071e59d7aa41547001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffbb82fc419212e7ee7d7ea02da0b7e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacffbb82fc419212e7ee7d7ea02da0b7e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gacffbb82fc419212e7ee7d7ea02da0b7e">blaze::declherm</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gacffbb82fc419212e7ee7d7ea02da0b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given sparse matrix expression <em>sm</em> as Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#gacffbb82fc419212e7ee7d7ea02da0b7e">More...</a><br /></td></tr>
<tr class="separator:gacffbb82fc419212e7ee7d7ea02da0b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3550a55a93f8b885e1b113a715952fca"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3550a55a93f8b885e1b113a715952fca"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3550a55a93f8b885e1b113a715952fca">blaze::decllow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga3550a55a93f8b885e1b113a715952fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given sparse matrix expression <em>sm</em> as lower.  <a href="../../d0/d45/group__sparse__matrix.html#ga3550a55a93f8b885e1b113a715952fca">More...</a><br /></td></tr>
<tr class="separator:ga3550a55a93f8b885e1b113a715952fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb953cdb04ef1682994bc8a5c690ec56"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabb953cdb04ef1682994bc8a5c690ec56"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gabb953cdb04ef1682994bc8a5c690ec56">blaze::declsym</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gabb953cdb04ef1682994bc8a5c690ec56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given sparse matrix expression <em>sm</em> as symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gabb953cdb04ef1682994bc8a5c690ec56">More...</a><br /></td></tr>
<tr class="separator:gabb953cdb04ef1682994bc8a5c690ec56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa521056d34f89ecf82b15d5eb5228f77"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa521056d34f89ecf82b15d5eb5228f77"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa521056d34f89ecf82b15d5eb5228f77">blaze::declupp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa521056d34f89ecf82b15d5eb5228f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the given sparse matrix expression <em>sm</em> as upper.  <a href="../../d0/d45/group__sparse__matrix.html#gaa521056d34f89ecf82b15d5eb5228f77">More...</a><br /></td></tr>
<tr class="separator:gaa521056d34f89ecf82b15d5eb5228f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1def760e8591dc098a2b94ad4501d3df"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga1def760e8591dc098a2b94ad4501d3df"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1def760e8591dc098a2b94ad4501d3df">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1def760e8591dc098a2b94ad4501d3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1def760e8591dc098a2b94ad4501d3df">More...</a><br /></td></tr>
<tr class="separator:ga1def760e8591dc098a2b94ad4501d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168334f1d51c058414fe29581cf1e65e"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga168334f1d51c058414fe29581cf1e65e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga168334f1d51c058414fe29581cf1e65e">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga168334f1d51c058414fe29581cf1e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga168334f1d51c058414fe29581cf1e65e">More...</a><br /></td></tr>
<tr class="separator:ga168334f1d51c058414fe29581cf1e65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7dc3fd3365cf4be7b22a9c754ac9f4c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae7dc3fd3365cf4be7b22a9c754ac9f4c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae7dc3fd3365cf4be7b22a9c754ac9f4c">blaze::eval</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae7dc3fd3365cf4be7b22a9c754ac9f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae7dc3fd3365cf4be7b22a9c754ac9f4c">More...</a><br /></td></tr>
<tr class="separator:gae7dc3fd3365cf4be7b22a9c754ac9f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c0b7e00bd4fff04d7834374fdb8345"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:gaa0c0b7e00bd4fff04d7834374fdb8345"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa0c0b7e00bd4fff04d7834374fdb8345">blaze::map</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, OP op)</td></tr>
<tr class="memdesc:gaa0c0b7e00bd4fff04d7834374fdb8345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa0c0b7e00bd4fff04d7834374fdb8345">More...</a><br /></td></tr>
<tr class="separator:gaa0c0b7e00bd4fff04d7834374fdb8345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc08c29fec359383e6856ce15653412"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename OP &gt; </td></tr>
<tr class="memitem:ga4fc08c29fec359383e6856ce15653412"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4fc08c29fec359383e6856ce15653412">blaze::forEach</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, OP op)</td></tr>
<tr class="memdesc:ga4fc08c29fec359383e6856ce15653412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga4fc08c29fec359383e6856ce15653412">More...</a><br /></td></tr>
<tr class="separator:ga4fc08c29fec359383e6856ce15653412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a7c2f5063bb49b64e3a8508f20d6825"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga1a7c2f5063bb49b64e3a8508f20d6825"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1a7c2f5063bb49b64e3a8508f20d6825">blaze::abs</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga1a7c2f5063bb49b64e3a8508f20d6825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga1a7c2f5063bb49b64e3a8508f20d6825">More...</a><br /></td></tr>
<tr class="separator:ga1a7c2f5063bb49b64e3a8508f20d6825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde7a678ada1f0febcc080b559926053"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadde7a678ada1f0febcc080b559926053"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadde7a678ada1f0febcc080b559926053">blaze::floor</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gadde7a678ada1f0febcc080b559926053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gadde7a678ada1f0febcc080b559926053">More...</a><br /></td></tr>
<tr class="separator:gadde7a678ada1f0febcc080b559926053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d99c41b25e1ccba8c1fe6bc6baa673"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga45d99c41b25e1ccba8c1fe6bc6baa673"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga45d99c41b25e1ccba8c1fe6bc6baa673">blaze::ceil</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga45d99c41b25e1ccba8c1fe6bc6baa673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga45d99c41b25e1ccba8c1fe6bc6baa673">More...</a><br /></td></tr>
<tr class="separator:ga45d99c41b25e1ccba8c1fe6bc6baa673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b9e3d20db929486251cd5318310433"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab9b9e3d20db929486251cd5318310433"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab9b9e3d20db929486251cd5318310433">blaze::trunc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gab9b9e3d20db929486251cd5318310433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gab9b9e3d20db929486251cd5318310433">More...</a><br /></td></tr>
<tr class="separator:gab9b9e3d20db929486251cd5318310433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee630041798b12ebb1798febb2c4120"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0ee630041798b12ebb1798febb2c4120"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga0ee630041798b12ebb1798febb2c4120">blaze::round</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga0ee630041798b12ebb1798febb2c4120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga0ee630041798b12ebb1798febb2c4120">More...</a><br /></td></tr>
<tr class="separator:ga0ee630041798b12ebb1798febb2c4120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc66e24ad4edc3cdc37256850fa3b16"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6dc66e24ad4edc3cdc37256850fa3b16"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6dc66e24ad4edc3cdc37256850fa3b16">blaze::conj</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6dc66e24ad4edc3cdc37256850fa3b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the complex conjugate of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga6dc66e24ad4edc3cdc37256850fa3b16">More...</a><br /></td></tr>
<tr class="separator:ga6dc66e24ad4edc3cdc37256850fa3b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d300f094adea64bb4e5e77ab793c54"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac8d300f094adea64bb4e5e77ab793c54"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac8d300f094adea64bb4e5e77ab793c54">blaze::ctrans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gac8d300f094adea64bb4e5e77ab793c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate transpose matrix of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gac8d300f094adea64bb4e5e77ab793c54">More...</a><br /></td></tr>
<tr class="separator:gac8d300f094adea64bb4e5e77ab793c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee11b603614ecd820533b77d48c5b6b6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaee11b603614ecd820533b77d48c5b6b6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaee11b603614ecd820533b77d48c5b6b6">blaze::real</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaee11b603614ecd820533b77d48c5b6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the real parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaee11b603614ecd820533b77d48c5b6b6">More...</a><br /></td></tr>
<tr class="separator:gaee11b603614ecd820533b77d48c5b6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16165ccd6db21fc1df6b74352a868420"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga16165ccd6db21fc1df6b74352a868420"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga16165ccd6db21fc1df6b74352a868420">blaze::imag</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga16165ccd6db21fc1df6b74352a868420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the imaginary parts of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga16165ccd6db21fc1df6b74352a868420">More...</a><br /></td></tr>
<tr class="separator:ga16165ccd6db21fc1df6b74352a868420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0801b1a75e0c41dac9cc5fd2c469cc2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaf0801b1a75e0c41dac9cc5fd2c469cc2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf0801b1a75e0c41dac9cc5fd2c469cc2">blaze::sqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaf0801b1a75e0c41dac9cc5fd2c469cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaf0801b1a75e0c41dac9cc5fd2c469cc2">More...</a><br /></td></tr>
<tr class="separator:gaf0801b1a75e0c41dac9cc5fd2c469cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e875a822e97bd4e1e895241f879c83d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3e875a822e97bd4e1e895241f879c83d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3e875a822e97bd4e1e895241f879c83d">blaze::invsqrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga3e875a822e97bd4e1e895241f879c83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse square root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga3e875a822e97bd4e1e895241f879c83d">More...</a><br /></td></tr>
<tr class="separator:ga3e875a822e97bd4e1e895241f879c83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebccf4da062e0fa956ad7f2812663e80"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaebccf4da062e0fa956ad7f2812663e80"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaebccf4da062e0fa956ad7f2812663e80">blaze::cbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaebccf4da062e0fa956ad7f2812663e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaebccf4da062e0fa956ad7f2812663e80">More...</a><br /></td></tr>
<tr class="separator:gaebccf4da062e0fa956ad7f2812663e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8996bd18a53f4aff25bdfcd3e79bc34"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa8996bd18a53f4aff25bdfcd3e79bc34"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa8996bd18a53f4aff25bdfcd3e79bc34">blaze::invcbrt</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa8996bd18a53f4aff25bdfcd3e79bc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cubic root of each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa8996bd18a53f4aff25bdfcd3e79bc34">More...</a><br /></td></tr>
<tr class="separator:gaa8996bd18a53f4aff25bdfcd3e79bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d6b7686f911eaefbcf7e849b8ecdbe"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename DT &gt; </td></tr>
<tr class="memitem:ga39d6b7686f911eaefbcf7e849b8ecdbe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga39d6b7686f911eaefbcf7e849b8ecdbe">blaze::clamp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>, const DT &amp;<a class="el" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">max</a>)</td></tr>
<tr class="memdesc:ga39d6b7686f911eaefbcf7e849b8ecdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts each single element of the sparse matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>.  <a href="../../d0/d45/group__sparse__matrix.html#ga39d6b7686f911eaefbcf7e849b8ecdbe">More...</a><br /></td></tr>
<tr class="separator:ga39d6b7686f911eaefbcf7e849b8ecdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a678b92c26772d92195f4ee9e6fa43"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ET &gt; </td></tr>
<tr class="memitem:gae1a678b92c26772d92195f4ee9e6fa43"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae1a678b92c26772d92195f4ee9e6fa43">blaze::pow</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm, ET <a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>)</td></tr>
<tr class="memdesc:gae1a678b92c26772d92195f4ee9e6fa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponential value for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae1a678b92c26772d92195f4ee9e6fa43">More...</a><br /></td></tr>
<tr class="separator:gae1a678b92c26772d92195f4ee9e6fa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d0624722cc50c65464169183fafa4b"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga34d0624722cc50c65464169183fafa4b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga34d0624722cc50c65464169183fafa4b">blaze::exp</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga34d0624722cc50c65464169183fafa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga34d0624722cc50c65464169183fafa4b">More...</a><br /></td></tr>
<tr class="separator:ga34d0624722cc50c65464169183fafa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad776d69924085796fd8b25260e8ed097"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad776d69924085796fd8b25260e8ed097"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad776d69924085796fd8b25260e8ed097">blaze::exp2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad776d69924085796fd8b25260e8ed097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gad776d69924085796fd8b25260e8ed097">More...</a><br /></td></tr>
<tr class="separator:gad776d69924085796fd8b25260e8ed097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1656aa731efa1a21acc0000f6e9623"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabe1656aa731efa1a21acc0000f6e9623"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gabe1656aa731efa1a21acc0000f6e9623">blaze::exp10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gabe1656aa731efa1a21acc0000f6e9623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gabe1656aa731efa1a21acc0000f6e9623">More...</a><br /></td></tr>
<tr class="separator:gabe1656aa731efa1a21acc0000f6e9623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee9ea9a5cc2a762fe7a218f6ba393a4"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5ee9ea9a5cc2a762fe7a218f6ba393a4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5ee9ea9a5cc2a762fe7a218f6ba393a4">blaze::log</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5ee9ea9a5cc2a762fe7a218f6ba393a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga5ee9ea9a5cc2a762fe7a218f6ba393a4">More...</a><br /></td></tr>
<tr class="separator:ga5ee9ea9a5cc2a762fe7a218f6ba393a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d4857f4a998623490b2d0319de59bc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gab5d4857f4a998623490b2d0319de59bc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab5d4857f4a998623490b2d0319de59bc">blaze::log10</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gab5d4857f4a998623490b2d0319de59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gab5d4857f4a998623490b2d0319de59bc">More...</a><br /></td></tr>
<tr class="separator:gab5d4857f4a998623490b2d0319de59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd743dfe188f3aa067d95fd53a65a42a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadd743dfe188f3aa067d95fd53a65a42a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadd743dfe188f3aa067d95fd53a65a42a">blaze::log2</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gadd743dfe188f3aa067d95fd53a65a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the common logarithm for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gadd743dfe188f3aa067d95fd53a65a42a">More...</a><br /></td></tr>
<tr class="separator:gadd743dfe188f3aa067d95fd53a65a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b1b285631e1b9152d4261e49285b01"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae4b1b285631e1b9152d4261e49285b01"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae4b1b285631e1b9152d4261e49285b01">blaze::sin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae4b1b285631e1b9152d4261e49285b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae4b1b285631e1b9152d4261e49285b01">More...</a><br /></td></tr>
<tr class="separator:gae4b1b285631e1b9152d4261e49285b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e0d3f20495e102565fb88380b27418"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga47e0d3f20495e102565fb88380b27418"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga47e0d3f20495e102565fb88380b27418">blaze::asin</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga47e0d3f20495e102565fb88380b27418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga47e0d3f20495e102565fb88380b27418">More...</a><br /></td></tr>
<tr class="separator:ga47e0d3f20495e102565fb88380b27418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0832cb251d6b576244a12dad712546"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7a0832cb251d6b576244a12dad712546"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7a0832cb251d6b576244a12dad712546">blaze::sinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7a0832cb251d6b576244a12dad712546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7a0832cb251d6b576244a12dad712546">More...</a><br /></td></tr>
<tr class="separator:ga7a0832cb251d6b576244a12dad712546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca849c7b6d6493c2f590b60f88730fc8"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaca849c7b6d6493c2f590b60f88730fc8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaca849c7b6d6493c2f590b60f88730fc8">blaze::asinh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaca849c7b6d6493c2f590b60f88730fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaca849c7b6d6493c2f590b60f88730fc8">More...</a><br /></td></tr>
<tr class="separator:gaca849c7b6d6493c2f590b60f88730fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674d083d73048e06813e988f134c2832"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga674d083d73048e06813e988f134c2832"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga674d083d73048e06813e988f134c2832">blaze::cos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga674d083d73048e06813e988f134c2832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga674d083d73048e06813e988f134c2832">More...</a><br /></td></tr>
<tr class="separator:ga674d083d73048e06813e988f134c2832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75dd2e64462152850559bfa1288e2bd1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga75dd2e64462152850559bfa1288e2bd1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga75dd2e64462152850559bfa1288e2bd1">blaze::acos</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga75dd2e64462152850559bfa1288e2bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga75dd2e64462152850559bfa1288e2bd1">More...</a><br /></td></tr>
<tr class="separator:ga75dd2e64462152850559bfa1288e2bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3501a4a7cc63a30e3bba26de85c019bb"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3501a4a7cc63a30e3bba26de85c019bb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3501a4a7cc63a30e3bba26de85c019bb">blaze::cosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga3501a4a7cc63a30e3bba26de85c019bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga3501a4a7cc63a30e3bba26de85c019bb">More...</a><br /></td></tr>
<tr class="separator:ga3501a4a7cc63a30e3bba26de85c019bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade939d0467ac5a0207a0feefa76c947a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gade939d0467ac5a0207a0feefa76c947a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gade939d0467ac5a0207a0feefa76c947a">blaze::acosh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gade939d0467ac5a0207a0feefa76c947a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gade939d0467ac5a0207a0feefa76c947a">More...</a><br /></td></tr>
<tr class="separator:gade939d0467ac5a0207a0feefa76c947a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3616341d1c247a1cae1f11978f5bee45"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga3616341d1c247a1cae1f11978f5bee45"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3616341d1c247a1cae1f11978f5bee45">blaze::tan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga3616341d1c247a1cae1f11978f5bee45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga3616341d1c247a1cae1f11978f5bee45">More...</a><br /></td></tr>
<tr class="separator:ga3616341d1c247a1cae1f11978f5bee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8c4f1b6e2c3bba472c4ffd09112ebc"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gade8c4f1b6e2c3bba472c4ffd09112ebc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gade8c4f1b6e2c3bba472c4ffd09112ebc">blaze::atan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gade8c4f1b6e2c3bba472c4ffd09112ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gade8c4f1b6e2c3bba472c4ffd09112ebc">More...</a><br /></td></tr>
<tr class="separator:gade8c4f1b6e2c3bba472c4ffd09112ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80762f317022d125217bfe99ca525772"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga80762f317022d125217bfe99ca525772"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga80762f317022d125217bfe99ca525772">blaze::tanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga80762f317022d125217bfe99ca525772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga80762f317022d125217bfe99ca525772">More...</a><br /></td></tr>
<tr class="separator:ga80762f317022d125217bfe99ca525772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0ac05ae28435fa97afad639362fec0"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7f0ac05ae28435fa97afad639362fec0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7f0ac05ae28435fa97afad639362fec0">blaze::atanh</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7f0ac05ae28435fa97afad639362fec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7f0ac05ae28435fa97afad639362fec0">More...</a><br /></td></tr>
<tr class="separator:ga7f0ac05ae28435fa97afad639362fec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8597b1f5b681757112efb6f1d678f20"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaa8597b1f5b681757112efb6f1d678f20"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa8597b1f5b681757112efb6f1d678f20">blaze::erf</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaa8597b1f5b681757112efb6f1d678f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaa8597b1f5b681757112efb6f1d678f20">More...</a><br /></td></tr>
<tr class="separator:gaa8597b1f5b681757112efb6f1d678f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9107984fd7e2ce054a789f0305964a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9a9107984fd7e2ce054a789f0305964a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9a9107984fd7e2ce054a789f0305964a">blaze::erfc</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9a9107984fd7e2ce054a789f0305964a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function for each non-zero element of the sparse matrix <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga9a9107984fd7e2ce054a789f0305964a">More...</a><br /></td></tr>
<tr class="separator:ga9a9107984fd7e2ce054a789f0305964a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33919cd1cc8c8d8ff2dd4b5656b2084c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga33919cd1cc8c8d8ff2dd4b5656b2084c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga33919cd1cc8c8d8ff2dd4b5656b2084c">blaze::operator/</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;mat, ST scalar)</td></tr>
<tr class="memdesc:ga33919cd1cc8c8d8ff2dd4b5656b2084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_94.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga33919cd1cc8c8d8ff2dd4b5656b2084c">More...</a><br /></td></tr>
<tr class="separator:ga33919cd1cc8c8d8ff2dd4b5656b2084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd36433fdfb7e29a028f1f95bdd913e"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga0cd36433fdfb7e29a028f1f95bdd913e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga0cd36433fdfb7e29a028f1f95bdd913e">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga0cd36433fdfb7e29a028f1f95bdd913e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_95.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga0cd36433fdfb7e29a028f1f95bdd913e">More...</a><br /></td></tr>
<tr class="separator:ga0cd36433fdfb7e29a028f1f95bdd913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7107de80e60ca5da2a6da14133b9cb7"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:gac7107de80e60ca5da2a6da14133b9cb7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac7107de80e60ca5da2a6da14133b9cb7">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;mat, ST scalar)</td></tr>
<tr class="memdesc:gac7107de80e60ca5da2a6da14133b9cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac7107de80e60ca5da2a6da14133b9cb7">More...</a><br /></td></tr>
<tr class="separator:gac7107de80e60ca5da2a6da14133b9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671632b074a58aa21cefc2801d8879ad"><td class="memTemplParams" colspan="2">template&lt;typename ST , typename MT , bool SO, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </td></tr>
<tr class="memitem:ga671632b074a58aa21cefc2801d8879ad"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga671632b074a58aa21cefc2801d8879ad">blaze::operator*</a> (ST scalar, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga671632b074a58aa21cefc2801d8879ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_96.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga671632b074a58aa21cefc2801d8879ad">More...</a><br /></td></tr>
<tr class="separator:ga671632b074a58aa21cefc2801d8879ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7791f2c1585deeac3821eb9eb96728b5"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7791f2c1585deeac3821eb9eb96728b5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7791f2c1585deeac3821eb9eb96728b5">blaze::serial</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7791f2c1585deeac3821eb9eb96728b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#ga7791f2c1585deeac3821eb9eb96728b5">More...</a><br /></td></tr>
<tr class="separator:ga7791f2c1585deeac3821eb9eb96728b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ef88d7fe84f05c59d7bc6494e9dfaf"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga30ef88d7fe84f05c59d7bc6494e9dfaf"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga30ef88d7fe84f05c59d7bc6494e9dfaf">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga30ef88d7fe84f05c59d7bc6494e9dfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga30ef88d7fe84f05c59d7bc6494e9dfaf">More...</a><br /></td></tr>
<tr class="separator:ga30ef88d7fe84f05c59d7bc6494e9dfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341c864583bfe3e73823cc7378116a15"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga341c864583bfe3e73823cc7378116a15"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga341c864583bfe3e73823cc7378116a15">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga341c864583bfe3e73823cc7378116a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga341c864583bfe3e73823cc7378116a15">More...</a><br /></td></tr>
<tr class="separator:ga341c864583bfe3e73823cc7378116a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03a7fbb66466e5af45fca01d7a6a320"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab03a7fbb66466e5af45fca01d7a6a320"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab03a7fbb66466e5af45fca01d7a6a320">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab03a7fbb66466e5af45fca01d7a6a320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gab03a7fbb66466e5af45fca01d7a6a320">More...</a><br /></td></tr>
<tr class="separator:gab03a7fbb66466e5af45fca01d7a6a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f3bbd5bbeb0917a44fa37aa20c583b"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa7f3bbd5bbeb0917a44fa37aa20c583b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa7f3bbd5bbeb0917a44fa37aa20c583b">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa7f3bbd5bbeb0917a44fa37aa20c583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa7f3bbd5bbeb0917a44fa37aa20c583b">More...</a><br /></td></tr>
<tr class="separator:gaa7f3bbd5bbeb0917a44fa37aa20c583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b683cb962c5214646cb04a0c81049a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga72b683cb962c5214646cb04a0c81049a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga72b683cb962c5214646cb04a0c81049a">blaze::trans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga72b683cb962c5214646cb04a0c81049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga72b683cb962c5214646cb04a0c81049a">More...</a><br /></td></tr>
<tr class="separator:ga72b683cb962c5214646cb04a0c81049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4453ce085334a951b961e15b1325ae5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab4453ce085334a951b961e15b1325ae5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab4453ce085334a951b961e15b1325ae5">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab4453ce085334a951b961e15b1325ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gab4453ce085334a951b961e15b1325ae5">More...</a><br /></td></tr>
<tr class="separator:gab4453ce085334a951b961e15b1325ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb2b731158df09b48c6a3f638e95627"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga0fb2b731158df09b48c6a3f638e95627"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga0fb2b731158df09b48c6a3f638e95627">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0fb2b731158df09b48c6a3f638e95627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga0fb2b731158df09b48c6a3f638e95627">More...</a><br /></td></tr>
<tr class="separator:ga0fb2b731158df09b48c6a3f638e95627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3865f8884548af6a560e7680919469"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga4a3865f8884548af6a560e7680919469"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4a3865f8884548af6a560e7680919469">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4a3865f8884548af6a560e7680919469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga4a3865f8884548af6a560e7680919469">More...</a><br /></td></tr>
<tr class="separator:ga4a3865f8884548af6a560e7680919469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ce0648b27470d4c66fbd86579eda7a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa9ce0648b27470d4c66fbd86579eda7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa9ce0648b27470d4c66fbd86579eda7a">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa9ce0648b27470d4c66fbd86579eda7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa9ce0648b27470d4c66fbd86579eda7a">More...</a><br /></td></tr>
<tr class="separator:gaa9ce0648b27470d4c66fbd86579eda7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fb79e26189d84af0e645f82e042c00"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab3fb79e26189d84af0e645f82e042c00"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gab3fb79e26189d84af0e645f82e042c00">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fb79e26189d84af0e645f82e042c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gab3fb79e26189d84af0e645f82e042c00">More...</a><br /></td></tr>
<tr class="separator:gab3fb79e26189d84af0e645f82e042c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a40597fb7b04f0c8ec2bc7c44db96de"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0a40597fb7b04f0c8ec2bc7c44db96de"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga0a40597fb7b04f0c8ec2bc7c44db96de">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0a40597fb7b04f0c8ec2bc7c44db96de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga0a40597fb7b04f0c8ec2bc7c44db96de">More...</a><br /></td></tr>
<tr class="separator:ga0a40597fb7b04f0c8ec2bc7c44db96de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4574efaff2dca352f770bd777d428d9"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gad4574efaff2dca352f770bd777d428d9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad4574efaff2dca352f770bd777d428d9">blaze::operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad4574efaff2dca352f770bd777d428d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gad4574efaff2dca352f770bd777d428d9">More...</a><br /></td></tr>
<tr class="separator:gad4574efaff2dca352f770bd777d428d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c219ce124702f399963c486a55cc4f"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename MT &gt; </td></tr>
<tr class="memitem:gaa5c219ce124702f399963c486a55cc4f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa5c219ce124702f399963c486a55cc4f">blaze::operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaa5c219ce124702f399963c486a55cc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa5c219ce124702f399963c486a55cc4f">More...</a><br /></td></tr>
<tr class="separator:gaa5c219ce124702f399963c486a55cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30fb0fc6f5337ee891da8289db54cbe"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gac30fb0fc6f5337ee891da8289db54cbe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac30fb0fc6f5337ee891da8289db54cbe">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac30fb0fc6f5337ee891da8289db54cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac30fb0fc6f5337ee891da8289db54cbe">More...</a><br /></td></tr>
<tr class="separator:gac30fb0fc6f5337ee891da8289db54cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbedfad5475ca74c414f9d521666785"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7fbedfad5475ca74c414f9d521666785"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7fbedfad5475ca74c414f9d521666785">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7fbedfad5475ca74c414f9d521666785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga7fbedfad5475ca74c414f9d521666785">More...</a><br /></td></tr>
<tr class="separator:ga7fbedfad5475ca74c414f9d521666785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a7d3d1f552cdef59791a7c2343dfb0"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga67a7d3d1f552cdef59791a7c2343dfb0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga67a7d3d1f552cdef59791a7c2343dfb0">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga67a7d3d1f552cdef59791a7c2343dfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga67a7d3d1f552cdef59791a7c2343dfb0">More...</a><br /></td></tr>
<tr class="separator:ga67a7d3d1f552cdef59791a7c2343dfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87991a56789637caeaccd0403f119bbb"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga87991a56789637caeaccd0403f119bbb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga87991a56789637caeaccd0403f119bbb">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga87991a56789637caeaccd0403f119bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga87991a56789637caeaccd0403f119bbb">More...</a><br /></td></tr>
<tr class="separator:ga87991a56789637caeaccd0403f119bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac501fe7adbe7c1e014fca05eb52ca903"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gac501fe7adbe7c1e014fca05eb52ca903"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac501fe7adbe7c1e014fca05eb52ca903">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac501fe7adbe7c1e014fca05eb52ca903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac501fe7adbe7c1e014fca05eb52ca903">More...</a><br /></td></tr>
<tr class="separator:gac501fe7adbe7c1e014fca05eb52ca903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bac1269c33c0195082b551e3d0fd5c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga25bac1269c33c0195082b551e3d0fd5c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga25bac1269c33c0195082b551e3d0fd5c">blaze::operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga25bac1269c33c0195082b551e3d0fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga25bac1269c33c0195082b551e3d0fd5c">More...</a><br /></td></tr>
<tr class="separator:ga25bac1269c33c0195082b551e3d0fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454bac6ca812861ef3f785aae74d83bd"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga454bac6ca812861ef3f785aae74d83bd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga454bac6ca812861ef3f785aae74d83bd">blaze::operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga454bac6ca812861ef3f785aae74d83bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga454bac6ca812861ef3f785aae74d83bd">More...</a><br /></td></tr>
<tr class="separator:ga454bac6ca812861ef3f785aae74d83bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeacf8124cac1cc0d4012f460d58b7edc"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 , typename  = DisableIf_&lt; Or&lt; And&lt; IsUniLower&lt;MT1&gt;, IsUniUpper&lt;MT2&gt; &gt;                                   , And&lt; IsUniUpper&lt;MT1&gt;, IsUniLower&lt;MT2&gt; &gt; &gt; &gt;&gt; </td></tr>
<tr class="memitem:gaeacf8124cac1cc0d4012f460d58b7edc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/df9/classblaze_1_1TSMatTSMatSchurExpr.html">TSMatTSMatSchurExpr</a>&lt; MT1, MT2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaeacf8124cac1cc0d4012f460d58b7edc">blaze::tsmattsmatschur</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaeacf8124cac1cc0d4012f460d58b7edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend implementation of the Schur product between two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaeacf8124cac1cc0d4012f460d58b7edc">More...</a><br /></td></tr>
<tr class="separator:gaeacf8124cac1cc0d4012f460d58b7edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd4361b4bc2c9106d4ac3f18193a86f"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga1dd4361b4bc2c9106d4ac3f18193a86f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1dd4361b4bc2c9106d4ac3f18193a86f">blaze::operator%</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1dd4361b4bc2c9106d4ac3f18193a86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the Schur product of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1dd4361b4bc2c9106d4ac3f18193a86f">More...</a><br /></td></tr>
<tr class="separator:ga1dd4361b4bc2c9106d4ac3f18193a86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0e9818d88483ad5442711f995a3349"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gadd0e9818d88483ad5442711f995a3349"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadd0e9818d88483ad5442711f995a3349">blaze::operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadd0e9818d88483ad5442711f995a3349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gadd0e9818d88483ad5442711f995a3349">More...</a><br /></td></tr>
<tr class="separator:gadd0e9818d88483ad5442711f995a3349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">More...</a><br /></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad8fe418ba6e1d414a1915677cd42a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">More...</a><br /></td></tr>
<tr class="separator:gad8fe418ba6e1d414a1915677cd42a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MatrixAccessProxy global functions</h2></td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">blaze::reset</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa329d4ff44a8780cb8f29343ffc32790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="../../d0/d45/group__sparse__matrix.html#gaa329d4ff44a8780cb8f29343ffc32790">More...</a><br /></td></tr>
<tr class="separator:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">blaze::clear</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="../../d0/d45/group__sparse__matrix.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">More...</a><br /></td></tr>
<tr class="separator:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868d66bdd8bf2a66c2ca3070b9b405c0"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT &gt; </td></tr>
<tr class="memitem:ga868d66bdd8bf2a66c2ca3070b9b405c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga868d66bdd8bf2a66c2ca3070b9b405c0">blaze::isDefault</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga868d66bdd8bf2a66c2ca3070b9b405c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="../../d0/d45/group__sparse__matrix.html#ga868d66bdd8bf2a66c2ca3070b9b405c0">More...</a><br /></td></tr>
<tr class="separator:ga868d66bdd8bf2a66c2ca3070b9b405c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee949313474e40ba1ae59e4ee0effc7b"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT &gt; </td></tr>
<tr class="memitem:gaee949313474e40ba1ae59e4ee0effc7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaee949313474e40ba1ae59e4ee0effc7b">blaze::isReal</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaee949313474e40ba1ae59e4ee0effc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix element represents a real number.  <a href="../../d0/d45/group__sparse__matrix.html#gaee949313474e40ba1ae59e4ee0effc7b">More...</a><br /></td></tr>
<tr class="separator:gaee949313474e40ba1ae59e4ee0effc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f81b77ccdaf00ee271abda38355e34"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT &gt; </td></tr>
<tr class="memitem:ga70f81b77ccdaf00ee271abda38355e34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga70f81b77ccdaf00ee271abda38355e34">blaze::isZero</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga70f81b77ccdaf00ee271abda38355e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 0.  <a href="../../d0/d45/group__sparse__matrix.html#ga70f81b77ccdaf00ee271abda38355e34">More...</a><br /></td></tr>
<tr class="separator:ga70f81b77ccdaf00ee271abda38355e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352ea0fd5d3b6ebeea997e7ea0990e6b"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT &gt; </td></tr>
<tr class="memitem:ga352ea0fd5d3b6ebeea997e7ea0990e6b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga352ea0fd5d3b6ebeea997e7ea0990e6b">blaze::isOne</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga352ea0fd5d3b6ebeea997e7ea0990e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is 1.  <a href="../../d0/d45/group__sparse__matrix.html#ga352ea0fd5d3b6ebeea997e7ea0990e6b">More...</a><br /></td></tr>
<tr class="separator:ga352ea0fd5d3b6ebeea997e7ea0990e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga272972206a96bceac26706156979ddc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">blaze::isnan</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga272972206a96bceac26706156979ddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is not a number.  <a href="../../d0/d45/group__sparse__matrix.html#ga272972206a96bceac26706156979ddc0">More...</a><br /></td></tr>
<tr class="separator:ga272972206a96bceac26706156979ddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">blaze::swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga48b3ef0a633565ae5ae8d03422150d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="../../d0/d45/group__sparse__matrix.html#ga48b3ef0a633565ae5ae8d03422150d66">More...</a><br /></td></tr>
<tr class="separator:ga48b3ef0a633565ae5ae8d03422150d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">blaze::swap</a> (const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;a, T &amp;b) noexcept</td></tr>
<tr class="memdesc:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga56e363bb9d02dc099d3d52ba6ad93373">More...</a><br /></td></tr>
<tr class="separator:ga56e363bb9d02dc099d3d52ba6ad93373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga1ba7ff15d755e738537539e75ec37072"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">blaze::swap</a> (T &amp;a, const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga1ba7ff15d755e738537539e75ec37072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="../../d0/d45/group__sparse__matrix.html#ga1ba7ff15d755e738537539e75ec37072">More...</a><br /></td></tr>
<tr class="separator:ga1ba7ff15d755e738537539e75ec37072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrix operators</h2></td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse matrices with different storage order.  <a href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">More...</a><br /></td></tr>
<tr class="separator:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">blaze::operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga23358313c28966ce20d3e636914c151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">More...</a><br /></td></tr>
<tr class="separator:ga23358313c28966ce20d3e636914c151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">blaze::operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac3f69b34e146551053564a5ddba4469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">More...</a><br /></td></tr>
<tr class="separator:gac3f69b34e146551053564a5ddba4469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrix functions</h2></td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">blaze::isnan</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse matrix for not-a-number elements.  <a href="../../d0/d45/group__sparse__matrix.html#ga5fd7ae64eff3d41879d3fc8a138daa7d">More...</a><br /></td></tr>
<tr class="separator:ga5fd7ae64eff3d41879d3fc8a138daa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb34c5e4364e0f4e3553d1d98d1dbab5"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gadb34c5e4364e0f4e3553d1d98d1dbab5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gadb34c5e4364e0f4e3553d1d98d1dbab5">blaze::isSymmetric</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gadb34c5e4364e0f4e3553d1d98d1dbab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is symmetric.  <a href="../../d0/d45/group__sparse__matrix.html#gadb34c5e4364e0f4e3553d1d98d1dbab5">More...</a><br /></td></tr>
<tr class="separator:gadb34c5e4364e0f4e3553d1d98d1dbab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0516f969a643dbd6de879592fb0edc1"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac0516f969a643dbd6de879592fb0edc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac0516f969a643dbd6de879592fb0edc1">blaze::isHermitian</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gac0516f969a643dbd6de879592fb0edc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is Hermitian.  <a href="../../d0/d45/group__sparse__matrix.html#gac0516f969a643dbd6de879592fb0edc1">More...</a><br /></td></tr>
<tr class="separator:gac0516f969a643dbd6de879592fb0edc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e720807afdbf8e0807f3ee14b8487c"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac2e720807afdbf8e0807f3ee14b8487c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac2e720807afdbf8e0807f3ee14b8487c">blaze::isUniform</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gac2e720807afdbf8e0807f3ee14b8487c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a uniform matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gac2e720807afdbf8e0807f3ee14b8487c">More...</a><br /></td></tr>
<tr class="separator:gac2e720807afdbf8e0807f3ee14b8487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b25d2bc3d94d5e9615a2f39adba382"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gac6b25d2bc3d94d5e9615a2f39adba382"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac6b25d2bc3d94d5e9615a2f39adba382">blaze::isLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gac6b25d2bc3d94d5e9615a2f39adba382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gac6b25d2bc3d94d5e9615a2f39adba382">More...</a><br /></td></tr>
<tr class="separator:gac6b25d2bc3d94d5e9615a2f39adba382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12179d9725730370b696c130bef0c7f8"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga12179d9725730370b696c130bef0c7f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga12179d9725730370b696c130bef0c7f8">blaze::isUniLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga12179d9725730370b696c130bef0c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a lower unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga12179d9725730370b696c130bef0c7f8">More...</a><br /></td></tr>
<tr class="separator:ga12179d9725730370b696c130bef0c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc14aa80efc6e94977fdc050360d8359"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacc14aa80efc6e94977fdc050360d8359"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gacc14aa80efc6e94977fdc050360d8359">blaze::isStrictlyLower</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gacc14aa80efc6e94977fdc050360d8359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly lower triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gacc14aa80efc6e94977fdc050360d8359">More...</a><br /></td></tr>
<tr class="separator:gacc14aa80efc6e94977fdc050360d8359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade34272db080300167e6ad1d43380674"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gade34272db080300167e6ad1d43380674"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gade34272db080300167e6ad1d43380674">blaze::isUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gade34272db080300167e6ad1d43380674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gade34272db080300167e6ad1d43380674">More...</a><br /></td></tr>
<tr class="separator:gade34272db080300167e6ad1d43380674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e92b39ea6e60cde76564c557e489f0a"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga6e92b39ea6e60cde76564c557e489f0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga6e92b39ea6e60cde76564c557e489f0a">blaze::isUniUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga6e92b39ea6e60cde76564c557e489f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is an upper unitriangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga6e92b39ea6e60cde76564c557e489f0a">More...</a><br /></td></tr>
<tr class="separator:ga6e92b39ea6e60cde76564c557e489f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ee211b011418f9d1a1ab3f589defaa"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gad6ee211b011418f9d1a1ab3f589defaa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad6ee211b011418f9d1a1ab3f589defaa">blaze::isStrictlyUpper</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gad6ee211b011418f9d1a1ab3f589defaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse matrix is a strictly upper triangular matrix.  <a href="../../d0/d45/group__sparse__matrix.html#gad6ee211b011418f9d1a1ab3f589defaa">More...</a><br /></td></tr>
<tr class="separator:gad6ee211b011418f9d1a1ab3f589defaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681f183bb22db2bda509e9a3de0a5381"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga681f183bb22db2bda509e9a3de0a5381"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga681f183bb22db2bda509e9a3de0a5381">blaze::isDiagonal</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga681f183bb22db2bda509e9a3de0a5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is diagonal.  <a href="../../d0/d45/group__sparse__matrix.html#ga681f183bb22db2bda509e9a3de0a5381">More...</a><br /></td></tr>
<tr class="separator:ga681f183bb22db2bda509e9a3de0a5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864d8b32e36c2e1c0371e70ec7d3e575"><td class="memTemplParams" colspan="2">template&lt;bool RF, typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga864d8b32e36c2e1c0371e70ec7d3e575"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga864d8b32e36c2e1c0371e70ec7d3e575">blaze::isIdentity</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga864d8b32e36c2e1c0371e70ec7d3e575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the give sparse matrix is an identity matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga864d8b32e36c2e1c0371e70ec7d3e575">More...</a><br /></td></tr>
<tr class="separator:ga864d8b32e36c2e1c0371e70ec7d3e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">blaze::min</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga939c2915cf7e6cb391d024b4c90dca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga939c2915cf7e6cb391d024b4c90dca15">More...</a><br /></td></tr>
<tr class="separator:ga939c2915cf7e6cb391d024b4c90dca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">blaze::max</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">More...</a><br /></td></tr>
<tr class="separator:ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1a7c2f5063bb49b64e3a8508f20d6825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a7c2f5063bb49b64e3a8508f20d6825">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4" title="Applies the abs() function to each single element of the dense matrix dm. ">abs()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga82c7ab005f0a5070705195db86e7bae4">abs</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga75dd2e64462152850559bfa1288e2bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75dd2e64462152850559bfa1288e2bd1">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function computes the inverse cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90" title="Computes the inverse cosine for each single element of the dense matrix dm. ">acos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga51c819795e3845b35ba6344a19a50b90">acos</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gade939d0467ac5a0207a0feefa76c947a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade939d0467ac5a0207a0feefa76c947a">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function computes the inverse hyperbolic cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace" title="Computes the inverse hyperbolic cosine for each single element of the dense matrix dm...">acosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga328df782acd85cc3d5e3458eac531ace">acosh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[1..\infty)$" src="../../form_93.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga47e0d3f20495e102565fb88380b27418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e0d3f20495e102565fb88380b27418">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function computes the inverse sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87" title="Computes the inverse sine for each single element of the dense matrix dm. ">asin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88e862dd7e670667e8520d80e2d4ba87">asin</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaca849c7b6d6493c2f590b60f88730fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca849c7b6d6493c2f590b60f88730fc8">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function computes the inverse hyperbolic sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734" title="Computes the inverse hyperbolic sine for each single element of the dense matrix dm. ">asinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga2fcf55ee4728e81c09d9c6ab90d7c734">asinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gade8c4f1b6e2c3bba472c4ffd09112ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade8c4f1b6e2c3bba472c4ffd09112ebc">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function computes the inverse tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0" title="Computes the inverse tangent for each single element of the dense matrix dm. ">atan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6887fb234d4aa28bf896f8e684fbe1e0">atan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7f0ac05ae28435fa97afad639362fec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0ac05ae28435fa97afad639362fec0">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse hyperbolic tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function computes the inverse hyperbolic tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55" title="Computes the inverse hyperbolic tangent for each single element of the dense matrix dm...">atanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae0632a5d595720be50b96079f29cdd55">atanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaebccf4da062e0fa956ad7f2812663e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebccf4da062e0fa956ad7f2812663e80">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cubic root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function computes the cubic root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989" title="Computes the cubic root of each single element of the dense matrix dm. ">cbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga208aae7dbc991f038bf8ec1d84afa989">cbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga45d99c41b25e1ccba8c1fe6bc6baa673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d99c41b25e1ccba8c1fe6bc6baa673">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307" title="Applies the ceil() function to each single element of the dense matrix dm. ">ceil()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga86bec4639063b9b7cf5856973008a307">ceil</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga39d6b7686f911eaefbcf7e849b8ecdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d6b7686f911eaefbcf7e849b8ecdbe">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename DT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts each single element of the sparse matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">min</td><td>The lower delimiter. </td></tr>
    <tr><td class="paramname">max</td><td>The upper delimiter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix with restricted elements.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function restricts each element of the input matrix <em>sm</em> to the range <img class="formulaInl" alt="$[min..max]$" src="../../form_88.png"/>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed" title="Restricts each single element of the dense matrix dm to the range . ">clamp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga88b09502be6a6aee96c90a0bc7fa47ed">clamp</a>( A, -1.0, 1.0 );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d9a939b2471f71e81d8eee8c22a5ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9a939b2471f71e81d8eee8c22a5ae4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the element represented by the access proxy to its default initial state. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb" title="Clearing the represented element. ">clear()</a> function, this function clears the vector/matrix to its default initial state. </p>

</div>
</div>
<a id="ga6dc66e24ad4edc3cdc37256850fa3b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc66e24ad4edc3cdc37256850fa3b16">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the complex conjugate of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of each single element of <em>sm</em>.</dd></dl>
<p>The <em>conj</em> function calculates the complex conjugate of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>conj</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga674d083d73048e06813e988f134c2832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674d083d73048e06813e988f134c2832">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function computes the cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43" title="Computes the cosine for each single element of the dense matrix dm. ">cos()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae3ddccb3f7678e3c7a79c31af3af2b43">cos</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3501a4a7cc63a30e3bba26de85c019bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3501a4a7cc63a30e3bba26de85c019bb">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic cosine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function computes the hyperbolic cosine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b" title="Computes the hyperbolic cosine for each single element of the dense matrix dm. ">cosh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga6a875b7f5942c159fb7dd5401fdcb88b">cosh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac8d300f094adea64bb4e5e77ab793c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8d300f094adea64bb4e5e77ab793c54">&#9670;&nbsp;</a></span>ctrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::ctrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate transpose matrix of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate transpose of <em>sm</em>.</dd></dl>
<p>The <em>ctrans</em> function returns an expression representing the conjugate transpose (also called adjoint matrix, Hermitian conjugate matrix or transjugate matrix) of the given input matrix <em>sm</em>.<br />
The following example demonstrates the use of the <em>ctrans</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt; complex&lt;double&gt;</a> &gt; A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga654aa9bc341896a531363e297b65107e">ctrans</a>( A );</div></div><!-- fragment --><p>Note that the <em>ctrans</em> function has the same effect as manually applying the <em>conj</em> and <em>trans</em> function in any order:</p>
<div class="fragment"><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga4c3ba99bdcc46aaef2b7285a5054cacf">conj</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( A ) );  <span class="comment">// Computing the conjugate transpose matrix</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga3d22dbcb5d0acb071e59d7aa41547001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d22dbcb5d0acb071e59d7aa41547001">&#9670;&nbsp;</a></span>decldiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::decldiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given sparse matrix expression <em>sm</em> as diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid diagonal matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decldiag</em> function declares the given sparse matrix expression <em>sm</em> as diagonal. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decldiag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7187096e39dd93ef22367044b3600fe7">decldiag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gacffbb82fc419212e7ee7d7ea02da0b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacffbb82fc419212e7ee7d7ea02da0b7e">&#9670;&nbsp;</a></span>declherm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declherm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given sparse matrix expression <em>sm</em> as Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid Hermitian matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declherm</em> function declares the given sparse matrix expression <em>sm</em> as Hermitian. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declherm</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gada0ab0b8ff7fd8a57ada423a50011679">declherm</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3550a55a93f8b885e1b113a715952fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3550a55a93f8b885e1b113a715952fca">&#9670;&nbsp;</a></span>decllow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::decllow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given sparse matrix expression <em>sm</em> as lower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid lower matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>decllow</em> function declares the given sparse matrix expression <em>sm</em> as lower. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>decllow</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gad34f841b05e0aa88e561d312168e6429">decllow</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabb953cdb04ef1682994bc8a5c690ec56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb953cdb04ef1682994bc8a5c690ec56">&#9670;&nbsp;</a></span>declsym()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declsym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given sparse matrix expression <em>sm</em> as symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid symmetric matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declsym</em> function declares the given sparse matrix expression <em>sm</em> as symmetric. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declsym</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gadf429fe0aac934e266ffef8aa0a284ba">declsym</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa521056d34f89ecf82b15d5eb5228f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa521056d34f89ecf82b15d5eb5228f77">&#9670;&nbsp;</a></span>declupp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::declupp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares the given sparse matrix expression <em>sm</em> as upper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The redeclared sparse matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid upper matrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>declupp</em> function declares the given sparse matrix expression <em>sm</em> as upper. In case the given matrix is not a square matrix, a <em>std::invalid_argument</em> exception is thrown.<br />
The following example demonstrates the use of the <em>declupp</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaceb58b929e36557ec199ba79cbccd247">declupp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa8597b1f5b681757112efb6f1d678f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8597b1f5b681757112efb6f1d678f20">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error function of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function computes the error function for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608" title="Computes the error function for each single element of the dense matrix dm. ">erf()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gae8d14e06526209c8debb6b384e145608">erf</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9a9107984fd7e2ce054a789f0305964a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9107984fd7e2ce054a789f0305964a">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complementary error function of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function computes the complementary error function for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca" title="Computes the complementary error function for each single element of the dense matrix dm...">erfc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaa64b4501c6c359d0fc9955de26f1e0ca">erfc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae7dc3fd3365cf4be7b22a9c754ac9f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7dc3fd3365cf4be7b22a9c754ac9f4c">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse matrix expression <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse matrix.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse matrix expression <em>sm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga19b5ef8a28958146c85a18ef72886b82">eval</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga34d0624722cc50c65464169183fafa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d0624722cc50c65464169183fafa4b">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function computes <img class="formulaInl" alt="$ e^x $" src="../../form_89.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817" title="Computes  for each single element of the dense matrix dm. ">exp()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga01d9361c0ee99c282d650adca58fc817">exp</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gabe1656aa731efa1a21acc0000f6e9623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe1656aa731efa1a21acc0000f6e9623">&#9670;&nbsp;</a></span>exp10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function computes <img class="formulaInl" alt="$ 10^x $" src="../../form_91.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81" title="Computes  for each single element of the dense matrix dm. ">exp10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga5384d15bbb975be8c0c72b8a2193cd81">exp10</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gad776d69924085796fd8b25260e8ed097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad776d69924085796fd8b25260e8ed097">&#9670;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::exp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function computes <img class="formulaInl" alt="$ 2^x $" src="../../form_90.png"/> for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32" title="Computes  for each single element of the dense matrix dm. ">exp2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga1842bcb4ac9e245fdd079dc469499d32">exp2</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gadde7a678ada1f0febcc080b559926053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde7a678ada1f0febcc080b559926053">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30" title="Applies the floor() function to each single element of the dense matrix dm. ">floor()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga17215f7077a9cacabf3d29ffb85cdd30">floor</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4fc08c29fec359383e6856ce15653412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fc08c29fec359383e6856ce15653412">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function evaluates the given custom operation on each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea" title="Evaluates the given custom operation on each single element of the dense matrix dm. ">forEach()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga7ae0b42de3d71f8c56366bd9564f6cea">forEach</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga16165ccd6db21fc1df6b74352a868420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16165ccd6db21fc1df6b74352a868420">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the imaginary parts of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of each single element of <em>sm</em>.</dd></dl>
<p>The <em>imag</em> function calculates the imaginary part of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>imag</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa8996bd18a53f4aff25bdfcd3e79bc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8996bd18a53f4aff25bdfcd3e79bc34">&#9670;&nbsp;</a></span>invcbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invcbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse cubic root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse cubic root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function computes the inverse cubic root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e" title="Computes the inverse cubic root of each single element of the dense matrix dm. ">invcbrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3ac8a6a6b4610343c75aa2e3a537692e">invcbrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga3e875a822e97bd4e1e895241f879c83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e875a822e97bd4e1e895241f879c83d">&#9670;&nbsp;</a></span>invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse square root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse square root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function computes the inverse square root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f" title="Computes the inverse square root of each single element of the dense matrix dm. ">invsqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga25a5afb293f1b00e1e9fedbc9eeb830f">invsqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$(0..\infty)$" src="../../form_87.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga868d66bdd8bf2a66c2ca3070b9b405c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868d66bdd8bf2a66c2ca3070b9b405c0">&#9670;&nbsp;</a></span>isDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga681f183bb22db2bda509e9a3de0a5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga681f183bb22db2bda509e9a3de0a5381">&#9670;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give sparse matrix is diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is diagonal, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is diagonal, i.e. if the non-diagonal elements are default elements. In case of integral or floating point data types, a diagonal matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} aa &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; bb &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; cc &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; xx \\ \end{array}\right)\]" src="../../form_55.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isDiagonal&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a diagonal matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae26e04b0050c0d9ec960e21184d063ee">isDiagonal</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gac0516f969a643dbd6de879592fb0edc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0516f969a643dbd6de879592fb0edc1">&#9670;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isHermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is Hermitian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is Hermitian, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an Hermitian matrix. The matrix is considered to be an Hermitian matrix if it is a square matrix whose conjugate transpose is equal to itself ( <img class="formulaInl" alt="$ A = \overline{A^T} $" src="../../form_22.png"/>), i.e. each matrix element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_24.png"/> is equal to the complex conjugate of the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_25.png"/>. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">isHermitian</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isHermitian&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an Hermitian matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gac019dffc6f1692e1554eb4ec3c6359a8">isHermitian</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga864d8b32e36c2e1c0371e70ec7d3e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864d8b32e36c2e1c0371e70ec7d3e575">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the give sparse matrix is an identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an identity matrix, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is an identity matrix, i.e. if the diagonal elements are 1 and the non-diagonal elements are 0. In case of integral or floating point data types, an identity matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array}\right)\]" src="../../form_56.png"/>
</p>
<p>The following example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isIdentity&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an identity matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaf4377bd3eea37726b161b1224c2d1604">isIdentity</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gac6b25d2bc3d94d5e9615a2f39adba382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b25d2bc3d94d5e9615a2f39adba382">&#9670;&nbsp;</a></span>isLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a lower triangular matrix. The matrix is considered to be lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} l_{0,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; l_{1,1} &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; l_{2,2} &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; l_{N,N} \\ \end{array}\right).\]" src="../../form_47.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_48.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_49.png"/> matrices are considered as trivially lower triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga76e4cc18360144e03649b843b3e71d5d">isLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga5fd7ae64eff3d41879d3fc8a138daa7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fd7ae64eff3d41879d3fc8a138daa7d">&#9670;&nbsp;</a></span>isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given sparse matrix for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the sparse matrix is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the sparse matrix for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> at least one element of the matrix is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A( 3UL, 4UL );</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga88d643a61cd9e3b87852233e13973f08">isnan</a>( A ) ) { ... }</div></div><!-- fragment --><p>Note that this function only works for matrices with floating point elements. The attempt to use it for a matrix with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a id="ga272972206a96bceac26706156979ddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272972206a96bceac26706156979ddc0">&#9670;&nbsp;</a></span>isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is not a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in not a number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is not a number (NaN). In case it is not a number, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga352ea0fd5d3b6ebeea997e7ea0990e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352ea0fd5d3b6ebeea997e7ea0990e6b">&#9670;&nbsp;</a></span>isOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 1, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 1. In case it is 1, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaee949313474e40ba1ae59e4ee0effc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee949313474e40ba1ae59e4ee0effc7b">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix element represents a real number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix element represents a real number, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the a real number. In case the element is of built-in type, the function returns <em>true</em>. In case the element is of complex type, the function returns <em>true</em> if the imaginary part is equal to 0. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gacc14aa80efc6e94977fdc050360d8359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc14aa80efc6e94977fdc050360d8359">&#9670;&nbsp;</a></span>isStrictlyLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a strictly lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly lower triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a strictly lower triangular matrix. The matrix is considered to be strictly lower triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_51.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">isStrictlyLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isStrictlyLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly lower triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga119bf55e86f4c944024cda1117c11de7">isStrictlyLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gad6ee211b011418f9d1a1ab3f589defaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6ee211b011418f9d1a1ab3f589defaa">&#9670;&nbsp;</a></span>isStrictlyUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isStrictlyUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a strictly upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a strictly upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a strictly upper triangular matrix. The matrix is considered to be strictly upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 0 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ \end{array}\right).\]" src="../../form_54.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">isStrictlyUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isStrictlyUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a strictly upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gabe4088222c02c754e9b3a7306f133fbf">isStrictlyUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gadb34c5e4364e0f4e3553d1d98d1dbab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb34c5e4364e0f4e3553d1d98d1dbab5">&#9670;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is symmetric, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is symmetric. The matrix is considered to be symmetric if it is a square matrix whose transpose is equal to itself ( <img class="formulaInl" alt="$ A = A^T $" src="../../form_23.png"/>). The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isSymmetric&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a symmetric matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gacc6f1a7ad7504c911e99f6e84a57ec73">isSymmetric</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gac2e720807afdbf8e0807f3ee14b8487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e720807afdbf8e0807f3ee14b8487c">&#9670;&nbsp;</a></span>isUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a uniform matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a uniform matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a uniform matrix. The matrix is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniform&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a uniform matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7cd6724c4c75998517110808090ad74c">isUniform</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga12179d9725730370b696c130bef0c7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12179d9725730370b696c130bef0c7f8">&#9670;&nbsp;</a></span>isUniLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniLower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is a lower unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is a lower unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is a lower unitriangular matrix. The matrix is considered to be lower unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ l_{1,0} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ l_{2,0} &amp; l_{2,1} &amp; 1 &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ l_{N,0} &amp; l_{N,1} &amp; l_{N,2} &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_50.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">isUniLower</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniLower&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in a lower unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gaa21ed126177b5c18bff85c2665e2bfa9">isUniLower</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga6e92b39ea6e60cde76564c557e489f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e92b39ea6e60cde76564c557e489f0a">&#9670;&nbsp;</a></span>isUniUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is an upper unitriangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper unitriangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an upper unitriangular matrix. The matrix is considered to be upper unitriangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; 1 &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; 1 &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\ \end{array}\right).\]" src="../../form_53.png"/>
</p>
<p>The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">isUniUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUniUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper unitriangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gad7fb30f7100507698da7138a291adc68">isUniUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="gade34272db080300167e6ad1d43380674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade34272db080300167e6ad1d43380674">&#9670;&nbsp;</a></span>isUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUpper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse matrix is an upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is an upper triangular matrix, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse matrix is an upper triangular matrix. The matrix is considered to be upper triangular if it is a square matrix of the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} u_{0,0} &amp; u_{0,1} &amp; u_{0,2} &amp; \cdots &amp; u_{0,N} \\ 0 &amp; u_{1,1} &amp; u_{1,2} &amp; \cdots &amp; u_{1,N} \\ 0 &amp; 0 &amp; u_{2,2} &amp; \cdots &amp; u_{2,N} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; u_{N,N} \\ \end{array}\right).\]" src="../../form_52.png"/>
</p>
<p><img class="formulaInl" alt="$ 0 \times 0 $" src="../../form_48.png"/> or <img class="formulaInl" alt="$ 1 \times 1 $" src="../../form_49.png"/> matrices are considered as trivially upper triangular. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Initialization</span></div><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( A ) ) { ... }</div></div><!-- fragment --><p>Optionally, it is possible to switch between strict semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a074d019d1c06483083c4c36c7e4509f3" title="Relaxation flag for strict semantics. ">blaze::strict</a>) and relaxed semantics (<a class="el" href="../../d2/de9/namespaceblaze.html#a23645c84f32e9a6dae4fc7a378598bba" title="Relaxation flag for relaxed semantics. ">blaze::relaxed</a>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( isUpper&lt;relaxed&gt;( A ) ) { ... }</div></div><!-- fragment --><p>It is also possible to check if a matrix expression results in an upper triangular matrix:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#gae3bafc9d47a1c4c6ff26d0997c1218be">isUpper</a>( A * B ) ) { ... }</div></div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary matrix. </p>

</div>
</div>
<a id="ga70f81b77ccdaf00ee271abda38355e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70f81b77ccdaf00ee271abda38355e34">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool RF, typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is 0, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy represents the numeric value 0. In case it is 0, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="ga5ee9ea9a5cc2a762fe7a218f6ba393a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee9ea9a5cc2a762fe7a218f6ba393a4">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function computes the natural logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a">log</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gab5d4857f4a998623490b2d0319de59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d4857f4a998623490b2d0319de59bc">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function computes the binary logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de" title="Computes the common logarithm for each single element of the dense matrix dm. ">log10()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaac5b7d6556dffdfa9fb311d5ce5dd7de">log10</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gadd743dfe188f3aa067d95fd53a65a42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd743dfe188f3aa067d95fd53a65a42a">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the common logarithm for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common logarithm of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function computes the common logarithm for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208" title="Computes the binary logarithm for each single element of the dense matrix dm. ">log2()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga75e400cfca815316f564e56795cb7208">log2</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="gaa0c0b7e00bd4fff04d7834374fdb8345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c0b7e00bd4fff04d7834374fdb8345">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename OP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OP&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the given custom operation on each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">op</td><td>The custom operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The custom operation applied to each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function evaluates the given custom operation on each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, []( <span class="keywordtype">double</span> a ){ <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a ); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9a5f94e2e6c14eba8ca707b7a6b7d4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a5f94e2e6c14eba8ca707b7a6b7d4b2">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The given sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse matrix element.</dd></dl>
<p>This function returns the largest element of the given sparse matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga939c2915cf7e6cb391d024b4c90dca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga939c2915cf7e6cb391d024b4c90dca15">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; MT &gt; blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The given sparse matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse matrix element.</dd></dl>
<p>This function returns the smallest element of the given sparse matrix. This function can only be used for element types that support the smaller-than relationship. In case the matrix currently has either 0 rows or 0 columns, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a id="ga23358313c28966ce20d3e636914c151f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23358313c28966ce20d3e636914c151f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a id="ga1def760e8591dc098a2b94ad4501d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1def760e8591dc098a2b94ad4501d3df">&#9670;&nbsp;</a></span>operator%() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga168334f1d51c058414fe29581cf1e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168334f1d51c058414fe29581cf1e65e">&#9670;&nbsp;</a></span>operator%() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac30fb0fc6f5337ee891da8289db54cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac30fb0fc6f5337ee891da8289db54cbe">&#9670;&nbsp;</a></span>operator%() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major sparse matrix and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga7fbedfad5475ca74c414f9d521666785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbedfad5475ca74c414f9d521666785">&#9670;&nbsp;</a></span>operator%() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major sparse matrix and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab03a7fbb66466e5af45fca01d7a6a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab03a7fbb66466e5af45fca01d7a6a320">&#9670;&nbsp;</a></span>operator%() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa9ce0648b27470d4c66fbd86579eda7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ce0648b27470d4c66fbd86579eda7a">&#9670;&nbsp;</a></span>operator%() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga87991a56789637caeaccd0403f119bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87991a56789637caeaccd0403f119bbb">&#9670;&nbsp;</a></span>operator%() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga1dd4361b4bc2c9106d4ac3f18193a86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd4361b4bc2c9106d4ac3f18193a86f">&#9670;&nbsp;</a></span>operator%() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator for the Schur product of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gafc13c77920f97b72180fcf7c07f4b373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc13c77920f97b72180fcf7c07f4b373">&#9670;&nbsp;</a></span>operator%() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaf7d90c00940662e27260afdc38ecd0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d90c00940662e27260afdc38ecd0f5">&#9670;&nbsp;</a></span>operator%() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a row-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4612fad107f743fa8ac8735a6c8f03c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4612fad107f743fa8ac8735a6c8f03c1">&#9670;&nbsp;</a></span>operator%() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major dense matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga62069bfe75e612d20989547be4d85b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62069bfe75e612d20989547be4d85b2a">&#9670;&nbsp;</a></span>operator%() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the Schur product of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the Schur product of a column-major dense matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A % B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0a40597fb7b04f0c8ec2bc7c44db96de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a40597fb7b04f0c8ec2bc7c44db96de">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose dense vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a sparse vector and a transpose dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&lt;rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="gad4574efaff2dca352f770bd777d428d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4574efaff2dca352f770bd777d428d9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose sparse vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a sparse vector and a transpose sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>(b);</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="gaa5c219ce124702f399963c486a55cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c219ce124702f399963c486a55cc4f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_111.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">y = x * A;</div></div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>VT::ElementType</em> and <em>MT::ElementType</em>. Both the dense matrix type <em>VT</em> and the dense vector type <em>MT</em> as well as the two element types <em>VT::ElementType</em> and <em>MT::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga341c864583bfe3e73823cc7378116a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga341c864583bfe3e73823cc7378116a15">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga4a3865f8884548af6a560e7680919469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3865f8884548af6a560e7680919469">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a row-major sparse matrix and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga67a7d3d1f552cdef59791a7c2343dfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67a7d3d1f552cdef59791a7c2343dfb0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of a column-major sparse matrix and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>,double,<a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a>&gt; B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga454bac6ca812861ef3f785aae74d83bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454bac6ca812861ef3f785aae74d83bd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_82.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A * B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac7107de80e60ca5da2a6da14133b9cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7107de80e60ca5da2a6da14133b9cb7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_36.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a sparse matrix and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A * 1.25;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>MT::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="ga671632b074a58aa21cefc2801d8879ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671632b074a58aa21cefc2801d8879ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST , typename MT , bool SO, typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the multiplication between a scalar value and a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = 1.25 * A;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>ST</em> and <em>MT::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a id="gadebae18946fa942ef27ff069f2760b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadebae18946fa942ef27ff069f2760b6a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the outer product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side transpose sparse vector for the outer product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This operator represents the outer product between a dense vector and a transpose sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a;</div><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">A = a * b;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em>. Both vector types <em>VT1</em> and <em>VT2</em> as well as the two element types <em>VT1::ElementType</em> and <em>VT2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. </p>

</div>
</div>
<a id="ga30ef88d7fe84f05c59d7bc6494e9dfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ef88d7fe84f05c59d7bc6494e9dfaf">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab4453ce085334a951b961e15b1325ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4453ce085334a951b961e15b1325ae5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a row-major and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0fb2b731158df09b48c6a3f638e95627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb2b731158df09b48c6a3f638e95627">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a column-major and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga25bac1269c33c0195082b551e3d0fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25bac1269c33c0195082b551e3d0fd5c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_81.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added to the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A + B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gaa7f3bbd5bbeb0917a44fa37aa20c583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7f3bbd5bbeb0917a44fa37aa20c583b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two row-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gab3fb79e26189d84af0e645f82e042c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fb79e26189d84af0e645f82e042c00">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a row-major and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A, C;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gac501fe7adbe7c1e014fca05eb52ca903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac501fe7adbe7c1e014fca05eb52ca903">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a column-major and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="gadd0e9818d88483ad5442711f995a3349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd0e9818d88483ad5442711f995a3349">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_84.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the matrix subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted from the left-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two column-major sparse matrices:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A, B, C;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">C = A - B;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the two involved matrix element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em>. Both matrix types <em>MT1</em> and <em>MT2</em> as well as the two element types <em>MT1::ElementType</em> and <em>MT2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current number of rows and columns of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a id="ga0cd36433fdfb7e29a028f1f95bdd913e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd36433fdfb7e29a028f1f95bdd913e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_95.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the matrix.</dd></dl>
<p>This operator represents the negation of a sparse matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = -A;</div></div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse matrix. </p>

</div>
</div>
<a id="ga33919cd1cc8c8d8ff2dd4b5656b2084c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33919cd1cc8c8d8ff2dd4b5656b2084c">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ST , typename  = EnableIf_&lt; IsNumeric&lt;ST&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ST&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_94.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result matrix.</dd></dl>
<p>This operator represents the division of a sparse matrix by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = A / 0.24;</div></div><!-- fragment --><p>The operator returns an expression representing a sparse matrix of the higher-order element type of the involved data types <em>MT::ElementType</em> and <em>ST</em>. Note that this operator only works for scalar values of built-in data type.</p>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by a user assert. </dd></dl>

</div>
</div>
<a id="gac3f69b34e146551053564a5ddba4469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3f69b34e146551053564a5ddba4469c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga52adc17fd1c3cf58857e4bbe59d5215a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52adc17fd1c3cf58857e4bbe59d5215a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse matrices with different storage order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="ga5be271299bf9d21d79adbc98fefc7c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be271299bf9d21d79adbc98fefc7c73">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two row-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gad8fe418ba6e1d414a1915677cd42a034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8fe418ba6e1d414a1915677cd42a034">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two column-major sparse matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse matrices are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="gae1a678b92c26772d92195f4ee9e6fa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a678b92c26772d92195f4ee9e6fa43">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, typename ET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ET&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponential value for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponential value of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function computes the exponential value for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb" title="Computes the exponential value for each single element of the dense matrix dm. ">pow()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga50f9950dc0a14952d77cb22307cee5bb">pow</a>( A, 4.2 );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaee11b603614ecd820533b77d48c5b6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee11b603614ecd820533b77d48c5b6b6">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix containing the real parts of each single element of <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The real part of each single element of <em>sm</em>.</dd></dl>
<p>The <em>real</em> function calculates the real part of each element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>real</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa329d4ff44a8780cb8f29343ffc32790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa329d4ff44a8780cb8f29343ffc32790">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the element represented by the access proxy to its default initial value. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a> function, this function resets all elements of the vector/matrix to the default initial values. </p>

</div>
</div>
<a id="ga0ee630041798b12ebb1798febb2c4120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee630041798b12ebb1798febb2c4120">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90" title="Applies the round() function to each single element of the dense matrix dm. ">round()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac9c035640c6ebfe1669dbe275009de90">round</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7791f2c1585deeac3821eb9eb96728b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7791f2c1585deeac3821eb9eb96728b5">&#9670;&nbsp;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given sparse matrix expression <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse matrix.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given sparse matrix expression <em>sm</em>. The function returns an expression representing the operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gac775fabaa100b5d7367998d1ea31e5fb">serial</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gae4b1b285631e1b9152d4261e49285b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b1b285631e1b9152d4261e49285b01">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function computes the sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315" title="Computes the sine for each single element of the dense matrix dm. ">sin()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga184756a753db8cd2f780d88c3a652315">sin</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7a0832cb251d6b576244a12dad712546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0832cb251d6b576244a12dad712546">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic sine of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function computes the hyperbolic sine for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7" title="Computes the hyperbolic sine for each single element of the dense matrix dm. ">sinh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga517339bd44004f0029c0e399cdea98b7">sinh</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf0801b1a75e0c41dac9cc5fd2c469cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0801b1a75e0c41dac9cc5fd2c469cc2">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of each single element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function computes the square root of each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da" title="Computes the square root of each single element of the dense matrix dm. ">sqrt()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[0..\infty)$" src="../../form_86.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga48b3ef0a633565ae5ae8d03422150d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b3ef0a633565ae5ae8d03422150d66">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga56e363bb9d02dc099d3d52ba6ad93373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e363bb9d02dc099d3d52ba6ad93373">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga1ba7ff15d755e738537539e75ec37072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba7ff15d755e738537539e75ec37072">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga3616341d1c247a1cae1f11978f5bee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3616341d1c247a1cae1f11978f5bee45">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function computes the tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606" title="Computes the tangent for each single element of the dense matrix dm. ">tan()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaedd02a415ad4981909556655496f5606">tan</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="ga80762f317022d125217bfe99ca525772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80762f317022d125217bfe99ca525772">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent for each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix; all non-zero elements must be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hyperbolic tangent of each non-zero element of <em>sm</em>.</dd></dl>
<p>The <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function computes the hyperbolic tangent for each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2" title="Computes the hyperbolic tangent for each single element of the dense matrix dm. ">tanh()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga68dd72087a3e8104e3a089e5c481efd2">tanh</a>( A );</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> non-zero elements are expected to be in the range <img class="formulaInl" alt="$[-1..1]$" src="../../form_92.png"/>. No runtime checks are performed to assert this precondition! </dd></dl>

</div>
</div>
<a id="ga72b683cb962c5214646cb04a0c81049a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72b683cb962c5214646cb04a0c81049a">&#9670;&nbsp;</a></span>trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The sparse matrix to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the matrix.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div><div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga89e370b7fc394ce8cbb51b0114509b08">trans</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gab9b9e3d20db929486251cd5318310433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b9e3d20db929486251cd5318310433">&#9670;&nbsp;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) blaze::trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function to each non-zero element of the sparse matrix <em>sm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The input matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting sparse matrix.</dd></dl>
<p>This function applies the <a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a> function to each non-zero element of the input matrix <em>sm</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895" title="Applies the trunc() function to each single element of the dense matrix dm. ">trunc()</a></em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#ga05bab7da7e169af5159b553cd0b7d895">trunc</a>( A );</div></div><!-- fragment --> 
</div>
</div>
<a id="gaeacf8124cac1cc0d4012f460d58b7edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeacf8124cac1cc0d4012f460d58b7edc">&#9670;&nbsp;</a></span>tsmattsmatschur()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 , typename  = DisableIf_&lt; Or&lt; And&lt; IsUniLower&lt;MT1&gt;, IsUniUpper&lt;MT2&gt; &gt;                                   , And&lt; IsUniUpper&lt;MT1&gt;, IsUniLower&lt;MT2&gt; &gt; &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d7/df9/classblaze_1_1TSMatTSMatSchurExpr.html">TSMatTSMatSchurExpr</a>&lt;MT1,MT2&gt; blaze::tsmattsmatschur </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend implementation of the Schur product between two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B \circ C $" src="../../form_83.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse matrix for the Schur product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix for the Schur product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Schur product of the two matrices.</dd></dl>
<p>This function implements a performance optimized treatment of the Schur product between two column-major sparse matrices. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:24 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
