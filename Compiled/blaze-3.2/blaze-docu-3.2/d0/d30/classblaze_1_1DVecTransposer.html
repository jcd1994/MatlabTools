<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blaze::DVecTransposer&lt; VT, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../df/db8/classblaze_1_1DVecTransposer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::DVecTransposer&lt; VT, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a> &raquo; <a class="el" href="../../de/d90/group__dense__vector.html">Dense Vectors</a> &raquo; <a class="el" href="../../db/d95/group__dense__vector__expression.html">Expressions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense vector.The <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class is a wrapper object for the temporary transposition of a dense vector.  
 <a href="../../d0/d30/classblaze_1_1DVecTransposer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/d93/DVecTransposer_8h_source.html">DVecTransposer.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; DVecTransposer&lt; VT, TF &gt;, TF &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add322e0fc3231f6b35528a57cd479e38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>simdEnabled</b> = VT::simdEnabled
 }<tr class="memdesc:add322e0fc3231f6b35528a57cd479e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SIMD optimization.  <a href="../../d0/d30/classblaze_1_1DVecTransposer.html#add322e0fc3231f6b35528a57cd479e38">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:add322e0fc3231f6b35528a57cd479e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6911585a4391cbc8b4190148b0e501dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: bool { <b>smpAssignable</b> = VT::smpAssignable
 }<tr class="memdesc:a6911585a4391cbc8b4190148b0e501dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../d0/d30/classblaze_1_1DVecTransposer.html#a6911585a4391cbc8b4190148b0e501dc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6911585a4391cbc8b4190148b0e501dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d87c087a7e91e35870f8ea55f8d373f"><td class="memItemLeft" align="right" valign="top"><a id="a4d87c087a7e91e35870f8ea55f8d373f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4d87c087a7e91e35870f8ea55f8d373f">This</a> = <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a>&lt; VT, TF &gt;</td></tr>
<tr class="memdesc:a4d87c087a7e91e35870f8ea55f8d373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> instance. <br /></td></tr>
<tr class="separator:a4d87c087a7e91e35870f8ea55f8d373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1528b554a1b45f1da9f8eff6349e448e"><td class="memItemLeft" align="right" valign="top"><a id="a1528b554a1b45f1da9f8eff6349e448e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a1528b554a1b45f1da9f8eff6349e448e">ResultType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aca0f2ff41fa8f2a1a6ff10fe09817cd8">TransposeType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a1528b554a1b45f1da9f8eff6349e448e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a1528b554a1b45f1da9f8eff6349e448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb439f5168d0827213ef5808934db902"><td class="memItemLeft" align="right" valign="top"><a id="aeb439f5168d0827213ef5808934db902"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#aeb439f5168d0827213ef5808934db902">TransposeType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a5a86db58851c76c3500769d8afdc759e">ResultType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:aeb439f5168d0827213ef5808934db902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:aeb439f5168d0827213ef5808934db902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa4826d2ab86af6ab7ba043a64907dd"><td class="memItemLeft" align="right" valign="top"><a id="acfa4826d2ab86af6ab7ba043a64907dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#acfa4826d2ab86af6ab7ba043a64907dd">ElementType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a9d478221c22767e2ab79fe64681a744b">ElementType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:acfa4826d2ab86af6ab7ba043a64907dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector elements. <br /></td></tr>
<tr class="separator:acfa4826d2ab86af6ab7ba043a64907dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94712c1224b5dca3f59362a47d32a15"><td class="memItemLeft" align="right" valign="top"><a id="ae94712c1224b5dca3f59362a47d32a15"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> = <a class="el" href="../../dc/d7b/group__simd.html#ga0b575b0b82167488f51b14b02b664ba2">SIMDTrait_</a>&lt; <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#acfa4826d2ab86af6ab7ba043a64907dd">ElementType</a> &gt;</td></tr>
<tr class="memdesc:ae94712c1224b5dca3f59362a47d32a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type of the vector elements. <br /></td></tr>
<tr class="separator:ae94712c1224b5dca3f59362a47d32a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af376d1c8a6d179e9fa3eadfda6df0120"><td class="memItemLeft" align="right" valign="top"><a id="af376d1c8a6d179e9fa3eadfda6df0120"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#af376d1c8a6d179e9fa3eadfda6df0120">ReturnType</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa2e2edcdde49d73a7ca7d2515046b088">ReturnType_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:af376d1c8a6d179e9fa3eadfda6df0120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:af376d1c8a6d179e9fa3eadfda6df0120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fd9f9e1901558130e8714965ce6cd8"><td class="memItemLeft" align="right" valign="top"><a id="ac4fd9f9e1901558130e8714965ce6cd8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ac4fd9f9e1901558130e8714965ce6cd8">CompositeType</a> = const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4d87c087a7e91e35870f8ea55f8d373f">This</a> &amp;</td></tr>
<tr class="memdesc:ac4fd9f9e1901558130e8714965ce6cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:ac4fd9f9e1901558130e8714965ce6cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b962ce6697904d59c5a02ee5b88994a"><td class="memItemLeft" align="right" valign="top"><a id="a5b962ce6697904d59c5a02ee5b88994a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5b962ce6697904d59c5a02ee5b88994a">Reference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a1285adb17e7a11f3dee9b2b0f03f8a89">Reference_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a5b962ce6697904d59c5a02ee5b88994a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant vector value. <br /></td></tr>
<tr class="separator:a5b962ce6697904d59c5a02ee5b88994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22579fb280c528d525e0068ea38f9245"><td class="memItemLeft" align="right" valign="top"><a id="a22579fb280c528d525e0068ea38f9245"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a22579fb280c528d525e0068ea38f9245">ConstReference</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a7428fec1f7754658bd4d765ed6e87841">ConstReference_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a22579fb280c528d525e0068ea38f9245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant vector value. <br /></td></tr>
<tr class="separator:a22579fb280c528d525e0068ea38f9245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ea574ca6f566a804bbc8a7f70e8c20"><td class="memItemLeft" align="right" valign="top"><a id="a51ea574ca6f566a804bbc8a7f70e8c20"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a51ea574ca6f566a804bbc8a7f70e8c20">Pointer</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a52d7e49942dc7ea47dc5289b3f43c35b">Pointer_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a51ea574ca6f566a804bbc8a7f70e8c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant vector value. <br /></td></tr>
<tr class="separator:a51ea574ca6f566a804bbc8a7f70e8c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de8d28faa006d900403cccb988903c"><td class="memItemLeft" align="right" valign="top"><a id="a26de8d28faa006d900403cccb988903c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a26de8d28faa006d900403cccb988903c">ConstPointer</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#afe86491b935b63fcc07559cd23830314">ConstPointer_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a26de8d28faa006d900403cccb988903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant vector value. <br /></td></tr>
<tr class="separator:a26de8d28faa006d900403cccb988903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4992c2c5f86a17fc389327684a9505f2"><td class="memItemLeft" align="right" valign="top"><a id="a4992c2c5f86a17fc389327684a9505f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4992c2c5f86a17fc389327684a9505f2">Iterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a55cefc4108da9a311933047654da11b1">Iterator_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a4992c2c5f86a17fc389327684a9505f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a4992c2c5f86a17fc389327684a9505f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4bc84d9e32c3eb6cf20f3090663b63"><td class="memItemLeft" align="right" valign="top"><a id="a2d4bc84d9e32c3eb6cf20f3090663b63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#aa1d864b56dde1649490ccd585cb20508">ConstIterator_</a>&lt; VT &gt;</td></tr>
<tr class="memdesc:a2d4bc84d9e32c3eb6cf20f3090663b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a2d4bc84d9e32c3eb6cf20f3090663b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memItemLeft" align="right" valign="top"><a id="a4e76ca32c31f9077cb773fe1cc414a52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> = VT</td></tr>
<tr class="memdesc:a4e76ca32c31f9077cb773fe1cc414a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a4e76ca32c31f9077cb773fe1cc414a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc93f26871b9f666a0106f3d4c2ad09b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#acc93f26871b9f666a0106f3d4c2ad09b">DVecTransposer</a> (VT &amp;dv) noexcept</td></tr>
<tr class="memdesc:acc93f26871b9f666a0106f3d4c2ad09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class.  <a href="#acc93f26871b9f666a0106f3d4c2ad09b">More...</a><br /></td></tr>
<tr class="separator:acc93f26871b9f666a0106f3d4c2ad09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d42a016119958532f9e24fcfd61cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5b962ce6697904d59c5a02ee5b88994a">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a23d42a016119958532f9e24fcfd61cab">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a23d42a016119958532f9e24fcfd61cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a23d42a016119958532f9e24fcfd61cab">More...</a><br /></td></tr>
<tr class="separator:a23d42a016119958532f9e24fcfd61cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6906201bb55da1ebc7dc8e7b30c6efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a22579fb280c528d525e0068ea38f9245">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#af6906201bb55da1ebc7dc8e7b30c6efc">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:af6906201bb55da1ebc7dc8e7b30c6efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#af6906201bb55da1ebc7dc8e7b30c6efc">More...</a><br /></td></tr>
<tr class="separator:af6906201bb55da1ebc7dc8e7b30c6efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c76c9970eda90fe672574c5e1e03d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5b962ce6697904d59c5a02ee5b88994a">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a8c76c9970eda90fe672574c5e1e03d6c">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a8c76c9970eda90fe672574c5e1e03d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the vector elements.  <a href="#a8c76c9970eda90fe672574c5e1e03d6c">More...</a><br /></td></tr>
<tr class="separator:a8c76c9970eda90fe672574c5e1e03d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ef31f40cc59f52e762e8cd1da3f527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a22579fb280c528d525e0068ea38f9245">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a35ef31f40cc59f52e762e8cd1da3f527">at</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const</td></tr>
<tr class="memdesc:a35ef31f40cc59f52e762e8cd1da3f527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to the vector elements.  <a href="#a35ef31f40cc59f52e762e8cd1da3f527">More...</a><br /></td></tr>
<tr class="separator:a35ef31f40cc59f52e762e8cd1da3f527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52240ed98a6fa933057e78646f7ab3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a51ea574ca6f566a804bbc8a7f70e8c20">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ad52240ed98a6fa933057e78646f7ab3d">data</a> () noexcept</td></tr>
<tr class="memdesc:ad52240ed98a6fa933057e78646f7ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#ad52240ed98a6fa933057e78646f7ab3d">More...</a><br /></td></tr>
<tr class="separator:ad52240ed98a6fa933057e78646f7ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6badb20f7f19243d60d92b14774bfa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a26de8d28faa006d900403cccb988903c">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ab6badb20f7f19243d60d92b14774bfa8">data</a> () const noexcept</td></tr>
<tr class="memdesc:ab6badb20f7f19243d60d92b14774bfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#ab6badb20f7f19243d60d92b14774bfa8">More...</a><br /></td></tr>
<tr class="separator:ab6badb20f7f19243d60d92b14774bfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf433e696a055ddac49882cfeb03d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4992c2c5f86a17fc389327684a9505f2">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a0cf433e696a055ddac49882cfeb03d59">begin</a> ()</td></tr>
<tr class="memdesc:a0cf433e696a055ddac49882cfeb03d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the dense vector.  <a href="#a0cf433e696a055ddac49882cfeb03d59">More...</a><br /></td></tr>
<tr class="separator:a0cf433e696a055ddac49882cfeb03d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d65a8e9fc74f3b28ff28f3448e162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2f8d65a8e9fc74f3b28ff28f3448e162">begin</a> () const</td></tr>
<tr class="memdesc:a2f8d65a8e9fc74f3b28ff28f3448e162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the dense vector.  <a href="#a2f8d65a8e9fc74f3b28ff28f3448e162">More...</a><br /></td></tr>
<tr class="separator:a2f8d65a8e9fc74f3b28ff28f3448e162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed039f287ded496cfa0057b2581d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#abeed039f287ded496cfa0057b2581d9b">cbegin</a> () const</td></tr>
<tr class="memdesc:abeed039f287ded496cfa0057b2581d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the dense vector.  <a href="#abeed039f287ded496cfa0057b2581d9b">More...</a><br /></td></tr>
<tr class="separator:abeed039f287ded496cfa0057b2581d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cccddd53f3f88fb5739bb9d8ec686ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4992c2c5f86a17fc389327684a9505f2">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a1cccddd53f3f88fb5739bb9d8ec686ff">end</a> ()</td></tr>
<tr class="memdesc:a1cccddd53f3f88fb5739bb9d8ec686ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the dense vector.  <a href="#a1cccddd53f3f88fb5739bb9d8ec686ff">More...</a><br /></td></tr>
<tr class="separator:a1cccddd53f3f88fb5739bb9d8ec686ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f73da54cee6eec0ac10d37340fd3608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4f73da54cee6eec0ac10d37340fd3608">end</a> () const</td></tr>
<tr class="memdesc:a4f73da54cee6eec0ac10d37340fd3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the dense vector.  <a href="#a4f73da54cee6eec0ac10d37340fd3608">More...</a><br /></td></tr>
<tr class="separator:a4f73da54cee6eec0ac10d37340fd3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270614918ee4a48a2b85102a48d43371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a270614918ee4a48a2b85102a48d43371">cend</a> () const</td></tr>
<tr class="memdesc:a270614918ee4a48a2b85102a48d43371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the dense vector.  <a href="#a270614918ee4a48a2b85102a48d43371">More...</a><br /></td></tr>
<tr class="separator:a270614918ee4a48a2b85102a48d43371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e0790104c59609b08d1a5ef4c8eba"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a839e0790104c59609b08d1a5ef4c8eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a839e0790104c59609b08d1a5ef4c8eba">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a839e0790104c59609b08d1a5ef4c8eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_43.png"/>).  <a href="#a839e0790104c59609b08d1a5ef4c8eba">More...</a><br /></td></tr>
<tr class="separator:a839e0790104c59609b08d1a5ef4c8eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac076b3a0b18f2e2fce5bcf3ac783ed15"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac076b3a0b18f2e2fce5bcf3ac783ed15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ac076b3a0b18f2e2fce5bcf3ac783ed15">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:ac076b3a0b18f2e2fce5bcf3ac783ed15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_44.png"/>).  <a href="#ac076b3a0b18f2e2fce5bcf3ac783ed15">More...</a><br /></td></tr>
<tr class="separator:ac076b3a0b18f2e2fce5bcf3ac783ed15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed16bb98ddbcd31506551a66d8a81509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#aed16bb98ddbcd31506551a66d8a81509">size</a> () const noexcept</td></tr>
<tr class="memdesc:aed16bb98ddbcd31506551a66d8a81509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the vector.  <a href="#aed16bb98ddbcd31506551a66d8a81509">More...</a><br /></td></tr>
<tr class="separator:aed16bb98ddbcd31506551a66d8a81509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8b4bc9f6f5e94d8a2ddae39a482789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a9c8b4bc9f6f5e94d8a2ddae39a482789">reset</a> ()</td></tr>
<tr class="memdesc:a9c8b4bc9f6f5e94d8a2ddae39a482789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the vector elements.  <a href="#a9c8b4bc9f6f5e94d8a2ddae39a482789">More...</a><br /></td></tr>
<tr class="separator:a9c8b4bc9f6f5e94d8a2ddae39a482789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6a224b197a7ff0d38a51c85ed54995"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3f6a224b197a7ff0d38a51c85ed54995"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a3f6a224b197a7ff0d38a51c85ed54995">canAlias</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:a3f6a224b197a7ff0d38a51c85ed54995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector can alias with the given address <em>alias</em>.  <a href="#a3f6a224b197a7ff0d38a51c85ed54995">More...</a><br /></td></tr>
<tr class="separator:a3f6a224b197a7ff0d38a51c85ed54995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e3d07018ab2b273a1857ac2f698a84"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae9e3d07018ab2b273a1857ac2f698a84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae9e3d07018ab2b273a1857ac2f698a84">isAliased</a> (const Other *alias) const noexcept</td></tr>
<tr class="memdesc:ae9e3d07018ab2b273a1857ac2f698a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is aliased with the given address <em>alias</em>.  <a href="#ae9e3d07018ab2b273a1857ac2f698a84">More...</a><br /></td></tr>
<tr class="separator:ae9e3d07018ab2b273a1857ac2f698a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767e17f3163aab5cc84908997db1991b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a767e17f3163aab5cc84908997db1991b">isAligned</a> () const noexcept</td></tr>
<tr class="memdesc:a767e17f3163aab5cc84908997db1991b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is properly aligned in memory.  <a href="#a767e17f3163aab5cc84908997db1991b">More...</a><br /></td></tr>
<tr class="separator:a767e17f3163aab5cc84908997db1991b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca1f1e9eb635a4033f67f9bf47fbfcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a8ca1f1e9eb635a4033f67f9bf47fbfcc">canSMPAssign</a> () const noexcept</td></tr>
<tr class="memdesc:a8ca1f1e9eb635a4033f67f9bf47fbfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector can be used in SMP assignments.  <a href="#a8ca1f1e9eb635a4033f67f9bf47fbfcc">More...</a><br /></td></tr>
<tr class="separator:a8ca1f1e9eb635a4033f67f9bf47fbfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a18af8c0ae16cec4c1f47fbe30d5966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5a18af8c0ae16cec4c1f47fbe30d5966">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a5a18af8c0ae16cec4c1f47fbe30d5966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load of a SIMD element of the vector.  <a href="#a5a18af8c0ae16cec4c1f47fbe30d5966">More...</a><br /></td></tr>
<tr class="separator:a5a18af8c0ae16cec4c1f47fbe30d5966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093061101ff39f75f079fbe44774e5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a093061101ff39f75f079fbe44774e5d0">loada</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:a093061101ff39f75f079fbe44774e5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of a SIMD element of the vector.  <a href="#a093061101ff39f75f079fbe44774e5d0">More...</a><br /></td></tr>
<tr class="separator:a093061101ff39f75f079fbe44774e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5412f4a7df5555ce08791aadebefcc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#aa5412f4a7df5555ce08791aadebefcc5">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const noexcept</td></tr>
<tr class="memdesc:aa5412f4a7df5555ce08791aadebefcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of a SIMD element of the vector.  <a href="#aa5412f4a7df5555ce08791aadebefcc5">More...</a><br /></td></tr>
<tr class="separator:aa5412f4a7df5555ce08791aadebefcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614606d053fc8e9134c2f33556b3de94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a614606d053fc8e9134c2f33556b3de94">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a614606d053fc8e9134c2f33556b3de94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store of a SIMD element of the vector.  <a href="#a614606d053fc8e9134c2f33556b3de94">More...</a><br /></td></tr>
<tr class="separator:a614606d053fc8e9134c2f33556b3de94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6551f62e53ab90792b3de5d803560f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a6551f62e53ab90792b3de5d803560f7a">storea</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a6551f62e53ab90792b3de5d803560f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a SIMD element of the vector.  <a href="#a6551f62e53ab90792b3de5d803560f7a">More...</a><br /></td></tr>
<tr class="separator:a6551f62e53ab90792b3de5d803560f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b791489625cc939e5e07b52b26c7f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a3b791489625cc939e5e07b52b26c7f62">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a3b791489625cc939e5e07b52b26c7f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of a SIMD element of the vector.  <a href="#a3b791489625cc939e5e07b52b26c7f62">More...</a><br /></td></tr>
<tr class="separator:a3b791489625cc939e5e07b52b26c7f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d1e972f8941a1950c82db3905efc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ab82d1e972f8941a1950c82db3905efc3">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ab82d1e972f8941a1950c82db3905efc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a SIMD element of the vector.  <a href="#ab82d1e972f8941a1950c82db3905efc3">More...</a><br /></td></tr>
<tr class="separator:ab82d1e972f8941a1950c82db3905efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaa469e55ab3833b24ee97ae04fc344"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:addaa469e55ab3833b24ee97ae04fc344"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#addaa469e55ab3833b24ee97ae04fc344">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:addaa469e55ab3833b24ee97ae04fc344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose assignment of a dense vector.  <a href="#addaa469e55ab3833b24ee97ae04fc344">More...</a><br /></td></tr>
<tr class="separator:addaa469e55ab3833b24ee97ae04fc344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002b865a65ddbb55559dc192b818c391"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a002b865a65ddbb55559dc192b818c391"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a002b865a65ddbb55559dc192b818c391">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a002b865a65ddbb55559dc192b818c391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose assignment of a sparse vector.  <a href="#a002b865a65ddbb55559dc192b818c391">More...</a><br /></td></tr>
<tr class="separator:a002b865a65ddbb55559dc192b818c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7969d1befeb6e289d8c64070410b4f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:afd7969d1befeb6e289d8c64070410b4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#afd7969d1befeb6e289d8c64070410b4f">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd7969d1befeb6e289d8c64070410b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose addition assignment of a dense vector.  <a href="#afd7969d1befeb6e289d8c64070410b4f">More...</a><br /></td></tr>
<tr class="separator:afd7969d1befeb6e289d8c64070410b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e8a5b1a7d2e543e2163d7e628e4100"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a73e8a5b1a7d2e543e2163d7e628e4100"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a73e8a5b1a7d2e543e2163d7e628e4100">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a73e8a5b1a7d2e543e2163d7e628e4100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose addition assignment of a sparse vector.  <a href="#a73e8a5b1a7d2e543e2163d7e628e4100">More...</a><br /></td></tr>
<tr class="separator:a73e8a5b1a7d2e543e2163d7e628e4100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769cbfbc92ff288f0818815dbdd969f4"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a769cbfbc92ff288f0818815dbdd969f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a769cbfbc92ff288f0818815dbdd969f4">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a769cbfbc92ff288f0818815dbdd969f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose subtraction assignment of a dense vector.  <a href="#a769cbfbc92ff288f0818815dbdd969f4">More...</a><br /></td></tr>
<tr class="separator:a769cbfbc92ff288f0818815dbdd969f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f46d17fc984bc508dd3d58de2e0ce7"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a47f46d17fc984bc508dd3d58de2e0ce7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a47f46d17fc984bc508dd3d58de2e0ce7">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a47f46d17fc984bc508dd3d58de2e0ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose subtraction assignment of a sparse vector.  <a href="#a47f46d17fc984bc508dd3d58de2e0ce7">More...</a><br /></td></tr>
<tr class="separator:a47f46d17fc984bc508dd3d58de2e0ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774abf6adb50f8d5730bb9d663075313"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a774abf6adb50f8d5730bb9d663075313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a774abf6adb50f8d5730bb9d663075313">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a774abf6adb50f8d5730bb9d663075313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose multiplication assignment of a dense vector.  <a href="#a774abf6adb50f8d5730bb9d663075313">More...</a><br /></td></tr>
<tr class="separator:a774abf6adb50f8d5730bb9d663075313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a01aa5ba58df9f8c8a22bf7ba6711c0"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a1a01aa5ba58df9f8c8a22bf7ba6711c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a1a01aa5ba58df9f8c8a22bf7ba6711c0">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1a01aa5ba58df9f8c8a22bf7ba6711c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose multiplication assignment of a sparse vector.  <a href="#a1a01aa5ba58df9f8c8a22bf7ba6711c0">More...</a><br /></td></tr>
<tr class="separator:a1a01aa5ba58df9f8c8a22bf7ba6711c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff96087db357c8523fa045e4ff55dc5"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a5ff96087db357c8523fa045e4ff55dc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5ff96087db357c8523fa045e4ff55dc5">divAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5ff96087db357c8523fa045e4ff55dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the transpose division assignment of a dense vector.  <a href="#a5ff96087db357c8523fa045e4ff55dc5">More...</a><br /></td></tr>
<tr class="separator:a5ff96087db357c8523fa045e4ff55dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721338a0234a4dee3200733d8056e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a7721338a0234a4dee3200733d8056e68">operator~</a> () noexcept</td></tr>
<tr class="memdesc:a7721338a0234a4dee3200733d8056e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a7721338a0234a4dee3200733d8056e68">More...</a><br /></td></tr>
<tr class="separator:a7721338a0234a4dee3200733d8056e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fea61cee277be4dcad4276b298237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a466fea61cee277be4dcad4276b298237">operator~</a> () const noexcept</td></tr>
<tr class="memdesc:a466fea61cee277be4dcad4276b298237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#a466fea61cee277be4dcad4276b298237">More...</a><br /></td></tr>
<tr class="separator:a466fea61cee277be4dcad4276b298237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae106ac9669122ba9b59a6d941f5c6e20"><td class="memItemLeft" align="right" valign="top"><a id="ae106ac9669122ba9b59a6d941f5c6e20"></a>
VT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae106ac9669122ba9b59a6d941f5c6e20">dv_</a></td></tr>
<tr class="memdesc:ae106ac9669122ba9b59a6d941f5c6e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dense vector operand. <br /></td></tr>
<tr class="separator:ae106ac9669122ba9b59a6d941f5c6e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VT, bool TF&gt;<br />
class blaze::DVecTransposer&lt; VT, TF &gt;</h3>

<p><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense vector.</p>
<p>The <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class is a wrapper object for the temporary transposition of a dense vector. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="add322e0fc3231f6b35528a57cd479e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add322e0fc3231f6b35528a57cd479e38">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SIMD optimization. </p>
<p>The <em>simdEnabled</em> compilation flag indicates whether expressions the vector is involved in can be optimized via SIMD operations. In case the dense vector operand is vectorizable, the <em>simdEnabled</em> compilation flag is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<a id="a6911585a4391cbc8b4190148b0e501dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6911585a4391cbc8b4190148b0e501dc">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for SMP assignments. </p>
<p>The <em>smpAssignable</em> compilation flag indicates whether the vector can be used in SMP (shared memory parallel) assignments (both on the left-hand and right-hand side of the assignment). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc93f26871b9f666a0106f3d4c2ad09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc93f26871b9f666a0106f3d4c2ad09b">&#9670;&nbsp;</a></span>DVecTransposer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::<a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a> </td>
          <td>(</td>
          <td class="paramtype">VT &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afd7969d1befeb6e289d8c64070410b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7969d1befeb6e289d8c64070410b4f">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a73e8a5b1a7d2e543e2163d7e628e4100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e8a5b1a7d2e543e2163d7e628e4100">&#9670;&nbsp;</a></span>addAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="addaa469e55ab3833b24ee97ae04fc344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaa469e55ab3833b24ee97ae04fc344">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a002b865a65ddbb55559dc192b818c391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002b865a65ddbb55559dc192b818c391">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a8c76c9970eda90fe672574c5e1e03d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c76c9970eda90fe672574c5e1e03d6c">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5b962ce6697904d59c5a02ee5b88994a">Reference</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid vector access index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ef31f40cc59f52e762e8cd1da3f527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ef31f40cc59f52e762e8cd1da3f527">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a22579fb280c528d525e0068ea38f9245">ConstReference</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Invalid vector access index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf433e696a055ddac49882cfeb03d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf433e696a055ddac49882cfeb03d59">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4992c2c5f86a17fc389327684a9505f2">Iterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the dense vector. </dd></dl>

</div>
</div>
<a id="a2f8d65a8e9fc74f3b28ff28f3448e162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8d65a8e9fc74f3b28ff28f3448e162">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the dense vector. </dd></dl>

</div>
</div>
<a id="a3f6a224b197a7ff0d38a51c85ed54995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a224b197a7ff0d38a51c85ed54995">&#9670;&nbsp;</a></span>canAlias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a8ca1f1e9eb635a4033f67f9bf47fbfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca1f1e9eb635a4033f67f9bf47fbfcc">&#9670;&nbsp;</a></span>canSMPAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector can be used in SMP assignments, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="abeed039f287ded496cfa0057b2581d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeed039f287ded496cfa0057b2581d9b">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the dense vector. </dd></dl>

</div>
</div>
<a id="a270614918ee4a48a2b85102a48d43371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270614918ee4a48a2b85102a48d43371">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the dense vector. </dd></dl>

</div>
</div>
<a id="ad52240ed98a6fa933057e78646f7ab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52240ed98a6fa933057e78646f7ab3d">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a51ea574ca6f566a804bbc8a7f70e8c20">Pointer</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a id="ab6badb20f7f19243d60d92b14774bfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6badb20f7f19243d60d92b14774bfa8">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a26de8d28faa006d900403cccb988903c">ConstPointer</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a id="a5ff96087db357c8523fa045e4ff55dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff96087db357c8523fa045e4ff55dc5">&#9670;&nbsp;</a></span>divAssign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::divAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose division assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector divisor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a1cccddd53f3f88fb5739bb9d8ec686ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cccddd53f3f88fb5739bb9d8ec686ff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a4992c2c5f86a17fc389327684a9505f2">Iterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the dense vector. </dd></dl>

</div>
</div>
<a id="a4f73da54cee6eec0ac10d37340fd3608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f73da54cee6eec0ac10d37340fd3608">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a2d4bc84d9e32c3eb6cf20f3090663b63">ConstIterator</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the dense vector. </dd></dl>

</div>
</div>
<a id="ae9e3d07018ab2b273a1857ac2f698a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e3d07018ab2b273a1857ac2f698a84">&#9670;&nbsp;</a></span>isAliased()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a767e17f3163aab5cc84908997db1991b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767e17f3163aab5cc84908997db1991b">&#9670;&nbsp;</a></span>isAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector is aligned, <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a5a18af8c0ae16cec4c1f47fbe30d5966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a18af8c0ae16cec4c1f47fbe30d5966">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a093061101ff39f75f079fbe44774e5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093061101ff39f75f079fbe44774e5d0">&#9670;&nbsp;</a></span>loada()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::loada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="aa5412f4a7df5555ce08791aadebefcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5412f4a7df5555ce08791aadebefcc5">&#9670;&nbsp;</a></span>loadu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned load of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded SIMD element.</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a774abf6adb50f8d5730bb9d663075313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774abf6adb50f8d5730bb9d663075313">&#9670;&nbsp;</a></span>multAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a1a01aa5ba58df9f8c8a22bf7ba6711c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a01aa5ba58df9f8c8a22bf7ba6711c0">&#9670;&nbsp;</a></span>multAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a839e0790104c59609b08d1a5ef4c8eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e0790104c59609b08d1a5ef4c8eba">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a> &gt;&amp; <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_43.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a>. </dd></dl>

</div>
</div>
<a id="ac076b3a0b18f2e2fce5bcf3ac783ed15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac076b3a0b18f2e2fce5bcf3ac783ed15">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a> &gt;&amp; <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_44.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A division by zero is only checked by an user assert. </dd></dl>

</div>
</div>
<a id="a23d42a016119958532f9e24fcfd61cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d42a016119958532f9e24fcfd61cab">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a5b962ce6697904d59c5a02ee5b88994a">Reference</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a id="af6906201bb55da1ebc7dc8e7b30c6efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6906201bb55da1ebc7dc8e7b30c6efc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#a22579fb280c528d525e0068ea38f9245">ConstReference</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_28.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a id="a7721338a0234a4dee3200733d8056e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7721338a0234a4dee3200733d8056e68">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a466fea61cee277be4dcad4276b298237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fea61cee277be4dcad4276b298237">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a4e76ca32c31f9077cb773fe1cc414a52">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a id="a9c8b4bc9f6f5e94d8a2ddae39a482789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8b4bc9f6f5e94d8a2ddae39a482789">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aed16bb98ddbcd31506551a66d8a81509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed16bb98ddbcd31506551a66d8a81509">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a id="a614606d053fc8e9134c2f33556b3de94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614606d053fc8e9134c2f33556b3de94">&#9670;&nbsp;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a6551f62e53ab90792b3de5d803560f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6551f62e53ab90792b3de5d803560f7a">&#9670;&nbsp;</a></span>storea()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::storea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a3b791489625cc939e5e07b52b26c7f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b791489625cc939e5e07b52b26c7f62">&#9670;&nbsp;</a></span>storeu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="ab82d1e972f8941a1950c82db3905efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82d1e972f8941a1950c82db3905efc3">&#9670;&nbsp;</a></span>stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html#ae94712c1224b5dca3f59362a47d32a15">SIMDType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of a SIMD element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The SIMD element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a id="a769cbfbc92ff288f0818815dbdd969f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769cbfbc92ff288f0818815dbdd969f4">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a id="a47f46d17fc984bc508dd3d58de2e0ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f46d17fc984bc508dd3d58de2e0ce7">&#9670;&nbsp;</a></span>subAssign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">blaze::DVecTransposer</a>&lt; VT, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the transpose subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/expressions/<a class="el" href="../../d7/d93/DVecTransposer_8h_source.html">DVecTransposer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:31 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
