<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Customization of Vectors and Matrices</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Customization of Vectors and Matrices </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#custom_data_members">Custom Data Members</a></li>
<li class="level1"><a href="#custom_operations">Custom Operations</a><ul><li class="level2"><a href="#custom_operations_map">The map() Functions</a></li>
<li class="level2"><a href="#custom_operations_free_functions">Free Functions</a></li>
</ul>
</li>
<li class="level1"><a href="#custom_data_types">Custom Data Types</a></li>
</ul>
</div>
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="custom_data_members"></a>
Custom Data Members</h1>
<hr/>
<p>So far the <b>Blaze</b> library does not provide a lot of flexibility to customize the data members of existing <a class="el" href="../../d7/dec/vector_types.html">Vector Types</a> and <a class="el" href="../../da/d37/matrix_types.html">Matrix Types</a>. However, to some extend it is possible to customize vectors and matrices by inheritance. The following example gives an impression on how to create a simple variation of <a class="el" href="../../da/d37/matrix_types.html#matrix_types_custom_matrix">CustomMatrix</a>, which automatically takes care of acquiring and releasing custom memory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type                    <span class="comment">// Data type of the matrix</span></div><div class="line">        , <span class="keywordtype">bool</span> SO = defaultStorageOrder &gt;  <span class="comment">// Storage order</span></div><div class="line"><span class="keyword">class </span>MyCustomMatrix</div><div class="line">   : <span class="keyword">public</span> CustomMatrix&lt; Type, unaligned, unpadded, SO &gt;</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keyword">explicit</span> <span class="keyword">inline</span> MyCustomMatrix( <span class="keywordtype">size_t</span> m, <span class="keywordtype">size_t</span> n )</div><div class="line">      : CustomMatrix&lt;Type,<a class="code" href="../../de/df1/group__math.html#gaa4c0db94efdf35b9bf1834ace9c48177">unaligned</a>,<a class="code" href="../../de/df1/group__math.html#ga1858f68dbe5aba0ded4e45358324e3a1">unpadded</a>,SO&gt;()</div><div class="line">      , array_( new Type[m*n] )</div><div class="line">   {</div><div class="line">      this-&gt;<a class="code" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7">reset</a>( array_.get(), m, n );</div><div class="line">   }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">   std::unique_ptr&lt;Type[]&gt; array_;</div><div class="line">};</div></div><!-- fragment --><p>Please note that this is a simplified example with the intent to show the general approach. The number of constructors, the memory acquisition, and the kind of memory management can of course be adapted to specific requirements. Also, please note that since none of the <b>Blaze</b> vectors and matrices have virtual destructors polymorphic destruction cannot be used.</p>
<p><br />
 </p>
<h1><a class="anchor" id="custom_operations"></a>
Custom Operations</h1>
<hr/>
<p>There are two approaches to extend <b>Blaze</b> with custom operations. First, the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> functions provide the possibility to execute componentwise custom operations on vectors and matrices. Second, it is possible to add customized free functions.</p>
<p><br />
 </p>
<h2><a class="anchor" id="custom_operations_map"></a>
The map() Functions</h2>
<p>Via the unary and binary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> functions it is possible to execute componentwise custom operations on vectors and matrices. The unary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> function can be used to apply a custom operation on each single element of a dense vector or matrix or each non-zero element of a sparse vector or matrix. For instance, the following example demonstrates a custom square root computation on a dense matrix:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> A, B;</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, []( <span class="keywordtype">double</span> d ) { <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( d ); } );</div></div><!-- fragment --><p>The binary <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> function can be used to apply an operation pairwise to the elements of two dense vectors or two dense matrices. The following example demonstrates the merging of two matrices of double precision values into a matrix of double precision complex numbers:</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>{ { 2.1, -4.2 }, { 1.0,  0.6 } };</div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double&gt;</a> <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>{ { 0.3,  1.4 }, { 2.9, -3.4 } };</div><div class="line"></div><div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt; complex&lt;double&gt;</a> &gt; cplx;</div><div class="line"></div><div class="line"><span class="comment">// Creating the matrix</span></div><div class="line"><span class="comment">//    ( (-2.1,  0.3) (-4.2, -1.4) )</span></div><div class="line"><span class="comment">//    ( ( 1.0,  2.9) ( 0.6, -3.4) )</span></div><div class="line">cplx = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga3efb8c5066fb6ae23b0ab8d3408e1b9b">real</a>, <a class="code" href="../../db/df0/group__dense__matrix.html#gaec095b59eb71bbc86cce1fda1e5d2947">imag</a>, []( <span class="keywordtype">double</span> r, <span class="keywordtype">double</span> i ){ <span class="keywordflow">return</span> complex( r, i ); } );</div></div><!-- fragment --><p>These examples demonstrate the most convenient way of defining a unary custom operation by passing a lambda to the <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> function. Alternatively, it is possible to pass a custom functor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Sqrt</div><div class="line">{</div><div class="line">   <span class="keywordtype">double</span> operator()( <span class="keywordtype">double</span> a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a );</div><div class="line">   }</div><div class="line">};</div><div class="line"></div><div class="line">B = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">map</a>( A, Sqrt() );</div></div><!-- fragment --><p>In order for the functor to work in a call to <code><a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a></code> it must define a function call operator, which accepts arguments of the type of the according vector or matrix elements.</p>
<p>Although the operation is automatically parallelized depending on the size of the vector or matrix, no automatic vectorization is possible. In order to enable vectorization, a <code>load()</code> function can be added to the functor, which handles the vectorized computation. Depending on the data type this function is passed one of the following <b>Blaze</b> SIMD data types:</p>
<ul>
<li>
SIMD data types for fundamental data types <ul>
<li>
<code><a class="el" href="../../d0/df2/classblaze_1_1SIMDint8.html" title="SIMD type for 8-bit signed integral data values. ">blaze::SIMDint8</a>:</code> Packed SIMD type for 8-bit signed integral data types </li>
<li>
<code><a class="el" href="../../dd/d00/classblaze_1_1SIMDuint8.html" title="SIMD type for 8-bit unsigned integral data values. ">blaze::SIMDuint8</a>:</code> Packed SIMD type for 8-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../d5/d4c/classblaze_1_1SIMDint16.html" title="SIMD type for 16-bit signed integral data values. ">blaze::SIMDint16</a>:</code> Packed SIMD type for 16-bit signed integral data types </li>
<li>
<code><a class="el" href="../../d5/d05/classblaze_1_1SIMDuint16.html" title="SIMD type for 16-bit unsigned integral data values. ">blaze::SIMDuint16</a>:</code> Packed SIMD type for 16-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../db/dca/classblaze_1_1SIMDint32.html" title="SIMD type for 32-bit signed integral data values. ">blaze::SIMDint32</a>:</code> Packed SIMD type for 32-bit signed integral data types </li>
<li>
<code><a class="el" href="../../d8/d06/classblaze_1_1SIMDuint32.html" title="SIMD type for 32-bit unsigned integral data values. ">blaze::SIMDuint32</a>:</code> Packed SIMD type for 32-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../d0/d16/classblaze_1_1SIMDint64.html" title="SIMD type for 64-bit integral data values. ">blaze::SIMDint64</a>:</code> Packed SIMD type for 64-bit signed integral data types </li>
<li>
<code><a class="el" href="../../d1/d32/classblaze_1_1SIMDuint64.html" title="SIMD type for 64-bit unsigned integral data values. ">blaze::SIMDuint64</a>:</code> Packed SIMD type for 64-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../d2/dba/classblaze_1_1SIMDfloat.html" title="SIMD type for 32-bit single precision floating point data values. ">blaze::SIMDfloat</a>:</code> Packed SIMD type for single precision floating point data </li>
<li>
<code><a class="el" href="../../d2/d94/classblaze_1_1SIMDdouble.html" title="SIMD type for 64-bit double precision floating point data values. ">blaze::SIMDdouble</a>:</code> Packed SIMD type for double precision floating point data </li>
</ul>
</li>
<li>
SIMD data types for complex data types <ul>
<li>
<code><a class="el" href="../../d8/db1/classblaze_1_1SIMDcint8.html" title="SIMD type for 8-bit signed integral complex values. ">blaze::SIMDcint8</a>:</code> Packed SIMD type for complex 8-bit signed integral data types </li>
<li>
<code><a class="el" href="../../df/db5/classblaze_1_1SIMDcuint8.html" title="SIMD type for 8-bit unsigned integral complex values. ">blaze::SIMDcuint8</a>:</code> Packed SIMD type for complex 8-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../db/d30/classblaze_1_1SIMDcint16.html" title="SIMD type for 16-bit signed integral complex values. ">blaze::SIMDcint16</a>:</code> Packed SIMD type for complex 16-bit signed integral data types </li>
<li>
<code><a class="el" href="../../dc/d8d/classblaze_1_1SIMDcuint16.html" title="SIMD type for 16-bit unsigned integral complex values. ">blaze::SIMDcuint16</a>:</code> Packed SIMD type for complex 16-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../dc/d39/classblaze_1_1SIMDcint32.html" title="SIMD type for 32-bit signed integral complex values. ">blaze::SIMDcint32</a>:</code> Packed SIMD type for complex 32-bit signed integral data types </li>
<li>
<code><a class="el" href="../../df/d64/classblaze_1_1SIMDcuint32.html" title="SIMD type for 32-bit unsigned integral complex values. ">blaze::SIMDcuint32</a>:</code> Packed SIMD type for complex 32-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../d7/df7/classblaze_1_1SIMDcint64.html" title="SIMD type for 64-bit signed integral complex values. ">blaze::SIMDcint64</a>:</code> Packed SIMD type for complex 64-bit signed integral data types </li>
<li>
<code><a class="el" href="../../de/ddd/classblaze_1_1SIMDcuint64.html" title="SIMD type for 64-bit unsigned integral complex values. ">blaze::SIMDcuint64</a>:</code> Packed SIMD type for complex 64-bit unsigned integral data types </li>
<li>
<code><a class="el" href="../../d4/dd2/classblaze_1_1SIMDcfloat.html" title="SIMD type for 32-bit single precision complex values. ">blaze::SIMDcfloat</a>:</code> Packed SIMD type for complex single precision floating point data </li>
<li>
<code><a class="el" href="../../da/d3e/classblaze_1_1SIMDcdouble.html" title="SIMD type for 64-bit double precision complex values. ">blaze::SIMDcdouble</a>:</code> Packed SIMD type for complex double precision floating point data </li>
</ul>
</li>
</ul>
<p>All SIMD types provide the <code>value</code> data member for a direct access to the underlying intrinsic data element. In the following example, this intrinsic element is passed to the AVX function <code>_mm256_sqrt_pd()</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Sqrt</div><div class="line">{</div><div class="line">   <span class="keywordtype">double</span> operator()( <span class="keywordtype">double</span> a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a );</div><div class="line">   }</div><div class="line"></div><div class="line">   SIMDdouble load( <span class="keyword">const</span> SIMDdouble&amp; a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <span class="keywordflow">return</span> _mm256_sqrt_pd( a.value );</div><div class="line">   }</div><div class="line">};</div></div><!-- fragment --><p>In this example, whenever vectorization is generally applicable, the <code>load()</code> function is called instead of the function call operator for as long as the number of remaining elements is larger-or-equal to the width of the packed SIMD type. In all other cases (which also includes peel-off and remainder loops) the scalar operation is used.</p>
<p>Please note that this example has two drawbacks: First, it will only compile in case the intrinsic <code>_mm256_sqrt_pd()</code> function is available (i.e. when AVX is active). Second, the availability of AVX is not taken into account. The first drawback can be alleviated by making the <code>load()</code> function a function template. The second drawback can be dealt with by adding a <code>simdEnabled()</code> function template to the functor:</p>
<div class="fragment"><div class="line">   <span class="keyword">struct </span>Sqrt</div><div class="line">   {</div><div class="line">      <span class="keywordtype">double</span> operator()( <span class="keywordtype">double</span> a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">         <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">std::sqrt</a>( a );</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</div><div class="line">      T load( <span class="keyword">const</span> T&amp; a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">         <span class="keywordflow">return</span> _mm256_sqrt_pd( a.value );</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</div><div class="line">      <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> simdEnabled() {</div><div class="line"><span class="preprocessor">#if defined(__AVX__)</span></div><div class="line">         <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">         <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      }</div><div class="line">   };</div></div><!-- fragment --><p>The <code>simdEnabled()</code> function must be a <code>static</code>, <code>constexpr</code> function and must return whether or not vectorization is available for the given data type <code>T</code>. In case the function returns <code>true</code>, the <code>load()</code> function is used for a vectorized evaluation, in case the function returns <code>false</code>, <code>load()</code> is not called.</p>
<p>Note that this is a simplified example that is only working when used for dense vectors and matrices with double precision floating point elements. The following code shows the complete implementation of the according functor that is used within the <b>Blaze</b> library. The <b>Blaze</b> <code>Sqrt</code> functor is working for all data types that are providing a square root operation:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d2/de9/namespaceblaze.html">blaze</a> {</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Sqrt</div><div class="line">{</div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</div><div class="line">   <a class="code" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <span class="keyword">auto</span> <a class="code" href="../../d0/d06/structblaze_1_1Sqrt.html#a2ea7f7baa9c7ee276946bc6907e4cae5">operator()</a>( <span class="keyword">const</span> T&amp; a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( a );</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</div><div class="line">   <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="../../d0/d06/structblaze_1_1Sqrt.html#ad87efbea4dc8693ff8d231c85d7208db">simdEnabled</a>() { <span class="keywordflow">return</span> HasSIMDSqrt&lt;T&gt;::value; }</div><div class="line"></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</div><div class="line">   <a class="code" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <span class="keyword">auto</span> <a class="code" href="../../d0/d06/structblaze_1_1Sqrt.html#ae86211d8820261a6befbdba4a3a96e0b">load</a>( <span class="keyword">const</span> T&amp; a )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <a class="code" href="../../de/d95/group__math__constraints.html#gaa421408ab45f75089b1e6833f97230c6">BLAZE_CONSTRAINT_MUST_BE_SIMD_PACK</a>( T );</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#gaf8993c014d97629a4db3bd9a61dcd8da">sqrt</a>( a );</div><div class="line">   }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace blaze</span></div></div><!-- fragment --><p>The same approach can be taken for binary custom operations. The following code demonstrates the <code>Min</code> functor of the <b>Blaze</b> library, which is working for all data types that provide a <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e" title="Returns the smallest element of the dense matrix. ">min()</a></code> operation:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Min</div><div class="line">{</div><div class="line">   <span class="keyword">explicit</span> <span class="keyword">inline</span> Min()</div><div class="line">   {}</div><div class="line"></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 &gt;</div><div class="line">   <a class="code" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> decltype(<span class="keyword">auto</span>) operator()( const T1&amp; a, const T2&amp; b )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( a, b );</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 &gt;</div><div class="line">   <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> simdEnabled() { <span class="keywordflow">return</span> HasSIMDMin&lt;T1,T2&gt;::value; }</div><div class="line"></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 &gt;</div><div class="line">   <a class="code" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> decltype(<span class="keyword">auto</span>) load( const T1&amp; a, const T2&amp; b )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">      <a class="code" href="../../de/d95/group__math__constraints.html#gaa421408ab45f75089b1e6833f97230c6">BLAZE_CONSTRAINT_MUST_BE_SIMD_PACK</a>( T1 );</div><div class="line">      <a class="code" href="../../de/d95/group__math__constraints.html#gaa421408ab45f75089b1e6833f97230c6">BLAZE_CONSTRAINT_MUST_BE_SIMD_PACK</a>( T2 );</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="../../db/df0/group__dense__matrix.html#ga1147d0f93d7cc6fad33935048f2b058e">min</a>( a, b );</div><div class="line">   }</div><div class="line">};</div></div><!-- fragment --><p>For more information on the available <b>Blaze</b> SIMD data types and functions, please see the SIMD module in the complete <b>Blaze</b> documentation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="custom_operations_free_functions"></a>
Free Functions</h2>
<p>In order to extend <b>Blaze</b> with new functionality it is possible to add free functions. Free functions can be used either as wrappers around calls to the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a> function or to implement general, non-componentwise operations. The following two examples will demonstrate both ideas.</p>
<p>The first example shows the <code>setToZero()</code> function, which resets a sparse matrix to zero without affecting the sparsity pattern. It is implemented as a convenience wrapper around the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b" title="Evaluates the given binary operation on each single element of the dense matrices lhs and rhs...">map()</a> function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT  <span class="comment">// Type of the sparse matrix</span></div><div class="line">        , <span class="keywordtype">bool</span> SO &gt;    <span class="comment">// Storage order</span></div><div class="line"><span class="keywordtype">void</span> setToZero( <a class="code" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">blaze::SparseMatrix&lt;MT,SO&gt;</a>&amp; mat )</div><div class="line">{</div><div class="line">   (~mat) = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaeacb52db2d3b774340603c1cb32916b">blaze::map</a>( ~mat, []( <span class="keywordtype">int</span> ){ <span class="keywordflow">return</span> 0; } );</div><div class="line">}</div></div><!-- fragment --><p>The <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html" title="Base class for sparse matrices.The SparseMatrix class is a base class for all sparse matrix classes...">blaze::SparseMatrix</a> class template is the base class for all kinds of sparse matrices and provides an abstraction from the actual type <code>MT</code> of the sparse matrix. However, due to the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously Recurring Template Pattern (CRTP)</a> it also enables a conversion back to the actual type. This downcast is performed via the tilde operator (i.e. <code>operator~()</code>). The template parameter <code>SO</code> represents the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a> or <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the matrix.</p>
<p>The second example shows the <code>countZeros()</code> function, which counts the number of values, which are exactly zero, in a dense, row-major matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT &gt;</div><div class="line"><span class="keywordtype">size_t</span> countZeros( <a class="code" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt;MT,rowMajor&gt;</a>&amp; mat )</div><div class="line">{</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">size_t</span> M( (~mat).<a class="code" href="../../dd/d7a/group__matrix.html#ga7b0c6e30994ba97cc2817a848355daf4">rows</a>() );</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">size_t</span> N( (~mat).<a class="code" href="../../dd/d7a/group__matrix.html#ga43caf6f27a219eb68a76ebdf2550b62d">columns</a>() );</div><div class="line">   <span class="keywordtype">size_t</span> count( 0UL );</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0UL; i&lt;M; ++i ) {</div><div class="line">      <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j=0UL; j&lt;N; ++j ) {</div><div class="line">         <span class="keywordflow">if</span>( blaze::isDefault&lt;strict&gt;( (~mat)(i,j) ) )</div><div class="line">            ++count;</div><div class="line">      }</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> count;</div><div class="line">}</div></div><!-- fragment --><p>The <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html" title="Base class for dense matrices.The DenseMatrix class is a base class for all dense matrix classes...">blaze::DenseMatrix</a> class template is the base class for all kinds of dense matrices. Again, it is possible to perform the conversion to the actual type via the tilde operator.</p>
<p>The following two listings show the declarations of all vector and matrix base classes, which can be used for custom free functions:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> VT  <span class="comment">// Concrete type of the dense or sparse vector</span></div><div class="line">        , <span class="keywordtype">bool</span> TF &gt;    <span class="comment">// Transpose flag (blaze::columnVector or blaze::rowVector)</span></div><div class="line"><span class="keyword">class </span>Vector;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> VT  <span class="comment">// Concrete type of the dense vector</span></div><div class="line">        , <span class="keywordtype">bool</span> TF &gt;    <span class="comment">// Transpose flag (blaze::columnVector or blaze::rowVector)</span></div><div class="line"><span class="keyword">class </span>DenseVector;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> VT  <span class="comment">// Concrete type of the sparse vector</span></div><div class="line">        , <span class="keywordtype">bool</span> TF &gt;    <span class="comment">// Transpose flag (blaze::columnVector or blaze::rowVector)</span></div><div class="line"><span class="keyword">class </span>SparseVector;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT  <span class="comment">// Concrete type of the dense or sparse matrix</span></div><div class="line">        , <span class="keywordtype">bool</span> SO &gt;    <span class="comment">// Storage order (blaze::rowMajor or blaze::columnMajor)</span></div><div class="line"><span class="keyword">class </span>Matrix;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT  <span class="comment">// Concrete type of the dense matrix</span></div><div class="line">        , <span class="keywordtype">bool</span> SO &gt;    <span class="comment">// Storage order (blaze::rowMajor or blaze::columnMajor)</span></div><div class="line"><span class="keyword">class </span>DenseMatrix;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT  <span class="comment">// Concrete type of the sparse matrix</span></div><div class="line">        , <span class="keywordtype">bool</span> SO &gt;    <span class="comment">// Storage order (blaze::rowMajor or blaze::columnMajor)</span></div><div class="line"><span class="keyword">class </span>SparseMatrix;</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="custom_data_types"></a>
Custom Data Types</h1>
<hr/>
<p>The <b>Blaze</b> library tries hard to make the use of custom data types as convenient, easy and intuitive as possible. However, unfortunately it is not possible to meet the requirements of all possible data types. Thus it might be necessary to provide <b>Blaze</b> with some additional information about the data type. The following sections give an overview of the necessary steps to enable the use of the hypothetical custom data type <code>custom::double_t</code> for vector and matrix operations. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;custom::double_t&gt;</a> a, b, c;</div><div class="line"><span class="comment">// ... Resizing and initialization</span></div><div class="line">c = a + b;</div></div><!-- fragment --><p>The <b>Blaze</b> library assumes that the <code>custom::double_t</code> data type provides <code><a class="el" href="../../d2/de9/namespaceblaze.html#acc4bc8412b1132b17be23b06833cadc2" title="Addition between a DenseIterator and an integral value. ">operator+()</a></code> for additions, <code><a class="el" href="../../d2/de9/namespaceblaze.html#ad8032b6bc6514096c8edb2f3a731cea0" title="Subtraction between a DenseIterator and an integral value. ">operator-()</a></code> for subtractions, <code><a class="el" href="../../db/df0/group__dense__matrix.html#gad7a8dd3b5e883329b16a6ae2bbef003e" title="Multiplication operator for the multiplication of two row-major dense matrices ( ). ">operator*()</a></code> for multiplications and <code><a class="el" href="../../db/df0/group__dense__matrix.html#ga03f7cce19ada0cda6d89630d8e4c7211" title="Division operator for the division of a dense matrix by a scalar value ( ). ">operator/()</a></code> for divisions. If any of these functions is missing it is necessary to implement the operator to perform the according operation. For this example we assume that the custom data type provides the four following functions instead of operators:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>custom {</div><div class="line"></div><div class="line">double_t add ( <span class="keyword">const</span> double_t&amp; a, <span class="keyword">const</span> double_t b );</div><div class="line">double_t sub ( <span class="keyword">const</span> double_t&amp; a, <span class="keyword">const</span> double_t b );</div><div class="line">double_t mult( <span class="keyword">const</span> double_t&amp; a, <span class="keyword">const</span> double_t b );</div><div class="line">double_t div ( <span class="keyword">const</span> double_t&amp; a, <span class="keyword">const</span> double_t b );</div><div class="line"></div><div class="line">} <span class="comment">// namespace custom</span></div></div><!-- fragment --><p>The following implementations will satisfy the requirements of the <b>Blaze</b> library:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> custom::double_t <a class="code" href="../../d2/de9/namespaceblaze.html#acc4bc8412b1132b17be23b06833cadc2">operator+</a>( <span class="keyword">const</span> custom::double_t&amp; a, <span class="keyword">const</span> custom::double_t&amp; b )</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> add( a, b );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">inline</span> custom::double_t <a class="code" href="../../d2/de9/namespaceblaze.html#ad8032b6bc6514096c8edb2f3a731cea0">operator-</a>( <span class="keyword">const</span> custom::double_t&amp; a, <span class="keyword">const</span> custom::double_t&amp; b )</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> sub( a, b );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">inline</span> custom::double_t <a class="code" href="../../db/df0/group__dense__matrix.html#gad7a8dd3b5e883329b16a6ae2bbef003e">operator*</a>( <span class="keyword">const</span> custom::double_t&amp; a, <span class="keyword">const</span> custom::double_t&amp; b )</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> mult( a, b );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">inline</span> custom::double_t <a class="code" href="../../db/df0/group__dense__matrix.html#ga03f7cce19ada0cda6d89630d8e4c7211">operator/</a>( <span class="keyword">const</span> custom::double_t&amp; a, <span class="keyword">const</span> custom::double_t&amp; b )</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> div( a, b );</div><div class="line">}</div></div><!-- fragment --><p><b>Blaze</b> will use all the information provided with these functions (for instance the return type) to properly handle the operations. In the rare case that the return type cannot be automatically determined from the operator it might be additionally necessary to provide a specialization of the following four <b>Blaze</b> class templates:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d2/de9/namespaceblaze.html">blaze</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>AddTrait&lt;custom::double_t,custom::double_t&gt; {</div><div class="line">   <span class="keyword">typedef</span> custom::double_t  Type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>SubTrait&lt;custom::double_t,custom::double_t&gt; {</div><div class="line">   <span class="keyword">typedef</span> custom::double_t  Type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>MultTrait&lt;custom::double_t,custom::double_t&gt; {</div><div class="line">   <span class="keyword">typedef</span> custom::double_t  Type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>DivTrait&lt;custom::double_t,custom::double_t&gt; {</div><div class="line">   <span class="keyword">typedef</span> custom::double_t  Type;</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace blaze</span></div></div><!-- fragment --><p>The same steps are necessary if several custom data types need to be combined (as for instance <code>custom::double_t</code> and <code>custom::float_t</code>). Note that in this case both permutations need to be taken into account:</p>
<div class="fragment"><div class="line">custom::double_t <a class="code" href="../../d2/de9/namespaceblaze.html#acc4bc8412b1132b17be23b06833cadc2">operator+</a>( <span class="keyword">const</span> custom::double_t&amp; a, <span class="keyword">const</span> custom::float_t&amp; b );</div><div class="line">custom::double_t <a class="code" href="../../d2/de9/namespaceblaze.html#acc4bc8412b1132b17be23b06833cadc2">operator+</a>( <span class="keyword">const</span> custom::float_t&amp; a, <span class="keyword">const</span> custom::double_t&amp; b );</div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>Please note that only built-in data types apply for vectorization and thus custom data types cannot achieve maximum performance!</p>
<p><br />
 Previous: <a class="el" href="../../d6/dc7/configuration_files.html">Configuration Files</a> &#160; &#160; Next: <a class="el" href="../../d4/de4/vector_and_matrix_customization.html#custom_operations">Custom Operations</a> <br />
</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
