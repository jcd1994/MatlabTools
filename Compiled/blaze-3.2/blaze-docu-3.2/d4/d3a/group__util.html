<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Utility module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:da/dbd/group__algorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbd/group__algorithms.html">Algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/dca/group__assert"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/group__assert.html">Assertions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d68/group__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d68/group__constraints.html">Compile time constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d87/group__mpl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d87/group__mpl.html">Meta-Programming Language</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d10/group__random"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html">Random number generation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d23/group__serialization"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d23/group__serialization.html">Serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/daf/group__singleton"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/daf/group__singleton.html">Singleton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/db9/group__threads"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/group__threads.html">Thread parallelization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d0d/group__timing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0d/group__timing.html">Time measurement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/df3/group__typelist"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df3/group__typelist.html">Type lists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d5a/group__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html">Type traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d16/group__value__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d16/group__value__traits.html">Value traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html">blaze::AlignedAllocator&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for type-specific aligned memory.The <a class="el" href="../../d0/d6f/classblaze_1_1AlignedAllocator.html" title="Allocator for type-specific aligned memory.The AlignedAllocator class template represents an implemen...">AlignedAllocator</a> class template represents an implementation of the allocator concept of the standard library for the allocation of type-specific, aligned, uninitialized memory. The allocator performs its allocation via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">blaze::allocate()</a> and <a class="el" href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b" title="Deallocation of memory for built-in data types. ">blaze::deallocate()</a> functions to guarantee properly aligned memory based on the alignment restrictions of the specified type <em>Type</em>. For instance, in case the given type is a fundamental, built-in data type and in case SSE vectorization is possible, the returned memory is guaranteed to be at least 16-byte aligned. In case AVX is active, the memory is even guaranteed to be at least 32-byte aligned.  <a href="../../d0/d6f/classblaze_1_1AlignedAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html">blaze::AlignedArray&lt; Type, N, Alignment &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a static array with a fixed alignment.The <a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html" title="Implementation of a static array with a fixed alignment.The AlignedArray class template represents a ...">AlignedArray</a> class template represents a static array with a guaranteed, fixed alignment. The type of the array elements, the number of elements and the alignment of the array can be specified via the three template parameters:  <a href="../../d3/d25/classblaze_1_1AlignedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">blaze::DisableIfTrue&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) class.The <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../df/df2/structblaze_1_1DisableIfTrue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">blaze::DisableIf&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d6/d36/structblaze_1_1DisableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da5/structblaze_1_1EmptyType.html">blaze::EmptyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty data type for utility purposes.  <a href="../../d7/da5/structblaze_1_1EmptyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">blaze::EnableIfTrue&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d7/d2c/structblaze_1_1EnableIfTrue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">blaze::EnableIf&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) class.The <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is <a class="el" href="../../dd/d46/structblaze_1_1Not.html" title="Compile time type negation.The Not alias declaration negates the given compile time condition...">Not</a> An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d9/d28/structblaze_1_1EnableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6e/classblaze_1_1FunctionTrace.html">blaze::FunctionTrace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII object for function tracing.The <a class="el" href="../../d4/d6e/classblaze_1_1FunctionTrace.html" title="RAII object for function tracing.The FunctionTrace class is an auxiliary helper class for the tracing...">FunctionTrace</a> class is an auxiliary helper class for the tracing of function calls. It is implemented as a wrapper around <code>std::cerr</code> and is responsible for the atomicity of the output of trace information.  <a href="../../d4/d6e/classblaze_1_1FunctionTrace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfc/classblaze_1_1InputString.html">blaze::InputString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a string wrapper.The <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class is a wrapper class for the purpose to read input strings delimited by quotations from streams, like for instance "example input". <a class="el" href="../../d9/de6/structblaze_1_1All.html" title="Compile time type check.This type trait determines whether the given type trait TypeTrait evaluates t...">All</a> characters between the leading and the trailing quotation are extracted unchanged from the input stream, including whitespaces. The input string has to be in one single line. In case of input errors, the <em>std::istream::failbit</em> of the input stream is set.  <a href="../../da/dfc/classblaze_1_1InputString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html">blaze::IntegralConstant&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for a compile time constant integral value.The <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html" title="Generic wrapper for a compile time constant integral value.The IntegralConstant class template repres...">IntegralConstant</a> class template represents a generic wrapper for a compile time constant integral value. The value of an <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html" title="Generic wrapper for a compile time constant integral value.The IntegralConstant class template repres...">IntegralConstant</a> can be accessed via the nested <em>value</em> (which is guaranteed to be of type <em>T</em>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../de/d59/structblaze_1_1IntegralConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dea/structblaze_1_1Limits.html">blaze::Limits&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical limits of built-in data types.The <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">Limits</a> class provides numerical limits for the following built-in data types:  <a href="../../d9/dea/structblaze_1_1Limits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/classblaze_1_1MemoryPool.html">blaze::MemoryPool&lt; Type, Blocksize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory pool for small objects.The memory pool efficiently improves the performance of dynamic memory allocations for small objects. By allocating a large block of memory that can be dynamically assigned to small objects, the memory allocation is reduced from a few hundred cycles to only a few cycles.<br />
The memory pool is build from memory blocks of type <a class="el" href="../../d2/d64/structblaze_1_1MemoryPool_1_1Block.html" title="Memory block within the memory bool. ">Block</a>, which hold the memory for a specified number of objects. The memory of these blocks is managed as a single free list.  <a href="../../d2/d8d/classblaze_1_1MemoryPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">blaze::NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-copyable class instances.The <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html" title="Base class for non-copyable class instances.The NonCopyable class is intended to work as a base class...">NonCopyable</a> class is intended to work as a base class for non-copyable classes. Both the copy constructor and the copy assignment operator are explicitly deleted in order to prohibit copy operations of the derived classes.<br />
.  <a href="../../dd/dbc/classblaze_1_1NonCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html">blaze::NonCreatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-creatable (static) classes.The <a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html" title="Base class for non-creatable (static) classes.The NonCreatable class is intended to work as a base cl...">NonCreatable</a> class is intended to work as a base class for non-creatable classes, i.e. classes that cannot be instantiated and exclusively offer static functions/data. Both the standard as well as the copy constructor and the copy assignment operator are declared private and left undefinded in order to prohibit the instantiation of objects of derived classes.<br />
.  <a href="../../d6/d8e/classblaze_1_1NonCreatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da4/classblaze_1_1NullType.html">blaze::NullType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type for generic codes.The <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> class represents an invalid or terminating data type for generic codes. For instance, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class uses the <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> as terminating data type for the type list.  <a href="../../dd/da4/classblaze_1_1NullType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html">blaze::ArrayDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-delete policy class.The <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> policy functor class applies an array delete operation to the given argument. Note that the array delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply an <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> functor to a pointer to an array of objects of incomplete type results in a compile time error!  <a href="../../d0/d60/structblaze_1_1ArrayDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html">blaze::Deallocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html" title="Deallocate policy class.The Deallocate deletion policy is the according deletion policy for arrays al...">Deallocate</a> policy class.The <a class="el" href="../../db/dc0/structblaze_1_1Deallocate.html" title="Deallocate policy class.The Deallocate deletion policy is the according deletion policy for arrays al...">Deallocate</a> deletion policy is the according deletion policy for arrays allocated via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">blaze::allocate</a> function. It uses deallocate to free the resource. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../db/dc0/structblaze_1_1Deallocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1DefaultDelete.html">blaze::DefaultDelete&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default C++ deletion policy class.The <a class="el" href="../../d2/df1/structblaze_1_1DefaultDelete.html" title="Default C++ deletion policy class.The DefaultDelete deletion policy is the standard delete for resour...">DefaultDelete</a> deletion policy is the standard delete for resources allocated via the new operator. It uses delete or array delete (depending on the template argument) to free the resource:  <a href="../../d2/df1/structblaze_1_1DefaultDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html">blaze::NoDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-delete policy class.  <a href="../../d8/dc7/structblaze_1_1NoDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html">blaze::PtrDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-delete policy class.The <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> policy functor class applies a delete operation to the given argument. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../d9/d94/structblaze_1_1PtrDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">blaze::UnsignedValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-in unsigned integral type in order to be able to extract non-negative unsigned integral values from an input stream.  <a href="../../da/d54/classblaze_1_1UnsignedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1e/classblaze_1_1complex.html">blaze::complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex data type of the Blaze library.  <a href="../../d3/d1e/classblaze_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">blaze::size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> type of the Blaze library.  <a href="../../d9/dcd/classblaze_1_1size__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">blaze::ptrdiff_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer difference type of the Blaze library.  <a href="../../d2/d8c/classblaze_1_1ptrdiff__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3b/classblaze_1_1int8__t.html">blaze::int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type of the Blaze library.  <a href="../../d6/d3b/classblaze_1_1int8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da1/classblaze_1_1uint8__t.html">blaze::uint8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer type of the Blaze library.  <a href="../../da/da1/classblaze_1_1uint8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">blaze::int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type of the Blaze library.  <a href="../../d9/d66/classblaze_1_1int16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3a/classblaze_1_1uint16__t.html">blaze::uint16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer type of the Blaze library.  <a href="../../de/d3a/classblaze_1_1uint16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">blaze::int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type of the Blaze library.  <a href="../../de/d2d/classblaze_1_1int32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">blaze::uint32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type of the Blaze library.  <a href="../../d6/dba/classblaze_1_1uint32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">blaze::int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type of the Blaze library.  <a href="../../d8/dc7/classblaze_1_1int64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">blaze::uint64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type of the Blaze library.  <a href="../../d5/d68/classblaze_1_1uint64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7a1571017e950fdea89e519e2c25c20d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>(EXCEPTION)&#160;&#160;&#160;throw EXCEPTION</td></tr>
<tr class="memdesc:ga7a1571017e950fdea89e519e2c25c20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the error reporting mechanism of the <b>Blaze</b> library.This macro encapsulates the default, general way of the <b>Blaze</b> library to report errors of any kind by throwing an exception. Also, since under certain conditions and environments it may be desirable to replace exceptions by a different error reporting mechanism this macro provides an opportunity to customize the error reporting approach.  <a href="#ga7a1571017e950fdea89e519e2c25c20d">More...</a><br /></td></tr>
<tr class="separator:ga7a1571017e950fdea89e519e2c25c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1075e5bf9b7acdf72d01d150d7f0a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gafa1075e5bf9b7acdf72d01d150d7f0a5">BLAZE_THROW_BAD_ALLOC</a>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::bad_alloc() )</td></tr>
<tr class="memdesc:gafa1075e5bf9b7acdf72d01d150d7f0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::bad_alloc</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::bad_alloc</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#gafa1075e5bf9b7acdf72d01d150d7f0a5">More...</a><br /></td></tr>
<tr class="separator:gafa1075e5bf9b7acdf72d01d150d7f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9df3ec894be73c8bbe412794fad80b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gac9df3ec894be73c8bbe412794fad80b3">BLAZE_THROW_LOGIC_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::logic_error( MESSAGE ) )</td></tr>
<tr class="memdesc:gac9df3ec894be73c8bbe412794fad80b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::logic_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::logic_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#gac9df3ec894be73c8bbe412794fad80b3">More...</a><br /></td></tr>
<tr class="separator:gac9df3ec894be73c8bbe412794fad80b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1011720c48bdd5ad4d83cfb4c7fd3ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gac1011720c48bdd5ad4d83cfb4c7fd3ee">BLAZE_THROW_INVALID_ARGUMENT</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::invalid_argument( MESSAGE ) )</td></tr>
<tr class="memdesc:gac1011720c48bdd5ad4d83cfb4c7fd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::invalid_argument</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::invalid_argument</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#gac1011720c48bdd5ad4d83cfb4c7fd3ee">More...</a><br /></td></tr>
<tr class="separator:gac1011720c48bdd5ad4d83cfb4c7fd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5062f7037528793700d2920a1b07c7ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5062f7037528793700d2920a1b07c7ee">BLAZE_THROW_LENGTH_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::length_error( MESSAGE ) )</td></tr>
<tr class="memdesc:ga5062f7037528793700d2920a1b07c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::length_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::length_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#ga5062f7037528793700d2920a1b07c7ee">More...</a><br /></td></tr>
<tr class="separator:ga5062f7037528793700d2920a1b07c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc93ac25c865f07b82286c432f4173a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaafc93ac25c865f07b82286c432f4173a">BLAZE_THROW_OUT_OF_RANGE</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::out_of_range( MESSAGE ) )</td></tr>
<tr class="memdesc:gaafc93ac25c865f07b82286c432f4173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::out_of_range</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::out_of_range</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#gaafc93ac25c865f07b82286c432f4173a">More...</a><br /></td></tr>
<tr class="separator:gaafc93ac25c865f07b82286c432f4173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d588d35b3322949abb3a1e1c5ea3355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2d588d35b3322949abb3a1e1c5ea3355">BLAZE_THROW_RUNTIME_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::runtime_error( MESSAGE ) )</td></tr>
<tr class="memdesc:ga2d588d35b3322949abb3a1e1c5ea3355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::runtime_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::runtime_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#ga2d588d35b3322949abb3a1e1c5ea3355">More...</a><br /></td></tr>
<tr class="separator:ga2d588d35b3322949abb3a1e1c5ea3355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748daff02e5fb84a1e83e37f15ab05ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga748daff02e5fb84a1e83e37f15ab05ab">BLAZE_THROW_OVERFLOW_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::overflow_error( MESSAGE ) )</td></tr>
<tr class="memdesc:ga748daff02e5fb84a1e83e37f15ab05ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::overflow_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::overflow_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#ga748daff02e5fb84a1e83e37f15ab05ab">More...</a><br /></td></tr>
<tr class="separator:ga748daff02e5fb84a1e83e37f15ab05ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af4c698d5aa64a2e1f3403183a8bdc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5af4c698d5aa64a2e1f3403183a8bdc2">BLAZE_THROW_UNDERFLOW_ERROR</a>(MESSAGE)&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::underflow_error( MESSAGE ) )</td></tr>
<tr class="memdesc:ga5af4c698d5aa64a2e1f3403183a8bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the emission of a <em>std::underflow_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::underflow_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior.  <a href="#ga5af4c698d5aa64a2e1f3403183a8bdc2">More...</a><br /></td></tr>
<tr class="separator:ga5af4c698d5aa64a2e1f3403183a8bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05e3ee65f08fab8e1aff1ef1e0cfc7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gae05e3ee65f08fab8e1aff1ef1e0cfc7f">BLAZE_FUNCTION_TRACE</a></td></tr>
<tr class="memdesc:gae05e3ee65f08fab8e1aff1ef1e0cfc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function trace macro.This macro can be used to reliably trace function calls. In case function tracing is activated, function traces are written to the console via <code>std::cerr</code>. The following short example demonstrates how the function trace macro is used:  <a href="#gae05e3ee65f08fab8e1aff1ef1e0cfc7f">More...</a><br /></td></tr>
<tr class="separator:gae05e3ee65f08fab8e1aff1ef1e0cfc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab69bc69a73945474ec1e28eb904b4c40"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T  = void&gt; </td></tr>
<tr class="memitem:gab69bc69a73945474ec1e28eb904b4c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gab69bc69a73945474ec1e28eb904b4c40">blaze::DisableIfTrue_</a> = typename <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">DisableIfTrue</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gab69bc69a73945474ec1e28eb904b4c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template.The DisableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gab69bc69a73945474ec1e28eb904b4c40">More...</a><br /></td></tr>
<tr class="separator:gab69bc69a73945474ec1e28eb904b4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memTemplParams" colspan="2">template&lt;typename Condition , typename T  = void&gt; </td></tr>
<tr class="memitem:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">blaze::DisableIf_</a> = typename <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template.The DisableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">More...</a><br /></td></tr>
<tr class="separator:gaebf93d6ed8011a7e73476b7d9c34f656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd728948d7bb8402576d198a5b219ed"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T  = void&gt; </td></tr>
<tr class="memitem:gaffd728948d7bb8402576d198a5b219ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaffd728948d7bb8402576d198a5b219ed">blaze::EnableIfTrue_</a> = typename <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">EnableIfTrue</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:gaffd728948d7bb8402576d198a5b219ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary type for the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template.The EnableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaffd728948d7bb8402576d198a5b219ed">More...</a><br /></td></tr>
<tr class="separator:gaffd728948d7bb8402576d198a5b219ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4921d0157490569e91b4f48652561d2b"><td class="memTemplParams" colspan="2">template&lt;typename Condition , typename T  = void&gt; </td></tr>
<tr class="memitem:ga4921d0157490569e91b4f48652561d2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">blaze::EnableIf_</a> = typename <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; Condition, T &gt;::Type</td></tr>
<tr class="memdesc:ga4921d0157490569e91b4f48652561d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template.The EnableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">More...</a><br /></td></tr>
<tr class="separator:ga4921d0157490569e91b4f48652561d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e5b7b706f77970ca22837afa80d8ef"><td class="memItemLeft" align="right" valign="top"><a id="ga24e5b7b706f77970ca22837afa80d8ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga24e5b7b706f77970ca22837afa80d8ef">blaze::FalseType</a> = <a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">BoolConstant</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga24e5b7b706f77970ca22837afa80d8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type/value traits base class.The FalseType class is used as base class for type traits and value traits that evaluate to <em>false</em>. <br /></td></tr>
<tr class="separator:ga24e5b7b706f77970ca22837afa80d8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac14970a620e557bc438e65b37004346"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gaac14970a620e557bc438e65b37004346"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">blaze::BoolConstant</a> = <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html">IntegralConstant</a>&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gaac14970a620e557bc438e65b37004346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wrapper for a compile time constant boolean value.The BoolConstant class template represents a generic wrapper for a compile time constant boolean value. The value of a BoolConstant can be accessed via the nested <em>value</em> (which is guaranteed to be of type <code>bool</code>), the type can be accessed via the nested type definition <em>ValueType</em>.  <a href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">More...</a><br /></td></tr>
<tr class="separator:gaac14970a620e557bc438e65b37004346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4e8b3f04b070dc9e532f176e2d21087a">blaze::IfTrue_</a> = typename <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; Condition, T1, T2 &gt;::Type</td></tr>
<tr class="memdesc:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template.The IfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template. For instance, given the types <em>C</em>, <em>T1</em>, and <em>T2</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#ga4e8b3f04b070dc9e532f176e2d21087a">More...</a><br /></td></tr>
<tr class="separator:ga4e8b3f04b070dc9e532f176e2d21087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaba6051ef1bc2e9d5a4722d0449a856a0">blaze::If_</a> = typename <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; T1, T2, T3 &gt;::Type</td></tr>
<tr class="memdesc:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary alias declaration for the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> class template.The If_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> alias declaration. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two type definitions are identical:  <a href="../../d4/d3a/group__util.html#gaba6051ef1bc2e9d5a4722d0449a856a0">More...</a><br /></td></tr>
<tr class="separator:gaba6051ef1bc2e9d5a4722d0449a856a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="memItemLeft" align="right" valign="top"><a id="ga051a0e2cd81c0befe93b4fa1c0e29573"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga051a0e2cd81c0befe93b4fa1c0e29573">blaze::TrueType</a> = <a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">BoolConstant</a>&lt; true &gt;</td></tr>
<tr class="memdesc:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits base class.The TrueType class is used as base class for type traits and value traits that evaluate to <em>true</em>. <br /></td></tr>
<tr class="separator:ga051a0e2cd81c0befe93b4fa1c0e29573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfa48da1e61cdc782220984f8bd8080"><td class="memItemLeft" align="right" valign="top"><a id="ga7bfa48da1e61cdc782220984f8bd8080"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga7bfa48da1e61cdc782220984f8bd8080">blaze::byte_t</a> = unsigned char</td></tr>
<tr class="memdesc:ga7bfa48da1e61cdc782220984f8bd8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte data type of the Blaze library.The <em>byte</em> data type is guaranteed to be an integral data type of size 1. <br /></td></tr>
<tr class="separator:ga7bfa48da1e61cdc782220984f8bd8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa083a2327d8401d9c0597acef9c8e456"><td class="memItemLeft" align="right" valign="top"><a id="gaa083a2327d8401d9c0597acef9c8e456"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa083a2327d8401d9c0597acef9c8e456">blaze::large_t</a> = <a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a></td></tr>
<tr class="memdesc:gaa083a2327d8401d9c0597acef9c8e456"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available signed integer data type. <br /></td></tr>
<tr class="separator:gaa083a2327d8401d9c0597acef9c8e456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bef1357e47d07efa71cb896c23517aa"><td class="memItemLeft" align="right" valign="top"><a id="ga5bef1357e47d07efa71cb896c23517aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5bef1357e47d07efa71cb896c23517aa">blaze::ularge_t</a> = <a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">uint64_t</a></td></tr>
<tr class="memdesc:ga5bef1357e47d07efa71cb896c23517aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available unsigned integer data type. <br /></td></tr>
<tr class="separator:ga5bef1357e47d07efa71cb896c23517aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e302c5d830d74d70120fb0b0f85e949"><td class="memItemLeft" align="right" valign="top"><a id="ga1e302c5d830d74d70120fb0b0f85e949"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga1e302c5d830d74d70120fb0b0f85e949">blaze::id_t</a> = <a class="el" href="../../d4/d3a/group__util.html#ga5bef1357e47d07efa71cb896c23517aa">ularge_t</a></td></tr>
<tr class="memdesc:ga1e302c5d830d74d70120fb0b0f85e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer data type for integral IDs. <br /></td></tr>
<tr class="separator:ga1e302c5d830d74d70120fb0b0f85e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gac4ee49b04d3c3e4b9814e9e0c3c9033d">blaze::checkAlignment</a> (const T *address)</td></tr>
<tr class="memdesc:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the alignment of the given address.  <a href="../../d4/d3a/group__util.html#gac4ee49b04d3c3e4b9814e9e0c3c9033d">More...</a><br /></td></tr>
<tr class="separator:gac4ee49b04d3c3e4b9814e9e0c3c9033d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">blaze::dimensionof</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static evaluation of array dimensions.  <a href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">More...</a><br /></td></tr>
<tr class="separator:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt;, T *&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">blaze::allocate</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dcf/group__vector.html#gab5a3d85c96e5ec1481fe48cd80e663a0">size</a>)</td></tr>
<tr class="memdesc:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned array allocation for built-in data types.  <a href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698">More...</a><br /></td></tr>
<tr class="separator:gaf1a0f267ad32bb5a074fa67bba6cb698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b">blaze::deallocate</a> (T *address) noexcept</td></tr>
<tr class="memdesc:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of memory for built-in data types.  <a href="../../d4/d3a/group__util.html#gacba35bf708a4ea62cdca2a4a18a24c4b">More...</a><br /></td></tr>
<tr class="separator:gacba35bf708a4ea62cdca2a4a18a24c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8322a0e31643eb8201816a377b917f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b8322a0e31643eb8201816a377b917f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga0b8322a0e31643eb8201816a377b917f">blaze::misalignment</a> (const T *address)</td></tr>
<tr class="memdesc:ga0b8322a0e31643eb8201816a377b917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the misalignment of the given address.  <a href="../../d4/d3a/group__util.html#ga0b8322a0e31643eb8201816a377b917f">More...</a><br /></td></tr>
<tr class="separator:ga0b8322a0e31643eb8201816a377b917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga36f2de85c3ad5760de5a1c87e56891f6">blaze::UNUSED_PARAMETER</a> (const Args &amp;...)</td></tr>
<tr class="memdesc:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppression of unused parameter warnings.  <a href="../../d4/d3a/group__util.html#ga36f2de85c3ad5760de5a1c87e56891f6">More...</a><br /></td></tr>
<tr class="separator:ga36f2de85c3ad5760de5a1c87e56891f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Checked delete operations</h2></td></tr>
<tr class="memitem:ga297919e8527a63a9fc784db08841f3af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga297919e8527a63a9fc784db08841f3af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga297919e8527a63a9fc784db08841f3af">blaze::checkedDelete</a> (T *ptr)</td></tr>
<tr class="memdesc:ga297919e8527a63a9fc784db08841f3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-checked <code>delete</code> operation.  <a href="../../d4/d3a/group__util.html#ga297919e8527a63a9fc784db08841f3af">More...</a><br /></td></tr>
<tr class="separator:ga297919e8527a63a9fc784db08841f3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77be235a7c6604689d0c703b69b11b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa77be235a7c6604689d0c703b69b11b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa77be235a7c6604689d0c703b69b11b5">blaze::checkedArrayDelete</a> (T *ptr)</td></tr>
<tr class="memdesc:gaa77be235a7c6604689d0c703b69b11b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-checked <code>delete</code>[] operation.  <a href="../../d4/d3a/group__util.html#gaa77be235a7c6604689d0c703b69b11b5">More...</a><br /></td></tr>
<tr class="separator:gaa77be235a7c6604689d0c703b69b11b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
InputString operators</h2></td></tr>
<tr class="memitem:ga942b82bb3e222d3e7651094a372cabd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">blaze::IsFileName</a> (const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;s)</td></tr>
<tr class="memdesc:ga942b82bb3e222d3e7651094a372cabd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a valid file name.  <a href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">More...</a><br /></td></tr>
<tr class="separator:ga942b82bb3e222d3e7651094a372cabd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">More...</a><br /></td></tr>
<tr class="separator:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">blaze::operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">More...</a><br /></td></tr>
<tr class="separator:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Numeric cast operators</h2></td></tr>
<tr class="memitem:ga3900228765ba060a55e8361467030d67"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3900228765ba060a55e8361467030d67"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3900228765ba060a55e8361467030d67">blaze::numeric_cast</a> (From from)</td></tr>
<tr class="memdesc:ga3900228765ba060a55e8361467030d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked conversion of values of numeric type.  <a href="../../d4/d3a/group__util.html#ga3900228765ba060a55e8361467030d67">More...</a><br /></td></tr>
<tr class="separator:ga3900228765ba060a55e8361467030d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Pointer cast operators</h2></td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">blaze::static_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga297b8d4addf0242658e5b89e9204460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">More...</a><br /></td></tr>
<tr class="separator:ga297b8d4addf0242658e5b89e9204460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">blaze::dynamic_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga6f5e788ec214cce869014db4e8d5366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">More...</a><br /></td></tr>
<tr class="separator:ga6f5e788ec214cce869014db4e8d5366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">blaze::const_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga28219d814bac7718746d5042aef9de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">More...</a><br /></td></tr>
<tr class="separator:ga28219d814bac7718746d5042aef9de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">blaze::reinterpret_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">More...</a><br /></td></tr>
<tr class="separator:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Smart pointer cast operators</h2></td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">blaze::static_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">More...</a><br /></td></tr>
<tr class="separator:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">blaze::dynamic_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">More...</a><br /></td></tr>
<tr class="separator:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">blaze::const_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga618bf0481250b859a7d953d54a31fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">More...</a><br /></td></tr>
<tr class="separator:ga618bf0481250b859a7d953d54a31fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">blaze::reinterpret_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29e5a317853deb66bcd03883873f20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">More...</a><br /></td></tr>
<tr class="separator:ga29e5a317853deb66bcd03883873f20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Time functions</h2></td></tr>
<tr class="memitem:ga4fb888631070076eac5ab46d3caddbd5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">blaze::getDate</a> ()</td></tr>
<tr class="memdesc:ga4fb888631070076eac5ab46d3caddbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated date string in the form YYYY-MM-DD.  <a href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">More...</a><br /></td></tr>
<tr class="separator:ga4fb888631070076eac5ab46d3caddbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3829412570c98a06a4bc95c550da95d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">blaze::getTime</a> ()</td></tr>
<tr class="memdesc:ga3829412570c98a06a4bc95c550da95d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated time and date string.  <a href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">More...</a><br /></td></tr>
<tr class="separator:ga3829412570c98a06a4bc95c550da95d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d046bc597081ad84f727946f245a800"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">blaze::getWcTime</a> ()</td></tr>
<tr class="memdesc:ga2d046bc597081ad84f727946f245a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current wall clock time in seconds.  <a href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">More...</a><br /></td></tr>
<tr class="separator:ga2d046bc597081ad84f727946f245a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">blaze::getCpuTime</a> ()</td></tr>
<tr class="memdesc:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CPU time in seconds.  <a href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">More...</a><br /></td></tr>
<tr class="separator:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae05e3ee65f08fab8e1aff1ef1e0cfc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae05e3ee65f08fab8e1aff1ef1e0cfc7f">&#9670;&nbsp;</a></span>BLAZE_FUNCTION_TRACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_FUNCTION_TRACE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function trace macro.This macro can be used to reliably trace function calls. In case function tracing is activated, function traces are written to the console via <code>std::cerr</code>. The following short example demonstrates how the function trace macro is used: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">   <a class="code" href="../../d4/d3a/group__util.html#gae05e3ee65f08fab8e1aff1ef1e0cfc7f">BLAZE_FUNCTION_TRACE</a>;</div><div class="line"></div><div class="line">   <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>The macro should be used as the very first statement inside the function in order to guarantee that writing the function trace is the very first and last action of the function call.<br />
Function tracing can be enabled or disabled via the BLAZE_USE_FUNCTION_TRACES macro. If function tracing is activated, trace information of the following form will be written to <code>std::cerr:</code> </p>
<div class="fragment"><div class="line">+ [Thread 0] Entering <span class="keyword">function</span> <span class="stringliteral">&#39;int main()&#39;</span> in file <span class="stringliteral">&#39;TraceDemo.cpp&#39;</span></div><div class="line">- [Thread 0] Leaving <span class="keyword">function</span> <span class="stringliteral">&#39;int main()&#39;</span> in file <span class="stringliteral">&#39;TraceDemo.cpp&#39;</span></div></div><!-- fragment --><p>In case function tracing is deactivated, all function trace functionality is completely removed from the code, i.e. no function traces are logged and no overhead results from the BLAZE_FUNCTION_TRACE macro. </p>

</div>
</div>
<a id="ga7a1571017e950fdea89e519e2c25c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1571017e950fdea89e519e2c25c20d">&#9670;&nbsp;</a></span>BLAZE_THROW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EXCEPTION</td><td>)</td>
          <td>&#160;&#160;&#160;throw EXCEPTION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the error reporting mechanism of the <b>Blaze</b> library.This macro encapsulates the default, general way of the <b>Blaze</b> library to report errors of any kind by throwing an exception. Also, since under certain conditions and environments it may be desirable to replace exceptions by a different error reporting mechanism this macro provides an opportunity to customize the error reporting approach. </p>
<p>The macro excepts a single argument, which specifies the exception to be thrown:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW( EXCEPTION ) \</span></div><div class="line"><span class="preprocessor">   throw EXCEPTION</span></div></div><!-- fragment --><p>In order to customize the error reporing mechanism all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will cause the <b>Blaze</b> specific mechanism to be overridden. The following example demonstrates this by replacing exceptions by a call to a <em><a class="el" href="../../db/df0/group__dense__matrix.html#ga33c9b9a39f0e7c6637b6af4f5e252e7a" title="Computes the natural logarithm for each single element of the dense matrix dm. ">log()</a></em> function and a direct call to abort:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW( EXCEPTION ) \</span></div><div class="line"><span class="preprocessor">   log( &quot;...&quot; ); \</span></div><div class="line"><span class="preprocessor">   abort()</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is possible to execute several statements instead of executing a single statement to throw an exception. Also note that it is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the error reporting mechanism via this macro can have a significant effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="gafa1075e5bf9b7acdf72d01d150d7f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa1075e5bf9b7acdf72d01d150d7f0a5">&#9670;&nbsp;</a></span>BLAZE_THROW_BAD_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_BAD_ALLOC&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::bad_alloc() )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::bad_alloc</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::bad_alloc</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_BAD_ALLOC \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::bad_alloc() )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::bad_alloc</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>BadAlloc</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   BadAlloc();</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_BAD_ALLOC \</span></div><div class="line"><span class="preprocessor">   throw BadAlloc()</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="gac1011720c48bdd5ad4d83cfb4c7fd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1011720c48bdd5ad4d83cfb4c7fd3ee">&#9670;&nbsp;</a></span>BLAZE_THROW_INVALID_ARGUMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_INVALID_ARGUMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::invalid_argument( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::invalid_argument</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::invalid_argument</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_INVALID_ARGUMENT( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::invalid_argument( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::invalid_argument</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>InvalidArgument</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   InvalidArgument();</div><div class="line">   <span class="keyword">explicit</span> InvalidArgument( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_INVALID_ARGUMENT( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw InvalidArgument( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="ga5062f7037528793700d2920a1b07c7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5062f7037528793700d2920a1b07c7ee">&#9670;&nbsp;</a></span>BLAZE_THROW_LENGTH_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_LENGTH_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::length_error( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::length_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::length_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_LENGTH_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::length_error( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::length_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LengthError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   LengthError();</div><div class="line">   <span class="keyword">explicit</span> LengthError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_LENGTH_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw LengthError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="gac9df3ec894be73c8bbe412794fad80b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9df3ec894be73c8bbe412794fad80b3">&#9670;&nbsp;</a></span>BLAZE_THROW_LOGIC_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_LOGIC_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::logic_error( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::logic_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::logic_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_LOGIC_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::logic_error( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::logic_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LogicError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   LogicError();</div><div class="line">   <span class="keyword">explicit</span> LogicError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_LOGIC_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw LogicError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="gaafc93ac25c865f07b82286c432f4173a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafc93ac25c865f07b82286c432f4173a">&#9670;&nbsp;</a></span>BLAZE_THROW_OUT_OF_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_OUT_OF_RANGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::out_of_range( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::out_of_range</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::out_of_range</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_OUT_OF_RANGE( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::out_of_range( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::out_of_range</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OutOfRange</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   OutOfRange();</div><div class="line">   <span class="keyword">explicit</span> OutOfRange( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_OUT_OF_RANGE( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw OutOfRange( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="ga748daff02e5fb84a1e83e37f15ab05ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748daff02e5fb84a1e83e37f15ab05ab">&#9670;&nbsp;</a></span>BLAZE_THROW_OVERFLOW_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_OVERFLOW_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::overflow_error( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::overflow_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::overflow_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_OVERFLOW_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::overflow_error( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::overflow_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OverflowError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   OverflowError();</div><div class="line">   <span class="keyword">explicit</span> OverflowError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_OVERFLOW_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw OverflowError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="ga2d588d35b3322949abb3a1e1c5ea3355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d588d35b3322949abb3a1e1c5ea3355">&#9670;&nbsp;</a></span>BLAZE_THROW_RUNTIME_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_RUNTIME_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::runtime_error( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::runtime_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::runtime_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_RUNTIME_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::runtime_error( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::runtime_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RuntimeError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   RuntimeError();</div><div class="line">   <span class="keyword">explicit</span> RuntimeError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_RUNTIME_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw RuntimeError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<a id="ga5af4c698d5aa64a2e1f3403183a8bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af4c698d5aa64a2e1f3403183a8bdc2">&#9670;&nbsp;</a></span>BLAZE_THROW_UNDERFLOW_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_THROW_UNDERFLOW_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MESSAGE</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d4/d3a/group__util.html#ga7a1571017e950fdea89e519e2c25c20d">BLAZE_THROW</a>( std::underflow_error( MESSAGE ) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the emission of a <em>std::underflow_error</em> exception.This macro encapsulates the default way of <b>Blaze</b> to throw a <em>std::underflow_error</em> exception. Also, since it may be desirable to replace the type of exception by a custom exception type this macro provides an opportunity to customize the behavior. </p>
<p>The macro excepts a single argument, which specifies the message of the exception:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BLAZE_THROW_UNDERFLOW_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   BLAZE_THROW( std::underflow_error( MESSAGE ) )</span></div></div><!-- fragment --><p>In order to customize the type of exception all that needs to be done is to define the macro prior to including any <em>Blaze</em> header file. This will override the <b>Blaze</b> default behavior. The following example demonstrates this by replacing <em>std::underflow_error</em> by a custom exception type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>UnderflowError</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   UnderflowError();</div><div class="line">   <span class="keyword">explicit</span> UnderflowError( <span class="keyword">const</span> std::string&amp; message );</div><div class="line">   <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define BLAZE_THROW_UNDERFLOW_ERROR( MESSAGE ) \</span></div><div class="line"><span class="preprocessor">   throw UnderflowError( MESSAGE )</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d52/Blaze_8h.html">blaze/Blaze.h</a>&gt;</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to define the macro such that a subsequent semicolon is required!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro is provided with the intention to assist in adapting <b>Blaze</b> to special conditions and environments. However, the customization of the type of exception via this macro may have an effect on the library. Thus be advised to use the macro with due care! </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaac14970a620e557bc438e65b37004346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac14970a620e557bc438e65b37004346">&#9670;&nbsp;</a></span>BoolConstant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#gaac14970a620e557bc438e65b37004346">blaze::BoolConstant</a> = typedef <a class="el" href="../../de/d59/structblaze_1_1IntegralConstant.html">IntegralConstant</a>&lt;bool,B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic wrapper for a compile time constant boolean value.The BoolConstant class template represents a generic wrapper for a compile time constant boolean value. The value of a BoolConstant can be accessed via the nested <em>value</em> (which is guaranteed to be of type <code>bool</code>), the type can be accessed via the nested type definition <em>ValueType</em>. </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/de9/namespaceblaze.html">blaze</a>;</div><div class="line"></div><div class="line"><a class="code" href="../../de/d59/structblaze_1_1IntegralConstant.html">BoolConstant&lt;true&gt;::value</a>       <span class="comment">// Evaluates to true</span></div><div class="line"><a class="code" href="../../de/d59/structblaze_1_1IntegralConstant.html">BoolConstant&lt;false&gt;::ValueType</a>  <span class="comment">// Results in bool</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gaebf93d6ed8011a7e73476b7d9c34f656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebf93d6ed8011a7e73476b7d9c34f656">&#9670;&nbsp;</a></span>DisableIf_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Condition , typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#gaebf93d6ed8011a7e73476b7d9c34f656">blaze::DisableIf_</a> = typedef typename <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt;Condition,T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary type for the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template.The DisableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DisableIf&lt; IsBuiltin&lt;T&gt; &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DisableIf_&lt; IsBuiltin&lt;T&gt; &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gab69bc69a73945474ec1e28eb904b4c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab69bc69a73945474ec1e28eb904b4c40">&#9670;&nbsp;</a></span>DisableIfTrue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#gab69bc69a73945474ec1e28eb904b4c40">blaze::DisableIfTrue_</a> = typedef typename <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">DisableIfTrue</a>&lt;Condition,T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary type for the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template.The DisableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> DisableIfTrue&lt; IsBuiltin&lt;T&gt;::value &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = DisableIfTrue_&lt; IsBuiltin&lt;T&gt;::value &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4921d0157490569e91b4f48652561d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4921d0157490569e91b4f48652561d2b">&#9670;&nbsp;</a></span>EnableIf_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Condition , typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">blaze::EnableIf_</a> = typedef typename <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt;Condition,T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template.The EnableIf_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> EnableIf&lt; IsBuiltin&lt;T&gt; &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = EnableIf_&lt; IsBuiltin&lt;T&gt; &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaffd728948d7bb8402576d198a5b219ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd728948d7bb8402576d198a5b219ed">&#9670;&nbsp;</a></span>EnableIfTrue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#gaffd728948d7bb8402576d198a5b219ed">blaze::EnableIfTrue_</a> = typedef typename <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">EnableIfTrue</a>&lt;Condition,T&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary type for the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template.The EnableIfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template. For instance, given the type <em>T</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> EnableIfTrue&lt; IsBuiltin&lt;T&gt;::value &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = EnableIfTrue_&lt; IsBuiltin&lt;T&gt;::value &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="gaba6051ef1bc2e9d5a4722d0449a856a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba6051ef1bc2e9d5a4722d0449a856a0">&#9670;&nbsp;</a></span>If_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#gaba6051ef1bc2e9d5a4722d0449a856a0">blaze::If_</a> = typedef typename <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt;T1,T2,T3&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> class template.The If_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If alias declaration selects one of the two given types T2 and T3 dep...">If</a> alias declaration. For instance, given the types <em>T1</em>, <em>T2</em>, and <em>T3</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> If&lt; IsBuiltin&lt;T1&gt;, T2, T3 &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = If_&lt; IsBuiltin&lt;T1&gt;, T2, T3 &gt;;</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4e8b3f04b070dc9e532f176e2d21087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8b3f04b070dc9e532f176e2d21087a">&#9670;&nbsp;</a></span>IfTrue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d4/d3a/group__util.html#ga4e8b3f04b070dc9e532f176e2d21087a">blaze::IfTrue_</a> = typedef typename <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt;Condition,T1,T2&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary alias declaration for the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template.The IfTrue_ alias declaration provides a convenient shortcut to access the nested <em>Type</em> of the <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template. For instance, given the types <em>C</em>, <em>T1</em>, and <em>T2</em> the following two type definitions are identical: </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Type1 = <span class="keyword">typename</span> IfTrue&lt; IsBuiltin&lt;C&gt;::value, T1, T2 &gt;::Type;</div><div class="line"><span class="keyword">using</span> Type2 = IfTrue_&lt; IsBuiltin&lt;C&gt;::value, T1, T2 &gt;;</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf1a0f267ad32bb5a074fa67bba6cb698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1a0f267ad32bb5a074fa67bba6cb698">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt;, T* &gt; blaze::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned array allocation for built-in data types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements of the given type to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of the aligned array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">allocate()</a> function provides the functionality to allocate memory based on the alignment restrictions of the given built-in data type. For instance, in case SSE vectorization is possible, the returned memory is guaranteed to be at least 16-byte aligned. In case AVX is active, the memory is even guaranteed to be at least 32-byte aligned.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Guaranteed to be 16-byte aligned (32-byte aligned in case AVX is used)</span></div><div class="line"><span class="keywordtype">double</span>* dp = allocate&lt;double&gt;( 10UL );</div></div><!-- fragment --> 
</div>
</div>
<a id="gac4ee49b04d3c3e4b9814e9e0c3c9033d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ee49b04d3c3e4b9814e9e0c3c9033d">&#9670;&nbsp;</a></span>checkAlignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool blaze::checkAlignment </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the alignment of the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the address is properly aligned, <em>false</em> if it is not.</dd></dl>
<p>This function performs an alignment check on the given address. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. In case the given address is properly aligned, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a id="gaa77be235a7c6604689d0c703b69b11b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa77be235a7c6604689d0c703b69b11b5">&#9670;&nbsp;</a></span>checkedArrayDelete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::checkedArrayDelete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type-checked <code>delete</code>[] operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the array to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function frees the given pointer resource via <code>delete</code>[]. Note that the <code>delete</code>[] operation is NOT permitted for incomplete types (i.e. declared but undefined data types). The attempt to use this function for a pointer to an array of objects of incomplete type results in a compile time error! </p>

</div>
</div>
<a id="ga297919e8527a63a9fc784db08841f3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297919e8527a63a9fc784db08841f3af">&#9670;&nbsp;</a></span>checkedDelete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::checkedDelete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type-checked <code>delete</code> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function frees the given pointer resource via <code>delete</code>. Note that the <code>delete</code> operation is NOT permitted for incomplete types (i.e. declared but undefined data types). The attempt to use this function for a pointer to an object of incomplete type results in a compile time error! </p>

</div>
</div>
<a id="ga28219d814bac7718746d5042aef9de09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28219d814bac7718746d5042aef9de09">&#9670;&nbsp;</a></span>const_pointer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The const_pointer_cast function is used exactly as the built-in const_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div><div class="line"></div><div class="line"><span class="keyword">const</span> A* a1;                          <span class="comment">// Pointer to a constant A object</span></div><div class="line">A* a2 = <a class="code" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">const_pointer_cast</a>&lt;A&gt;( a1 );  <span class="comment">// Const cast to a pointer to a non-constant A object</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga618bf0481250b859a7d953d54a31fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618bf0481250b859a7d953d54a31fffa">&#9670;&nbsp;</a></span>const_pointer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The const_pointer_cast function is used exactly as the built-in const_cast operator but for smart pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div><div class="line"></div><div class="line"><span class="keyword">using</span> APtr      = SharedPtr&lt;A&gt;;</div><div class="line"><span class="keyword">using</span> ConstAPtr = SharedPtr&lt;const A&gt;;</div><div class="line"></div><div class="line">ConstAPtr a1;                           <span class="comment">// Smart pointer to a constant A object</span></div><div class="line">APtr a2 = <a class="code" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">const_pointer_cast</a>&lt;A&gt;( a1 );  <span class="comment">// Const cast to a smart pointer to a non-constant A object</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gacba35bf708a4ea62cdca2a4a18a24c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba35bf708a4ea62cdca2a4a18a24c4b">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d3a/group__util.html#ga4921d0157490569e91b4f48652561d2b">EnableIf_</a>&lt; <a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a>&lt;T&gt; &gt; blaze::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocation of memory for built-in data types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the first element of the array to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function deallocates the given memory that was previously allocated via the <a class="el" href="../../d4/d3a/group__util.html#gaf1a0f267ad32bb5a074fa67bba6cb698" title="Aligned array allocation for built-in data types. ">allocate()</a> function. </p>

</div>
</div>
<a id="gaceb0ea831c8a56b9212d7a55e10ea5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb0ea831c8a56b9212d7a55e10ea5a4">&#9670;&nbsp;</a></span>dimensionof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::dimensionof </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static evaluation of array dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Reference to a static array of type T and size N. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dimension of the static array.</dd></dl>
<p>The dimensionof function is a safe way to evaluate the size of an array. The function only works for array arguments and fails for pointers and user-defined class types.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>              ai[ 42 ];</div><div class="line"><span class="keywordtype">int</span>*             pi( ai );</div><div class="line">std::vector&lt;int&gt; vi( 42 );</div><div class="line"></div><div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">dimensionof</a>( ai );  <span class="comment">// Returns the size of the integer array (42)</span></div><div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">dimensionof</a>( pi );  <span class="comment">// Fails to compile!</span></div><div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">dimensionof</a>( vi );  <span class="comment">// Fails to compile!</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga6f5e788ec214cce869014db4e8d5366e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f5e788ec214cce869014db4e8d5366e">&#9670;&nbsp;</a></span>dynamic_pointer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The dynamic_pointer_cast function is used exactly as the built-in dynamic_cast operator but for pointer types. As in case with the built-in dynamic_cast 0 is returned if the runtime type conversion doesn't succeed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div><div class="line"></div><div class="line">B* b = ...;                           <span class="comment">// Base pointer</span></div><div class="line">D* d = <a class="code" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">dynamic_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Dynamic down-cast</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga29989fd5881d9e3d3204be7cc9c7c3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29989fd5881d9e3d3204be7cc9c7c3db">&#9670;&nbsp;</a></span>dynamic_pointer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The dynamic_pointer_cast function is used exactly as the built-in dynamic_cast operator but for smart pointers. As in case with the built-in dynamic_cast 0 is returned if the runtime type conversion doesn't succeed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div><div class="line"></div><div class="line"><span class="keyword">using</span> BPtr = SharedPtr&lt;B&gt;;</div><div class="line"><span class="keyword">using</span> DPtr = SharedPtr&lt;D&gt;;</div><div class="line"></div><div class="line">BPtr b = ...;                           <span class="comment">// Base smart pointer</span></div><div class="line">DPtr d = <a class="code" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">dynamic_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Dynamic down-cast</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga2ff2b8c34d2384faa6b3e97954b98e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff2b8c34d2384faa6b3e97954b98e78">&#9670;&nbsp;</a></span>getCpuTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double blaze::getCpuTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current CPU time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The current CPU time in seconds. </dd></dl>

</div>
</div>
<a id="ga4fb888631070076eac5ab46d3caddbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb888631070076eac5ab46d3caddbd5">&#9670;&nbsp;</a></span>getDate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string blaze::getDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a formated date string in the form YYYY-MM-DD. </p>
<dl class="section return"><dt>Returns</dt><dd>Formated date string </dd></dl>

</div>
</div>
<a id="ga3829412570c98a06a4bc95c550da95d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3829412570c98a06a4bc95c550da95d8">&#9670;&nbsp;</a></span>getTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string blaze::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a formated time and date string. </p>
<dl class="section return"><dt>Returns</dt><dd>Formated time and date string in the format WEEKDAY DAY.MONTH YEAR, HOUR:MINUTES </dd></dl>

</div>
</div>
<a id="ga2d046bc597081ad84f727946f245a800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d046bc597081ad84f727946f245a800">&#9670;&nbsp;</a></span>getWcTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double blaze::getWcTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current wall clock time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The current wall clock time in seconds. </dd></dl>

</div>
</div>
<a id="ga942b82bb3e222d3e7651094a372cabd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga942b82bb3e222d3e7651094a372cabd6">&#9670;&nbsp;</a></span>IsFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::IsFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for a valid file name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The file name string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the string is a file name, <em>false</em> if it is not.</dd></dl>
<p>In order to be a file name, the first character can only be an alphanumerical character, '.', '/' or '_'. </p>

</div>
</div>
<a id="ga0b8322a0e31643eb8201816a377b917f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8322a0e31643eb8201816a377b917f">&#9670;&nbsp;</a></span>misalignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::misalignment </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the misalignment of the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes the given address is misaligned.</dd></dl>
<p>This function computes the misalignment of the given address with respect to the given data type <em>Type</em> and the available instruction set (SSE, AVX, ...). It returns the number of bytes the address is larger than the next smaller properly aligned address. </p>

</div>
</div>
<a id="ga3900228765ba060a55e8361467030d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3900228765ba060a55e8361467030d67">&#9670;&nbsp;</a></span>numeric_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To blaze::numeric_cast </td>
          <td>(</td>
          <td class="paramtype">From&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked conversion of values of numeric type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The numeric value to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>Invalid numeric cast (overflow). </td></tr>
    <tr><td class="paramname">std::underflow_error</td><td>Invalid numeric cast (underflow).</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts the given numeric value <em>from</em> to the specified type <em>To</em>. In case a loss of range is detected, either a <em>std::underflow_error</em> or <em>std::overflow_error</em> exception is thrown.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Triggers a std::overflow_error exception</span></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> a( <a class="code" href="../../db/df0/group__dense__matrix.html#ga6ae2749f3a298c7927a4f7f85407e2c4">std::numeric_limits&lt;int&gt;::max</a>() );</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">short</span> b( blaze::numeric_cast&lt;short&gt;( a ) );</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>( std::overflow_error&amp; ) {}</div><div class="line"></div><div class="line"><span class="comment">// Triggers a std::underflow_error exception</span></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> a( -1 );</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b( blaze::numeric_cast&lt;unsigned int&gt;( a ) );</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>( std::underflow_error&amp; ) {}</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa1ba7ee1b13541bf5bef5cb2eaf66207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ba7ee1b13541bf5bef5cb2eaf66207">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">str</td><td>Reference to a string object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="ga80a4395873ec4d104b68f12f5e9dc29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a4395873ec4d104b68f12f5e9dc29f">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; blaze::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Reference to the input stream. </td></tr>
    <tr><td class="paramname">str</td><td>Reference to a string object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream.</dd></dl>
<p>The input operator guarantees that the string object is not changed in the case of an input error. </p>

</div>
</div>
<a id="ga3e7e73afb20167f3b3dc8f1a032b98c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e7e73afb20167f3b3dc8f1a032b98c4">&#9670;&nbsp;</a></span>reinterpret_pointer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The reinterpret_pointer_cast function is used exactly as the built-in reinterpret_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* raw = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[ <span class="keyword">sizeof</span>(A)*10 ];  <span class="comment">// Allocation of raw memory</span></div><div class="line">A* a = <a class="code" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">reinterpret_pointer_cast</a>&lt;A&gt;( raw );               <span class="comment">// Reinterpretation cast</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga29e5a317853deb66bcd03883873f20ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e5a317853deb66bcd03883873f20ee">&#9670;&nbsp;</a></span>reinterpret_pointer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The reinterpret_pointer_cast function is used exactly as the built-in reinterpret_cast operator but for smart pointers. </p>

</div>
</div>
<a id="ga297b8d4addf0242658e5b89e9204460f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297b8d4addf0242658e5b89e9204460f">&#9670;&nbsp;</a></span>static_pointer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The static_pointer_cast function is used exactly as the built-in static_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div><div class="line"></div><div class="line">B* b = <span class="keyword">new</span> D();                      <span class="comment">// Base pointer to a derived class object</span></div><div class="line">D* d = <a class="code" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">static_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Static down-cast</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga70575290b13daca96bd7bcdf1ea2ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70575290b13daca96bd7bcdf1ea2ae65">&#9670;&nbsp;</a></span>static_pointer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The static_pointer_cast function is used exactly as the built-in static_cast operator but for smart pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div><div class="line"></div><div class="line"><span class="keyword">using</span> BPtr = SharedPtr&lt;B&gt;;</div><div class="line"><span class="keyword">using</span> DPtr = SharedPtr&lt;D&gt;;</div><div class="line"></div><div class="line">BPtr b = BPtr( <span class="keyword">new</span> D() );              <span class="comment">// Base smart pointer to a derived class object</span></div><div class="line">DPtr d = <a class="code" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">static_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Static down-cast</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ga36f2de85c3ad5760de5a1c87e56891f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36f2de85c3ad5760de5a1c87e56891f6">&#9670;&nbsp;</a></span>UNUSED_PARAMETER()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::UNUSED_PARAMETER </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppression of unused parameter warnings. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>The UNUSED_PARAMETER function provides the functionality to suppress warnings about any number of unused parameters. Usually this problem occurs in case a parameter is given a name but is not used within the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f( <span class="keywordtype">int</span> x )</div><div class="line">{}  <span class="comment">// x is not used within f. This may result in an unused parameter warning.</span></div></div><!-- fragment --><p>A possible solution is to keep the parameter unnamed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f( <span class="keywordtype">int</span> )</div><div class="line">{}  <span class="comment">// No warning about unused parameter is issued</span></div></div><!-- fragment --><p>However, there are situations where is approach is not possible, as for instance in case the variable must be documented via Doxygen. For these cases, the UNUSED_PARAMETER class can be used to suppress the warnings:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f( <span class="keywordtype">int</span> x )</div><div class="line">{</div><div class="line">   <a class="code" href="../../d4/d3a/group__util.html#ga36f2de85c3ad5760de5a1c87e56891f6">UNUSED_PARAMETER</a>( x );  <span class="comment">// Suppresses the unused parameter warnings</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 18 2017 05:50:25 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
